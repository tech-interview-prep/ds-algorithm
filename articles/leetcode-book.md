Copyright
=========

The content of this book comes from [leetcode.com](http://leetcode.com)
and all rights belong to the site.

This book is made by Jing Zhou. Email gnijuohz@gmail.com to report
questions or issues

A Distance Maximizing Problem
=============================

May 19, 2011 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> Given an array A of integers, find the maximum of j-i subjected to the
> constraint of A[i]

<span id="more-765"></span>  
 **Hint:**  
 This problem seemed easy, maybe because it is easy to understand. But
is it straightforward to solve? If you are thinking of a straightforward
solution, think again. Try to come up with a solution with run time
complexity of O(n log n). Can you do better than that?

**Solution:**

[![](http://www.leetcode.com/wp-content/uploads/2011/05/height_bars.gif "height_bars")](http://www.leetcode.com/wp-content/uploads/2011/05/height_bars.gif)Visualization
of the problem using *n* vertical lines. The i<sup>th</sup> line’s
height is represented by A[i], assuming A[i] is positive.

We are able to visualize the above problem better by drawing *n*
vertical lines, where the height of i<sup>th</sup> line corresponds to
the i<sup>th</sup> element in A. We first assume that all elements in A
are positive integers, but later it can be expanded to non-positive
integers as well. Now, unless the elements in A forms a strictly
non-increasing order, there must exist a pair of (i, j) such that A[i]

**Brute Force O(N<sup>2</sup>)**  
 The straightforward brute force way is to find the shortest line (the
starting index, i), then try to look toward the right side (the ending
index, j) and find a taller line with the furthest distance. Record the
distance (j-i)and repeat with the next shortest line. Clearly, this is
an O(N<sup>2</sup>) algorithm and we can do better.

**Sorting O(N log N)**

[![](http://www.leetcode.com/wp-content/uploads/2011/05/sorted_bar_lines1.gif "sorted_bar_lines")](http://www.leetcode.com/wp-content/uploads/2011/05/sorted_bar_lines1.gif)
Above diagram shows *n* lines sorted according its heights. Lines with
same heights are sorted using its original index. We will also need to
keep track of each line’s original index in order to calculate the
distance later. Finally, we build a table by scanning the lines’
original index from right to left once.

By sorting the lines according to its height, we can achieve better run
time complexity. Notice that once we sorted the lines, we are able to
find the maximum distance in O(N) time. For each possible original
starting index i, we find the original ending index j, which is the
maximum among all j’s where A[j] \> A[i]. To enable the quick search for
the maximum, we can build a look up table in O(N) time by scanning from
right to left once. For example, we start with index i = 4, which is the
shortest line. We know the maximum of all original indices to the right
is 7, therefore max distance = 7 – 4 = 3. For the next line which
original index is 3, the max distance = 7 – 3 = 4. Now, we must skip
over the duplicates and reach the line with its original index 1. Here,
we must be careful to skip over all duplicate heights which are not part
of the solution because not satisfying the constraint A[j] \> A[i].
Therefore, the max distance for this case = 2 – 1 = 1.

**Best Solution O(N)**

[](http://www.leetcode.com/wp-content/uploads/2011/05/height_bars_start.gif)[![](http://www.leetcode.com/wp-content/uploads/2011/05/height_bars_start1.gif "height_bars_start")](http://www.leetcode.com/wp-content/uploads/2011/05/height_bars_start1.gif)Given
two indices a and b, where would you rather choose as a potential
starting point?

Credits for the best O(N) solution goes to **<span>darksteel</span>**,
which I first learned this neat method from him.
[Anonymous](http://www.leetcode.com/2011/05/a-distance-maximizing-problem.html#comment-1122)
is the only reader who is able to solve this correctly using the same
idea, great job!

Solving this problem efficiently requires some clever observations to
eliminate all unnecessary comparisons. It is non obvious to me at first
if there exists an O(N) algorithm for this problem.

Please look at the above diagram carefully, and ask yourself if you
would choose index a or b as a potential starting point. Clearly, you
would never choose index b as the starting point. Why?

Assume that choosing index b as the starting point, the max distance is
j-b, where A[j] \> A[b]. Now, since a A[a], we can form a farther
distance by choosing a as the starting index. Therefore, we cannot
choose b as the starting point as this forms a contradiction.

Generally, we want to choose only starting points with no such lines
that are shorter to its left side. From the diagram above, only lines of
index 0, 1, 3, 4 are valid starting points.

Once we gather all valid starting points by scanning once from left to
right, we are able to obtain the maximum distance by scanning backwards.

It is obvious that if the ending point is less than the shortest
starting point, then it won’t be a valid solution for all other starting
points. Therefore, we scan from right to left until we meet the first
ending point that satisfies the condition. Then, we proceed to the next
shortest starting point, and continue on from the previous ending point.
Using this strategy, we would guarantee that we are able to find the
maximum distance in O(N) running time.

**To be continued…**

VN:F [1.9.22\_1171]

Rating: 4.0/**5** (30 votes cast)

<span class="hreview-aggregate"><span class="item"><span class="fn">A
Distance Maximizing Problem</span></span>, <span class="rating"><span
class="average">4.0</span> out of <span class="best">5</span> based on
<span class="votes">30</span> ratings <span
class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2011/05/a-distance-maximizing-problem.html>

> Given the sequence **S1** = {a,b,c,d,…,x,y,z,aa,ab,ac…. } and given
> that this sequence corresponds (term for term) to the sequence **S2**
> = {0,1,2,3,….}. Write code to convert an element of **S2** to the
> corresponding element of **S1**.

<span id="more-45"></span>

Your challenge, should you accept it, is to code this problem correctly
on your first try. Without any help from the computer of course
![:)](http://leetcode.com/wp-includes/images/smilies/icon_smile.gif) You
might think you have the idea to solve it but it is tricky to code it
correctly.

**Hint:**  
****  
I’ve created the following table for your convenience.

          a - 0     aa - 26   .....   za - 676    aaa - 702
          b - 1     ab - 27   .....   zb - 677    aab - 703
          c - 2        .                 .            .
            .          .                 .            .
            .          .                 .            .
            .          .                 .            .
          z - 25    az - 51   .....   zz - 701    aaz - 727

From **a-z**, how many of them are there? How about **aa-zz**? And
**aaa-zzz**?

**Solution:**  
You should be able to observe that from **a-z** (a total of **26**),
from **aa-zz** (a total of **26<sup>2</sup>**), from **aaa-zzz** (a
total of **26<sup>3</sup>**), and so on… I will explain why this is
important later.

Assume ***s*<sub>1</sub>** = **abc** and we need to find its
corresponding number, ***s*<sub>2</sub>**. Now imagine that **aaa** can
be magically transformed to **000**, **aab** –\> **001**, …, and **abc**
to some number *xyz*. The question is, what should *xyz* be?

Now this is a trivial question. Why? Remember that our numeral system
has 10 as its base. Here, we are merely converting the system from base
26 to base 10. Therefore, *xyz* = **2**\***26<sup>0</sup>** +
**1**\***26<sup>1</sup>** + **0**\***26<sup>2</sup>** = **28**.

But wait, we are not finished yet. To find the real value of
***s*<sub>2</sub>**, we need to find how many of them appeared before
**aaa** and add to *xyz*. Using the important observation earlier, we
can easily determine that that there are a total of **26** +
**26<sup>2</sup>** **** = **702** that appeared before **aaa**.
Therefore, ***s*<sub>1</sub>** corresponds to the number
***s*<sub>2</sub>** = **28** + **702** = **730**.

Assume that we are converting from ***s*<sub>2</sub>** = *n* to
***s***<sub>**1**</sub> = “abcde…”.  
We can generalize to the following equation (Equation **(1)**):

    Equation (1)

    n = 26 + 262 + ... + 26k-1 + a0 + a1*26 + a2*262 + ... + ak-1*26k-1
      = a0 + (a1 + 1) 26 + (a2 + 1) 262 + ... + (ak-1 + 1) 26k-1 

    where 
    ai ranges from 0-25 (each representing a letter in s1), 
    k is the number of letters in s1.

To solve the above equation, we have to find the values of
*a*<sub>0</sub>*, a*<sub>1</sub>*, …, a*<sub>*k*-1</sub>. Once we solve
this equation, we are able to determine the string of letters of
***s*<sub>1</sub>** directly.

*a*<sub>0</sub> can be solved by taking *n* % 26. Why? Because
*a*<sub>0</sub> ranges from 0-25, which is not divisible by 26, while
the rest are factor of 26. After we obtained the value of
*a*<sub>0</sub>, we divide *n* by 26. This will yield the number

    n' = (a1 + 1) + (a2 + 1) 26 + ... + (ak-1 + 1) 26k-2

You might think that *a*<sub>1</sub> + 1 = *n’* % 26. This is wrong.
What happens when *a*<sub>1</sub> = 25? For sure, *a*<sub>1</sub> +1 is
divisible by 26, and thus the mentioned equation is invalid. We can
easily resolve this by doing *a*<sub>1</sub> = (*n’* – 1) % 26.

The rest is easy, we continue further with *n”* = (*n’* – 1) / 26 and
*a*<sub>2</sub> = (*n”* – 1) % 26, up until *a*<sub>k-1</sub>.

Clearly, we need to do both modulo 26 and divide by 26 operations a
total of *k*-1 times. But do we really need to know the value of *k* (or
the number of letters in *s*<sub>1</sub>)?

The beauty of this method is, since we start from the least significant
digit and work our way up, we don’t need to evaluate *k*. We just need
to divide *n* by 26 repeatedly until it becomes 0.

string numToStr(int n) { string str(1, 'a' + n%26); n = n/26; while (n
!= 0) { str = (char)('a' + (n-1)%26) + str; n = (n-1)/26; } return str;
}
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">string</span><span class="h"> </span><span class="e">numToStr</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">string</span><span class="h"> </span><span class="e">str</span><span class="sy">(</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="s">'a'</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="i">n</span><span class="o">%</span><span class="cn">26</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">n</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">n</span><span class="o">/</span><span class="cn">26</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">str</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="t">char</span><span class="sy">)</span><span class="sy">(</span><span class="s">'a'</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="o">%</span><span class="cn">26</span><span class="sy">)</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="i">str</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">n</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="o">/</span><span class="cn">26</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">str</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**<span>Alternative Solution:</span>**  
The above solution can be converted to a recursive solution too. The
advantage is the recursive solution can print the solution directly
without storing the characters into a variable. Check my post:
[Recursion to the
Rescue!](http://www.leetcode.com/2010/02/here-is-one-of-questions-from-microsoft.html)
where recursion is used to reverse a string.

void numToStrHelper(int n) { if (n == 0) return;
numToStrHelper((n-1)/26); cout \<\< (char)('a'+(n-1)%26); } void
numTostr(int n) { numToStrHelper(n/26); cout \<\< (char)('a'+n%26); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">numToStrHelper</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">n</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">numToStrHelper</span><span class="sy">(</span><span class="sy">(</span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="o">/</span><span class="cn">26</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="t">char</span><span class="sy">)</span><span class="sy">(</span><span class="s">'a'</span><span class="o">+</span><span class="sy">(</span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="o">%</span><span class="cn">26</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">void</span><span class="h"> </span><span class="e">numTostr</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="e">numToStrHelper</span><span class="sy">(</span><span class="i">n</span><span class="o">/</span><span class="cn">26</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="t">char</span><span class="sy">)</span><span class="sy">(</span><span class="s">'a'</span><span class="o">+</span><span class="i">n</span><span class="o">%</span><span class="cn">26</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**<span>Further Thoughts:</span>**  
This question is actually much easier to solve if **S2** is changed to:

**S2** = {1,2,3,4,….} ie, *a*-\>1, *b*-\>2, *c*-\>3, …, *aa*-\>27.

Then transforming from *n* to a string in **S1** is just the same as
converting the number from base 10 to base 26. Using this idea as a
starting point, you can derive the same Equation **(1)** above.

VN:F [1.9.22\_1171]

Rating: 4.9/**5** (11 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Excel Sheet Row Numbers</span></span>, <span
class="rating"><span class="average">4.9</span> out of <span
class="best">5</span> based on <span class="votes">11</span> ratings
<span class="summary"></span></span></span>

Best Time to Buy and Sell Stock
===============================

November 10, 2010 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> Say you have an array for which the *i*<sup>th</sup> element is the
> price of a given stock on day *i*.
>
> If you were only permitted to buy one share of the stock and sell one
> share of the stock, design an algorithm to find the best times to buy
> and sell.

<span id="more-55"></span>  
 It is a question from [Hacking a Google Interview from
MIT](http://www.leetcode.com/2010/04/hacking-google-interview-from-mit.html)
handout \#3 titled “[Beating the Stock
Market](http://courses.csail.mit.edu/iap/interview/Hacking_a_Google_Interview_Handout_3.pdf)“.

At first glance, you might think that finding the minimum and maximum
value would do, but it does have a hidden restriction, that is: You must
buy before you can sell.

The question is equivalent to the following:

Find *i* and *j* that maximizes A*<sub>j</sub>* – A*<sub>i</sub>*, where
*i* j.

There is an obvious *O*(*N*<sup>2</sup>) solution, but in fact we can do
better in just *O*(*N*).

To solve this problem efficiently, you would need to track the minimum
value’s index. As you traverse, update the minimum value’s index when a
new minimum is met. Then, compare the difference of the current element
with the minimum value. Save the buy and sell time when the difference
exceeds our maximum difference (also update the maximum difference).

void getBestTime(int stocks[], int sz, int &buy, int &sell) { int min =
0; int maxDiff = 0; buy = sell = 0; for (int i = 0; i \< sz; i++) { if
(stocks[i] \< stocks[min]) min = i; int diff = stocks[i] - stocks[min];
if (diff \> maxDiff) { buy = min; sell = i; maxDiff = diff; } } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">getBestTime</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">stocks</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">sz</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">buy</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">sell</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">min</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">maxDiff</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">buy</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">sell</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">sz</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">stocks</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="v">stocks</span><span class="sy">[</span><span class="i">min</span><span class="sy">]</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">min</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">i</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">diff</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">stocks</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="v">stocks</span><span class="sy">[</span><span class="i">min</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">diff</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">maxDiff</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">buy</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">min</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">sell</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">i</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">maxDiff</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">diff</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.4/**5** (41 votes cast)

<span class="hreview-aggregate"><span class="item"><span class="fn">Best
Time to Buy and Sell Stock</span></span>, <span class="rating"><span
class="average">4.4</span> out of <span class="best">5</span> based on
<span class="votes">41</span> ratings <span
class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/11/best-time-to-buy-and-sell-stock.html>

> Given a binary search tree, print the elements in-order iteratively
> without using recursion.

<span id="more-18"></span>  
**<span>Note:</span>**  
Before you attempt this problem, you might want to try coding a
pre-order traversal iterative solution first, because it is easier. On
the other hand, coding a post-order iterative version is a challenge.
See my post: [Binary Tree Post-Order Traversal Iterative
Solution](http://www.leetcode.com/2010/10/binary-tree-post-order-traversal.html)
for more details and an in-depth analysis of the problem.

We know the elements can be printed in-order easily using recursion, as
follow:

void in\_order\_traversal(BinaryTree \*p) { if (!p) return;
in\_order\_traversal(p-\>left); cout \<\< p-\>data;
in\_order\_traversal(p-\>right); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">in_order_traversal</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">in_order_traversal</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">in_order_traversal</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

Excessive recursive function calls may cause memory to run out of stack
space and extra overhead. Since the depth of a <span>balanced</span>
binary search tree is about lg(*n*), you might not worry about running
out of stack space, even when you have a million of elements. But what
if the tree is not balanced? Then you are asking for trouble, because in
the worst case the height of the tree may go up to *n*. If that is the
case, stack space will eventually run out and your program will crash.

To solve this issue, we need to develop an iterative solution. The idea
is easy, we need a stack to store previous nodes, and a visited flag for
each node is needed to record if the node has been visited before. When
a node is traversed for the second time, its value will be printed.
After its value is printed, we push its right child and continue from
there.

void in\_order\_traversal\_iterative(BinaryTree \*root) {
stack\<BinaryTree\*\> s; s.push(root); while (!s.empty()) {
BinaryTree \*top = s.top(); if (top != NULL) { if (!top-\>visited) {
s.push(top-\>left); } else { cout \<\< top-\>data \<\< " "; s.pop();
s.push(top-\>right); } } else { s.pop(); if (!s.empty())
s.top()-\>visited = true; } } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">in_order_traversal_iterative</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="i">stack</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="h"> </span><span class="i">s</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">root</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">s</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="e">BinaryTree *</span><span class="v">top</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">top</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="t">NULL</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">top</span><span class="o">-&gt;</span><span class="i">visited</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">top</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">top</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">top</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">s</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">s</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="o">-&gt;</span><span class="v">visited</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**<span>Alternative Solution:</span>**  
The above solution requires modification to the original BST data
structure (ie, adding a visited flag). The other solution which doesn’t
modify the original structure is with the help of a current pointer in
addition of a stack.

First, the current pointer is initialized to the root. Keep traversing
to its left child while pushing visited nodes onto the stack. When you
reach a NULL node (ie, you’ve reached a leaf node), you would pop off an
element from the stack and set it to current. Now is the time to print
current’s value. Then, current is set to its right child and repeat the
process again. When the stack is empty, this means you’re done printing.

void in\_order\_traversal\_iterative(BinaryTree \*root) {
stack\<BinaryTree\*\> s; BinaryTree \*current = root; bool done = false;
while (!done) { if (current) { s.push(current); current =
current-\>left; } else { if (s.empty()) { done = true; } else { current
= s.top(); s.pop(); cout \<\< current-\>data \<\< " "; current =
current-\>right; } } } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">in_order_traversal_iterative</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="i">stack</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="h"> </span><span class="i">s</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">BinaryTree *</span><span class="v">current</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">root</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">bool</span><span class="h"> </span><span class="v">done</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">done</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">current</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">current</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">current</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">current</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">s</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">done</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">current</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">current</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">current</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">current</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

We can even do better by refactoring the above code. The refactoring
relies on one important observation:

The last traversed node must not have a right child.

Why this is true? To prove this, we assume the opposite, that is: the
last traversed node has a right child. This is certainly incorrect, as
in-order traversal would have to traverse its right child next before
the traversal is done. Since this is incorrect, the last traversed node
must not have a right child by contradiction.

Below is the refactored code:

void in\_order\_traversal\_iterative(BinaryTree \*root) {
stack\<BinaryTree\*\> s; BinaryTree \*current = root; while (!s.empty()
|| current) { if (current) { s.push(current); current = current-\>left;
} else { current = s.top(); s.pop(); cout \<\< current-\>data \<\< " ";
current = current-\>right; } } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">in_order_traversal_iterative</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="i">stack</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="h"> </span><span class="i">s</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">BinaryTree *</span><span class="v">current</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">root</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">s</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">current</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">current</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">current</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">current</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">current</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">current</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">s</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">current</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">current</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">current</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

[![](http://1.bp.blogspot.com/_UElib2WLeDE/TKkMHa8GoNI/AAAAAAAACWE/9_gC5U7nd94/s320/threaded_binary_tree.png)  
](http://1.bp.blogspot.com/_UElib2WLeDE/TKkMHa8GoNI/AAAAAAAACWE/9_gC5U7nd94/s1600/threaded_binary_tree.png)
A **threaded tree**, with the special threading links shown by dashed
arrows. A threaded binary tree makes it possible to traverse the values
in the binary tree via a linear traversal that is more rapid than a
recursive in-order traversal.
**<span>Further Thoughts:</span>**  
The above solutions require the help of a stack to do in-order
traversal. Is it possible to do in-order traversal without a stack?

The answer is yes, it’s possible. There’s 2 possible ways that I know
of:

1.  By adding a parent pointer to the data structure, this allows us to
    return to a node’s parent (Credits to my friend who provided this
    solution to me). To determine when to print a node’s value, we would
    have to determine when it’s returned from. If it’s returned from its
    left child, then you would print its value then traverse to its
    right child, on the other hand if it’s returned from its right
    child, you would traverse up one level to its parent.
2.  By using a Threaded Binary Tree. Read the article: [Threaded Binary
    Tree](http://en.wikipedia.org/wiki/Threaded_binary_tree) on
    Wikipedia for more information.

VN:F [1.9.22\_1171]

Rating: 4.7/**5** (58 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Binary Search Tree In-Order Traversal Iterative
Solution</span></span>, <span class="rating"><span
class="average">4.7</span> out of <span class="best">5</span> based on
<span class="votes">58</span> ratings <span
class="summary"></span></span></span>

> Given a binary tree, print out the tree in level order (ie, from left
> to right, level by level). Output a newline after the end of each
> level. **Breadth First Search (BFS) is not allowed**.<span
> id="more-39"></span>
>
>          3
>        /  \
>       9   20    
>          /  \
>         15    7
>
> For example, the level order output of the tree above is:
>
>     3 
>     9 20 
>     15 7

In my last post: [Printing Binary Tree in Level
Order](http://www.leetcode.com/2010/09/printing-binary-tree-in-level-order.html),
we discuss how to print a tree using [Breadth First
Search](http://en.wikipedia.org/wiki/Breadth-first_search) (BFS). The
challenge now is, can you do it using [Depth First
Search](http://en.wikipedia.org/wiki/Depth-first_search) (DFS) this
time?

**Hint:**  
Write a function call *printLevel(BinaryTree \*p, int level)* which will
print all nodes of a given level. Assume you know the height of the
tree, then you can print the entire tree level by level utilizing
*printLevel*.

**Solution:**  
*printLevel* function can be solved using DFS. Decrement level by *one*
as you advance to the next level. When level equals *1*, you’ve reached
the given level. To find the maximum height (or the max depth) of a
tree, you can read my post: [Maximum Height of a Binary
Tree](http://www.leetcode.com/2010/04/maximum-height-of-binary-tree.html).

void printLevel(BinaryTree \*p, int level) { if (!p) return; if (level
== 1) { cout \<\< p-\>data \<\< " "; } else { printLevel(p-\>left,
level-1); printLevel(p-\>right, level-1); } } void
printLevelOrder(BinaryTree \*root) { int height = maxHeight(root); for
(int level = 1; level \<= height; level++) { printLevel(root, level);
cout \<\< endl; } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">printLevel</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">level</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">level</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="e">printLevel</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">level</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="e">printLevel</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">level</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">void</span><span class="h"> </span><span class="e">printLevelOrder</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">height</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">maxHeight</span><span class="sy">(</span><span class="i">root</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">level</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">level</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">height</span><span class="sy">;</span><span class="h"> </span><span class="i">level</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="e">printLevel</span><span class="sy">(</span><span class="i">root</span><span class="sy">,</span><span class="h"> </span><span class="i">level</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">endl</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Further Thoughts:**  
If you look carefully, you will notice that the DFS solution traverses
the same node multiple times. Since BFS traverses each node exactly one
time, BFS is much more efficient than DFS.

Could you find the run time complexity for the DFS level-order traversal
solution? Try to estimate as best as you can, and then find the correct
answer by proving it using Math. Does your estimate fares well with the
correct answer? Why?

**Answer:**  
Although the DFS solution traverse the same node multiple times, it is
not another order slower than the BFS solution. Here is the proof that
the DFS solution above runs in *O*(*N*) time, where *N* is the number of
nodes in the binary tree and we assume that the binary tree is balanced.

We first compute the complexity of *printLevel* for the *kth* level:

    T(k) = 2T(k-1) + c
         = 2k-1 T(1) + c
         = 2k-1 + c

Assuming it’s a balanced binary tree, then it would have a total of lg
*N* levels.

Therefore, the complexity of printing all levels is:

    T(1) + T(2) + ... + T(lg N)
    = 1 + 2 + 22 + ... + 2lg N-1 + c
    = O(N)

Finding the maximum height of the tree also takes *O*(*N*) time,
therefore the overall complexity is still *O*(*N*).

VN:F [1.9.22\_1171]

Rating: 4.4/**5** (25 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Binary Tree Level-Order Traversal Using Depth First Search
(DFS)</span></span>, <span class="rating"><span
class="average">4.4</span> out of <span class="best">5</span> based on
<span class="votes">25</span> ratings <span
class="summary"></span></span></span>

> Given a binary tree, print the elements in post-order iteratively
> without using recursion.

<span id="more-51"></span>  

We know the elements can be printed post-order easily using recursion,
as follow:

void postOrderTraversal(BinaryTree \*p) { if (!p) return;
postOrderTraversal(p-\>left); postOrderTraversal(p-\>right); cout \<\<
p-\>data; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">postOrderTraversal</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">postOrderTraversal</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">postOrderTraversal</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

This is the most difficult of all types of iterative tree traversals.
You should attempt this problem: [Binary Search Tree In-Order Traversal
Iterative
Solution](http://www.leetcode.com/2010/04/binary-search-tree-in-order-traversal.html)
before this as it is an easier problem. The easiest of all iterative
tree traversals is [Pre-Order
Traversal](http://www.google.com/search?q=preorder+traversal+without+recursion).

Post-order traversal is useful in some types of tree operations:

1.  Tree deletion. In order to free up allocated memory of all nodes in
    a tree, the nodes must be deleted in the order where the current
    node can only be deleted when both of its left and right subtrees
    are deleted.
2.  Evaluating [post-fix
    notation](http://en.wikipedia.org/wiki/Post_fix_notation).

If you keep visited flags in the binary tree while traversing, the
problem could be solved in a more direct manner. But we will not discuss
this solution here, as it has already been discussed in Wikipedia’s
article on [Tree
Traversal](http://en.wikipedia.org/wiki/Post-order_traversal#Iterative_Traversal).
Here, we discuss a solution without using any visited flags, which seems
challenging to solve.

**Hint:**  
As usual, a stack-based solution is necessary when there is no parent
pointer available in the tree. Try to follow the post-order traversal of
a sample binary tree. When should you print a node’s value? Note under
what condition it traverses up/down the tree. Try to use a variable to
store the previously-traversed node. How would it help when it traverses
up/down the tree?

[![](http://3.bp.blogspot.com/_UElib2WLeDE/TMjYkP1_FtI/AAAAAAAACXQ/DvvKhb8LF5M/s320/Sorted_binary_tree.png)](http://3.bp.blogspot.com/_UElib2WLeDE/TMjYkP1_FtI/AAAAAAAACXQ/DvvKhb8LF5M/s1600/Sorted_binary_tree.png)

Post-order traversal sequence: A, C, E, D, B, H, I, G, F

**Solution:**  
We use a *prev* variable to keep track of the previously-traversed node.
Let’s assume *curr* is the current node that’s on top of the stack. When
*prev* is *curr*‘s parent, we are traversing down the tree. In this
case, we try to traverse to *curr*‘s left child if available (ie, push
left child to the stack). If it is not available, we look at *curr*‘s
right child. If both left and right child do not exist (ie, *curr* is a
leaf node), we print *curr*‘s value and pop it off the stack.

If *prev* is *curr*‘s left child, we are traversing up the tree from the
left. We look at *curr*‘s right child. If it is available, then traverse
down the right child (ie, push right child to the stack), otherwise
print *curr*‘s value and pop it off the stack.

If *prev* is *curr*‘s right child, we are traversing up the tree from
the right. In this case, we print *curr*‘s value and pop it off the
stack.

void postOrderTraversalIterative(BinaryTree \*root) { if (!root) return;
stack\<BinaryTree\*\> s; s.push(root); BinaryTree \*prev = NULL; while
(!s.empty()) { BinaryTree \*curr = s.top(); // we are traversing down
the tree if (!prev || prev-\>left == curr || prev-\>right == curr) { if
(curr-\>left) { s.push(curr-\>left); } else if (curr-\>right) {
s.push(curr-\>right); } else { cout \<\< curr-\>data \<\< " "; s.pop();
} } // we are traversing up the tree from the left else if (curr-\>left
== prev) { if (curr-\>right) { s.push(curr-\>right); } else { cout \<\<
curr-\>data \<\< " "; s.pop(); } } // we are traversing up the tree from
the right else if (curr-\>right == prev) { cout \<\< curr-\>data \<\< "
"; s.pop(); } prev = curr; // record previously traversed node } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">postOrderTraversalIterative</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">stack</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="h"> </span><span class="i">s</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">root</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">BinaryTree *</span><span class="v">prev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">s</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="e">BinaryTree *</span><span class="v">curr</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="c">// we are traversing down the tree</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">prev</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">prev</span><span class="o">-&gt;</span><span class="v">left</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">curr</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">prev</span><span class="o">-&gt;</span><span class="v">right</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">curr</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span></p>
<p><span class="h">    </span><span class="c">// we are traversing up the tree from the left</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="v">left</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">prev</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="c">// we are traversing up the tree from the right</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="v">right</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">prev</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">s</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="v">prev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">curr</span><span class="sy">;</span><span class="h">  </span><span class="c">// record previously traversed node</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

The above method is easy to follow, but has some redundant code. We
could refactor out the redundant code, and now it appears to be more
concise. Note how the code section for printing *curr*‘s value get
refactored into one single else block. Don’t worry about in an iteration
where its value won’t get printed, as it is guaranteed to enter the else
section in the next iteration.

void postOrderTraversalIterative(BinaryTree \*root) { if (!root) return;
stack\<BinaryTree\*\> s; s.push(root); BinaryTree \*prev = NULL; while
(!s.empty()) { BinaryTree \*curr = s.top(); if (!prev || prev-\>left ==
curr || prev-\>right == curr) { if (curr-\>left) s.push(curr-\>left);
else if (curr-\>right) s.push(curr-\>right); } else if (curr-\>left ==
prev) { if (curr-\>right) s.push(curr-\>right); } else { cout \<\<
curr-\>data \<\< " "; s.pop(); } prev = curr; } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">postOrderTraversalIterative</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">stack</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="h"> </span><span class="i">s</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">root</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">BinaryTree *</span><span class="v">prev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">s</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="e">BinaryTree *</span><span class="v">curr</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">prev</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">prev</span><span class="o">-&gt;</span><span class="v">left</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">curr</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">prev</span><span class="o">-&gt;</span><span class="v">right</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">curr</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="v">left</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">prev</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">s</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="v">prev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">curr</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**<span>Alternative Solution:</span>**  
An alternative solution is to use two stacks. Try to work it out on a
piece of paper. I think it is quite magical and beautiful. You will
think that it works magically, but in fact it is doing a reversed
pre-order traversal. That is, the order of traversal is a node, then its
right child followed by its left child. This yields post-order traversal
in reversed order. Using a second stack, we could reverse it back to the
correct order.

Here is how it works:

1.  Push the root node to the first stack.
2.  Pop a node from the first stack, and push it to the second stack.
3.  Then push its left child followed by its right child to the first
    stack.
4.  Repeat step **2)** and **3)** until the first stack is empty.
5.  Once done, the second stack would have all the nodes ready to be
    traversed in post-order. Pop off the nodes from the second stack one
    by one and you’re done.

void postOrderTraversalIterativeTwoStacks(BinaryTree \*root) { if
(!root) return; stack\<BinaryTree\*\> s; stack\<BinaryTree\*\> output;
s.push(root); while (!s.empty()) { BinaryTree \*curr = s.top();
output.push(curr); s.pop(); if (curr-\>left) s.push(curr-\>left); if
(curr-\>right) s.push(curr-\>right); } while (!output.empty()) { cout
\<\< output.top()-\>data \<\< " "; output.pop(); } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">postOrderTraversalIterativeTwoStacks</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">stack</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="h"> </span><span class="i">s</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">stack</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="h"> </span><span class="i">output</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">root</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">s</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="e">BinaryTree *</span><span class="v">curr</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">output</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">curr</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">s</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">output</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="v">output</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">output</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Complexity Analysis:**  
The two-stack solution takes up more space compared to the first
solution using one stack. In fact, the first solution has a space
complexity of *O*(*h*), where *h* is the maximum height of the tree. The
two-stack solution however, has a space complexity of *O*(*n*), where
*n* is the total number of nodes.

VN:F [1.9.22\_1171]

Rating: 4.8/**5** (73 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Binary Tree Post-Order Traversal Iterative
Solution</span></span>, <span class="rating"><span
class="average">4.8</span> out of <span class="best">5</span> based on
<span class="votes">73</span> ratings <span
class="summary"></span></span></span>

C code to count the number of words in a string
===============================================

February 13, 2010 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> Count the number of words in a string, where a word is defined to be a
> contiguous sequence of non-space characters.
>
> <span id="more-6"></span>eg, “Hello, my name is John.” -\> 5

Hint: Take account for extra spaces at the start and end of the string,
and there might be more than multiple spaces between words.

Below is a possible solution in C. The key is to note when it is in a
word and when it is not; When it changes from not-in-word to in-word,
increment wordCount by one.

int countNumWords(const char \*str) { bool inWord = false; int wordCount
= 0; while (\*str) { if (!inWord && isalpha(\*str)) { inWord = true;
wordCount++; } else if (inWord && \*str == ' ') { inWord = false; }
str++; } return wordCount; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">countNumWords</span><span class="sy">(</span><span class="m">const</span><span class="h"> </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="i">str</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">bool</span><span class="h"> </span><span class="v">inWord</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">wordCount</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="i">str</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">inWord</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="e">isalpha</span><span class="sy">(</span><span class="o">*</span><span class="i">str</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">inWord</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="i">wordCount</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">inWord</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="o">*</span><span class="v">str</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="s">' '</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">inWord</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="i">str</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">wordCount</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.8/**5** (15 votes cast)

<span class="hreview-aggregate"><span class="item"><span class="fn">C
code to count the number of words in a string</span></span>, <span
class="rating"><span class="average">4.8</span> out of <span
class="best">5</span> based on <span class="votes">15</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/02/c-code-to-count-number-of-words-in.html>

C code to remove spaces from a string
=====================================

February 13, 2010 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> Write a C function to remove spaces from a string. The function header
> should be  
> void removeSpaces(char \*str)<span id="more-5"></span>
>
> ie, “abc de” -\> “abcde”

Here might be a common interview question testing your C skills:

It can be implemented in just 5 lines of code, shown below:

void removeSpace(char \*str) { char \*p1 = str, \*p2 = str; do while
(\*p2 == ' ') p2++; while (\*p1++ = \*p2++); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">removeSpace</span><span class="sy">(</span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="i">str</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="v">p1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">str</span><span class="sy">,</span><span class="h"> </span><span class="o">*</span><span class="v">p2</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">str</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">do</span><span class="h"> </span></p>
<p><span class="h">    </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="v">p2</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="s">' '</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="i">p2</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="i">p1</span><span class="o">++</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="o">*</span><span class="i">p2</span><span class="o">++</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

Of course, this is for illustration purpose and to show how elegant C
code can be.

I probably wouldn’t program like this in the industry just for clarity
sake. There are no parenthesis indicating clear scope and it’s not
obvious what \*p1++ means to some programmers (\*p1++ is the same
as \*(p1++) due to ++ having higher precedence).

VN:F [1.9.22\_1171]

Rating: 3.9/**5** (16 votes cast)

<span class="hreview-aggregate"><span class="item"><span class="fn">C
code to remove spaces from a string</span></span>, <span
class="rating"><span class="average">3.9</span> out of <span
class="best">5</span> based on <span class="votes">16</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/02/c-code-to-remove-spaces-from-string.html>

Clone Graph Part I
==================

May 30, 2012 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> Clone a graph. Input is a Node pointer. Return the Node pointer of the
> cloned graph.  
>  <span id="more-1354"></span>
>
> A graph is defined below:  
>  struct Node {  
>  vector neighbors;  
>  }

**Hint:**  
 There are two main ways to traverse a graph. Do you still remember
them? Could you tell if the graph is directed or undirected?

**Solution:**  
 There are two main ways to traverse a graph: *Breadth-first* or
*Depth-first*. Let’s try the Breadth-first approach first, which
requires a queue. For the Depth-first approach, please see Clone Graph
Part II.

How does the breadth-first traversal works? Easy, as we pop a node off
the queue, we copy each of its neighbors, and push them to the queue.

A straight forward breadth-first traversal seemed to work. But some
details are still missing. For example, how do we connect the nodes of
the cloned graph?

Before we continue, we first need to make sure if the graph is directed
or not. If you notice how Node is defined above, it is quite obvious
that the graph is a directed graph. Why?

For example, A can have a neighbor called B. Therefore, we may traverse
from A to B. An undirected graph implies that B can always traverse back
to A. Is it true here? No, because whether B could traverse back to A
depends if one of B’s neighbor is A.

The fact that B can traverse back to A implies that the graph may
contain a cycle. You must take extra care to handle this case. Imagine
that you finished implementing without considering this case, and later
being pointed out by your interviewer that your code has an infinite
loop, yuck!

Let’s analyze this further by using the below example:

[![](http://www.leetcode.com/wp-content/uploads/2012/05/graph.png "graph")](http://www.leetcode.com/wp-content/uploads/2012/05/graph.png)<span>A
simple graph</span>

Assume that the starting point of the graph is A. First, you make a copy
of node A (A2), and found that A has only one neighbor B. You make a
copy of B (B2) and connects A2-\>B2 by pushing B2 as A2′s neighbor.
Next, you find that B has A as neighbor, which you have already made a
copy of. Here, we have to be careful not to make a copy of A again, but
to connect B2-\>A2 by pushing A2 as B2′s neighbor. But, how do we know
if a node has already been copied?

Easy, we could use a hash table! As we copy a node, we insert it into
the table. If we later find that one of a node’s neighbor is already in
the table, we do not make a copy of that neighbor, but to push its
neighbor’s copy to its copy instead. Therefore, the hash table would
need to store a mapping of key-value pairs, where the key is a node in
the original graph and its value is the node’s copy.

Let’s implement the code!

typedef unordered\_map\<Node \*, Node \*\> Map;
Node \*clone(Node \*graph) { if (!graph) return NULL; Map map;
queue\<Node \*\> q; q.push(graph); Node \*graphCopy = new Node();
map[graph] = graphCopy; while (!q.empty()) { Node \*node = q.front();
q.pop(); int n = node-\>neighbors.size(); for (int i = 0; i \< n; i++) {
Node \*neighbor = node-\>neighbors[i]; // no copy exists if
(map.find(neighbor) == map.end()) { Node \*p = new Node();
map[node]-\>neighbors.push\_back(p); map[neighbor] = p;
q.push(neighbor); } else { // a copy already exists
map[node]-\>neighbors.push\_back(map[neighbor]); } } } return graphCopy;
}
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="r">typedef</span><span class="h"> </span><span class="i">unordered_map</span><span class="o">&lt;</span><span class="e">Node *</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="o">&gt;</span><span class="h"> </span><span class="i">Map</span><span class="sy">;</span></p>
<p> </p>
<p><span class="e">Node *</span><span class="r">clone</span><span class="sy">(</span><span class="e">Node *</span><span class="i">graph</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">graph</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">    </span><span class="e">Map </span><span class="i">map</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">queue</span><span class="o">&lt;</span><span class="e">Node *</span><span class="o">&gt;</span><span class="h"> </span><span class="i">q</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">q</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">graph</span><span class="sy">)</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">    </span><span class="e">Node *</span><span class="v">graphCopy</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="r">new</span><span class="h"> </span><span class="e">Node</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">map</span><span class="sy">[</span><span class="i">graph</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">graphCopy</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">    </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">q</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="e">Node *</span><span class="v">node</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">q</span><span class="sy">.</span><span class="e">front</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">q</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="t">int</span><span class="h"> </span><span class="v">n</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">node</span><span class="o">-&gt;</span><span class="v">neighbors</span><span class="sy">.</span><span class="e">size</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">            </span><span class="e">Node *</span><span class="v">neighbor</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">node</span><span class="o">-&gt;</span><span class="v">neighbors</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">            </span><span class="c">// no copy exists</span></p>
<p><span class="h">            </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">map</span><span class="sy">.</span><span class="e">find</span><span class="sy">(</span><span class="i">neighbor</span><span class="sy">)</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="v">map</span><span class="sy">.</span><span class="st">end</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">                </span><span class="e">Node *</span><span class="v">p</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="r">new</span><span class="h"> </span><span class="e">Node</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">                </span><span class="v">map</span><span class="sy">[</span><span class="i">node</span><span class="sy">]</span><span class="o">-&gt;</span><span class="v">neighbors</span><span class="sy">.</span><span class="e">push_back</span><span class="sy">(</span><span class="i">p</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">                </span><span class="v">map</span><span class="sy">[</span><span class="i">neighbor</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="sy">;</span></p>
<p><span class="h">                </span><span class="v">q</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">neighbor</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">            </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span><span class="h">     </span><span class="c">// a copy already exists</span></p>
<p><span class="h">                </span><span class="v">map</span><span class="sy">[</span><span class="i">node</span><span class="sy">]</span><span class="o">-&gt;</span><span class="v">neighbors</span><span class="sy">.</span><span class="e">push_back</span><span class="sy">(</span><span class="v">map</span><span class="sy">[</span><span class="i">neighbor</span><span class="sy">]</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">            </span><span class="sy">}</span></p>
<p><span class="h">        </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p> </p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="i">graphCopy</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.5/**5** (111 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Clone Graph Part I</span></span>, <span class="rating"><span
class="average">4.5</span> out of <span class="best">5</span> based on
<span class="votes">111</span> ratings <span
class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2012/05/clone-graph-part-i.html>

### Leave a reply

### 3 trackbacks

-   *on August 8, 2014*
-   *on October 8, 2014*
-   *on February 12, 2015*

Coins in a Line
===============

February 9, 2011 <span>in [dynamic
programming](http://leetcode.com/category/dynamic-programming "View all posts in dynamic programming")</span>
<span class="post-utility alignright"></span>

> There are *n* coins in a line. (Assume *n* is even). Two players take
> turns to take a coin from one of the ends of the line until there are
> no more coins left. The player with the larger amount of money wins.
>
> 1.  Would you rather go first or second? Does it matter?
> 2.  Assume that you go first, describe an algorithm to compute the
>     maximum amount of money you can win.

<span id="more-83"></span>  
 This is an interesting problem itself, and different solutions from
multiple perspectives are provided in this post.

[![](http://1.bp.blogspot.com/_UElib2WLeDE/TVJ1kloofTI/AAAAAAAACdQ/SMgDB3scuFE/s1600/american_coins.jpg)](http://1.bp.blogspot.com/_UElib2WLeDE/TVJ1kloofTI/AAAAAAAACdQ/SMgDB3scuFE/s1600/american_coins.jpg)

<span>[U.S.
coins](http://en.wikipedia.org/wiki/Coins_of_the_United_States_dollar)
in various denominations in a line. Two players take turn to pick a coin
from one of the ends until no more coins are left. Whoever with the
larger amount of money wins.</span>

**Hints:**  
 If you go first, is there a strategy you can follow which prevents you
from losing? Try to consider how it matters when the number of coins are
odd vs. even.

**Solution for (1):**  
 Going first will guarantee that you will not lose. By following the
strategy below, you will always win the game (or get a possible tie).

-   Count the sum of all coins that are odd-numbered. (Call this **X**)
-   Count the sum of all coins that are even-numbered. (Call this **Y**)
-   If **X** \> **Y**, take the left-most coin first. Choose all
    odd-numbered coins in subsequent moves.
-   If **X** Y, take the right-most coin first. Choose all even-numbered
    coins in subsequent moves.
-   If **X** == **Y**, you will guarantee to get a tie if you stick with
    taking only even-numbered/odd-numbered coins.

You might be wondering how you can always choose
odd-numbered/even-numbered coins. Let me illustrate this using an
example where you have 10 coins:

If you take the coin numbered 1 (the left-most coin), your opponent can
only have the choice of taking coin numbered 2 or 10 (which are both
even-numbered coins). On the other hand, if you choose to take the coin
numbered 10 (the right-most coin), your opponent can only take coin
numbered 1 or 9 (which are odd-numbered coins).

Notice that the total number of coins change from even to odd and
vice-versa when player takes turn each time. Therefore, by going first
and depending on the coin you choose, you are essentially forcing your
opponent to take either only even-numbered or odd-numbered coins.

Now that you have found a non-losing strategy, could you compute the
maximum amount of money you can win?

**Hints:**  
 One misconception is to think that the above non-losing strategy would
generate the maximum amount of money as well. This is probably
incorrect. Could you find a counter example? (You might need at least 6
coins to find a counter example).

Assume that you are finding the maximum amount of money in a certain
range (ie, from coins numbered i to j, inclusive). Could you express it
as a recursive formula? Find ways to make it as efficient as possible.

**Solution for (2):**  
 Although the simple strategy illustrated in **Solution (1)** guarantees
you not to lose, it does not guarantee that it is optimal in any way.

Here, we use a good counter example to better see why this is so. Assume
the coins are laid out as below:

    { 3, 2, 2, 3, 1, 2 }

Following our previous non-losing strategy, we would count the sum of
odd-numbered coins, **X** = 3 + 2 + 1 = **6**, and the sum of
even-numbered coins, **Y** = 2 + 3 + 2 = **7**. As **Y** \> **X**, we
would take the last coin first and end up winning with the total amount
of **7** by taking only even-numbered coins.

However, let us try another way by taking the first coin (valued at 3,
denote by **(3)**) instead. The opponent is left with two possible
choices, the left coin **(2)** and the right coin **(2)**, both valued
at 2. No matter which coin the opponent chose, you can always take the
other coin **(2)** next and the configuration of the coins becomes: **{
2, 3, 1 }**. Now, the coin in the middle **(3)** would be yours to keep
for sure. Therefore, you win the game by a total amount of 3 + 2 + 3 =
**8**, which proves that the previous non-losing strategy is not
necessarily optimal.

To solve this problem in an optimal way, we need to find efficient means
in enumerating all possibilities. This is when [Dynamic
Programming](http://www.leetcode.com/search/label/dynamic%20programming)
(DP) kicks in and become so powerful that you start to feel magical.

First, we would need some observations to establish a recurrence
relation, which is essential as our first step in solving DP problems.

[![](http://4.bp.blogspot.com/_UElib2WLeDE/TVJNJgjHawI/AAAAAAAACdI/phIGr-4o_JM/s400/coins.png)](http://4.bp.blogspot.com/_UElib2WLeDE/TVJNJgjHawI/AAAAAAAACdI/phIGr-4o_JM/s1600/coins.png)

<span>The remaining coins are { A<sub>i</sub> … A<sub>j</sub> } and it
is your turn. Let P(i, j) denotes the maximum amount of money you can
get. Should you choose A<sub>i</sub> or A<sub>j</sub>?</span>

Assume that P(i, j) denotes the maximum amount of money you can win when
the remaining coins are { A<sub>i</sub>, …, A<sub>j</sub> }, and it is
your turn now. You have two choices, either take A<sub>i</sub> or
A<sub>j</sub>. First, let us focus on the case where you take
A<sub>i</sub>, so that the remaining coins become { A<sub>i+1</sub> …
A<sub>j</sub> }. Since the opponent is as smart as you, he must choose
the best way that yields the maximum for him, where the maximum amount
he can get is denoted by P(i+1, j).

Therefore, if you choose A<sub>i</sub>, the maximum amount you can get
is:

    P1 = Sum{Ai ... Aj} - P(i+1, j)

Similarly, if you choose A<sub>j</sub>, the maximum amount you can get
is:

    P2 = Sum{Ai ... Aj} - P(i, j-1)

Therefore,

    P(i, j) = max { P1, P2 }
            = max { Sum{Ai ... Aj} - P(i+1, j),
                    Sum{Ai ... Aj} - P(i, j-1) }

In fact, we are able to simplify the above relation further to (Why?):

    P(i, j) = Sum{Ai ... Aj} - min { P(i+1, j), P(i, j-1) }

Although the above recurrence relation is easy to understand, we need to
compute the value of Sum{A<sub>i</sub> … A<sub>j</sub>} in each step,
which is not very efficient. To avoid this problem, we can store values
of Sum{A<sub>i</sub> … A<sub>j</sub>} in a table and avoid
re-computations by computing in a certain order. Try to figure this out
by yourself. (Hint: You would first compute P(1,1), P(2,2), … P(*n*,
*n*) and work your way up).

**A Better Solution:**  
 There is another solution which does not rely on computing and storing
results of Sum{A<sub>i</sub> … A<sub>j</sub>}, therefore is more
efficient in terms of time and space. Let us rewind back to the case
where you take A<sub>i</sub>, and the remaining coins become {
A<sub>i+1</sub> … A<sub>j</sub> }.

[![](http://4.bp.blogspot.com/_UElib2WLeDE/TVJUaw3myeI/AAAAAAAACdM/-zYRDclcIlI/s400/coins2.png)](http://4.bp.blogspot.com/_UElib2WLeDE/TVJUaw3myeI/AAAAAAAACdM/-zYRDclcIlI/s1600/coins2.png)

<span>You took </span><span>A<sub>i</sub></span><span> from the coins {
</span><span>A<sub>i</sub></span><span> …
</span><span>A<sub>j</sub></span><span> }. The opponent will choose
either </span><span>A<sub>i+1</sub></span><span> or
</span><span>A<sub>j</sub></span><span>. Which one would he
choose?</span>

Let us look one extra step ahead this time by considering the two coins
the opponent will possibly take, A<sub>i+1</sub> and A<sub>j</sub>. If
the opponent takes A<sub>i+1</sub>, the remaining coins are {
A<sub>i+2</sub> … A<sub>j</sub> }, which our maximum is denoted by
P(i+2, j). On the other hand, if the opponent takes A<sub>j</sub>, our
maximum is P(i+1, j-1). Since the opponent is as smart as you, he would
have chosen the choice that yields the minimum amount to you.

Therefore, the maximum amount you can get when you choose A<sub>i</sub>
is:

    P1 = Ai + min { P(i+2, j), P(i+1, j-1) }

Similarly, the maximum amount you can get when you choose A<sub>j</sub>
is:

    P2 = Aj + min { P(i+1, j-1), P(i, j-2) }

Therefore,

    P(i, j) = max { P1, P2 }
            = max { Ai + min { P(i+2, j),   P(i+1, j-1) },
                    Aj + min { P(i+1, j-1), P(i,   j-2) } }

Although the above recurrence relation could be implemented in few lines
of code, its complexity is exponential. The reason is that each
recursive call branches into a total of four separate recursive calls,
and it could be *n* levels deep from the very first call). Memoization
provides an efficient way by avoiding re-computations using intermediate
results stored in a table. Below is the code which runs in
*O*(*n*<sup>2</sup>) time and takes *O*(*n*<sup>2</sup>) space.

<span>**Edit:**</span>  
 Updated code with a new function *printMoves* which prints out all the
moves you and the opponent make (assuming both of you are taking the
coins in an optimal way).

const int MAX\_N = 100; void printMoves(int P[][MAX\_N], int A[], int N)
{ int sum1 = 0, sum2 = 0; int m = 0, n = N-1; bool myTurn = true; while
(m \<= n) { int P1 = P[m+1][n]; // If take A[m], opponent can get... int
P2 = P[m][n-1]; // If take A[n] cout \<\< (myTurn ? "I" : "You") \<\< "
take coin no. "; if (P1 \<= P2) { cout \<\< m+1 \<\< " (" \<\< A[m] \<\<
")"; m++; } else { cout \<\< n+1 \<\< " (" \<\< A[n] \<\< ")"; n--; }
cout \<\< (myTurn ? ", " : ".\\n"); myTurn = !myTurn; } cout \<\<
"\\nThe total amount of money (maximum) I get is " \<\< P[0][N-1] \<\<
".\\n"; } int maxMoney(int A[], int N) { int P[MAX\_N][MAX\_N] = {0};
int a, b, c; for (int i = 0; i \< N; i++) { for (int m = 0, n = i; n \<
N; m++, n++) { assert(m \< N); assert(n \< N); a = ((m+2 \<= N-1) ?
P[m+2][n] : 0); b = ((m+1 \<= N-1 && n-1 \>= 0) ? P[m+1][n-1] : 0); c =
((n-2 \>= 0) ? P[m][n-2] : 0); P[m][n] = max(A[m] + min(a,b), A[n] +
min(b,c)); } } printMoves(P, A, N); return P[0][N-1]; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="m">const</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">MAX_N</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">100</span><span class="sy">;</span></p>
<p> </p>
<p><span class="t">void</span><span class="h"> </span><span class="e">printMoves</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">P</span><span class="sy">[</span><span class="sy">]</span><span class="sy">[</span><span class="i">MAX_N</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">N</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">sum1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="v">sum2</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">m</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="v">n</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">N</span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">bool</span><span class="h"> </span><span class="v">myTurn</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">m</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">P1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">P</span><span class="sy">[</span><span class="i">m</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">n</span><span class="sy">]</span><span class="sy">;</span><span class="h"> </span><span class="c">// If take A[m], opponent can get...</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">P2</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">P</span><span class="sy">[</span><span class="i">m</span><span class="sy">]</span><span class="sy">[</span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">;</span><span class="h"> </span><span class="c">// If take A[n]</span></p>
<p><span class="h">    </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="i">myTurn</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="s">&quot;I&quot;</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="s">&quot;You&quot;</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; take coin no. &quot;</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">P1</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">P2</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">m</span><span class="o">+</span><span class="cn">1</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; (&quot;</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">m</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;)&quot;</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="i">m</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">n</span><span class="o">+</span><span class="cn">1</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; (&quot;</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">n</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;)&quot;</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="i">n</span><span class="o">--</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="i">myTurn</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="s">&quot;, &quot;</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="s">&quot;.\n&quot;</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">myTurn</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="o">!</span><span class="i">myTurn</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;\nThe total amount of money (maximum) I get is &quot;</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="v">P</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="sy">[</span><span class="i">N</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;.\n&quot;</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">int</span><span class="h"> </span><span class="e">maxMoney</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">N</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">P</span><span class="sy">[</span><span class="i">MAX_N</span><span class="sy">]</span><span class="sy">[</span><span class="i">MAX_N</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">{</span><span class="cn">0</span><span class="sy">}</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="i">a</span><span class="sy">,</span><span class="h"> </span><span class="i">b</span><span class="sy">,</span><span class="h"> </span><span class="i">c</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">N</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">m</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="v">n</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">i</span><span class="sy">;</span><span class="h"> </span><span class="i">n</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">N</span><span class="sy">;</span><span class="h"> </span><span class="i">m</span><span class="o">++</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">assert</span><span class="sy">(</span><span class="i">m</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">N</span><span class="sy">)</span><span class="sy">;</span><span class="h"> </span><span class="st">assert</span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">N</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">a</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">m</span><span class="o">+</span><span class="cn">2</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">N</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="h">             </span><span class="sy">?</span><span class="h"> </span><span class="v">P</span><span class="sy">[</span><span class="i">m</span><span class="o">+</span><span class="cn">2</span><span class="sy">]</span><span class="sy">[</span><span class="i">n</span><span class="sy">]</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">b</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">m</span><span class="o">+</span><span class="cn">1</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">N</span><span class="o">-</span><span class="cn">1</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="v">P</span><span class="sy">[</span><span class="i">m</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">c</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">n</span><span class="o">-</span><span class="cn">2</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h">               </span><span class="sy">?</span><span class="h"> </span><span class="v">P</span><span class="sy">[</span><span class="i">m</span><span class="sy">]</span><span class="sy">[</span><span class="i">n</span><span class="o">-</span><span class="cn">2</span><span class="sy">]</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">P</span><span class="sy">[</span><span class="i">m</span><span class="sy">]</span><span class="sy">[</span><span class="i">n</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">max</span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="i">m</span><span class="sy">]</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="e">min</span><span class="sy">(</span><span class="i">a</span><span class="sy">,</span><span class="i">b</span><span class="sy">)</span><span class="sy">,</span></p>
<p><span class="h">                    </span><span class="v">A</span><span class="sy">[</span><span class="i">n</span><span class="sy">]</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="e">min</span><span class="sy">(</span><span class="i">b</span><span class="sy">,</span><span class="i">c</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="e">printMoves</span><span class="sy">(</span><span class="i">P</span><span class="sy">,</span><span class="h"> </span><span class="i">A</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="v">P</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="sy">[</span><span class="i">N</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

<span>**Further Thoughts:**</span>  
 Assume that your opponent is so dumb that you are able to manipulate
him into choosing the coins you want him to choose. Now, what is the
maximum possible amount of money you can win?

VN:F [1.9.22\_1171]

Rating: 4.8/**5** (32 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Coins in a Line</span></span>, <span class="rating"><span
class="average">4.8</span> out of <span class="best">5</span> based on
<span class="votes">32</span> ratings <span
class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2011/02/coins-in-line.html>

Construct Binary Tree From Inorder and Preorder/Postorder Traversal
===================================================================

April 20, 2011 <span>in [binary
tree](http://leetcode.com/category/binary-tree "View all posts in binary tree")</span>
<span class="post-utility alignright"></span>

> Given preorder and inorder traversal of a tree, construct the binary
> tree.

<span id="more-612"></span>  
 **Hint:**  
 A good way to attempt this question is to work backwards. Approach this
question by drawing a binary tree, then list down its preorder and
inorder traversal. As most binary tree problems, you want to solve this
recursively.

**About Duplicates:**  
 In this solution, we will assume that duplicates are not allowed in the
binary tree. Why?

Consider the following case:

    preorder = {7, 7}
    inorder = {7, 7}

We can construct the following trees which are both perfectly valid
solutions.

      7                     7
     /           or          \
    7                         7

Clearly, there would be ambiguity in constructing the tree if duplicates
were allowed.

**Solution:**  
 Let us look at this example tree.

            _______7______
           /              \
        __10__          ___2
       /      \        /
       4       3      _8
                \    /
                 1  11

The preorder and inorder traversals for the binary tree above is:

    preorder = {7,10,4,3,1,2,8,11}
    inorder = {4,10,3,1,7,11,8,2}

The crucial observation to this problem is *the tree’s root always
coincides with the first element in preorder traversal*. This must be
true because in preorder traversal you always traverse the root node
before its children. The root node’s value appear to be
**<span>7</span>** from the binary tree above.

We easily find that **<span>7</span>** appears as the 4<sup>th</sup>
index in the inorder sequence. (Notice that earlier we assumed that
duplicates are not allowed in the tree, so there would be no ambiguity).
For inorder traversal, we visit the left subtree first, then root node,
and followed by the right subtree. Therefore, all elements left of
**<span>7</span>** must be in the left subtree and all elements to the
right must be in the right subtree.

We see a clear recursive pattern from the above observation. After
creating the root node (**<span>7</span>**), we construct its left and
right subtree from inorder traversal of {<span>4</span>,
<span>10</span>, <span>3</span>, <span>1</span>} and {<span>11</span>,
<span>8</span>, <span>2</span>} respectively. We also need its
corresponding preorder traversal which could be found in a similar
fashion. If you remember, preorder traversal follows the sequence of
root node, left subtree and followed by right subtree. Therefore, the
left and right subtree’s postorder traversal must be {<span>10</span>,
<span>4</span>, <span>3</span>, <span>1</span>} and {<span>2</span>,
<span>8</span>, <span>11</span>} respectively. Since the left and right
subtree are binary trees in their own right, we can solve recursively!

We left out some details on how we search the root value’s index in the
inorder sequence. How about a simple *linear search*? If we assume that
the constructed binary tree is always balanced, then we can guarantee
the run time complexity to be O(*N* log *N*), where *N* is the number of
nodes. However, this is not necessarily the case and the constructed
binary tree can be skewed to the left/right, which has the worst
complexity of O(*N*<sup>2</sup>).

A more efficient way is to eliminate the search by using an efficient
look-up mechanism such as *hash table*. By hashing an element’s value to
its corresponding index in the inorder sequence, we can do look-ups in
constant time. Now, we need only O(*N*) time to construct the tree,
which theoretically is the most efficient way.

For illustration purpose, the below code uses a simple array for table
look-up, which is restricted to elements of 0 to 255 only. You should be
able to extend it easily to use a hash table.

const int MAX = 256; // a fast lookup for inorder's element -\> index //
binary tree's element must be in the range of [0, MAX-1] int
mapIndex[MAX]; void mapToIndices(int inorder[], int n) { for (int i = 0;
i \< n; i++) { assert(0 \<= inorder[i] && inorder[i] \<= MAX-1);
mapIndex[inorder[i]] = i; } } // precondition: mapToIndices must be
called before entry Node \*buildInorderPreorder(int in[], int pre[], int
n, int offset) { assert(n \>= 0); if (n == 0) return NULL; int rootVal =
pre[0]; int i = mapIndex[rootVal]-offset; // the divider's index
Node \*root = new Node(rootVal); root-\>left = buildInorderPreorder(in,
pre+1, i, offset); root-\>right = buildInorderPreorder(in+i+1, pre+i+1,
n-i-1, offset+i+1); return root; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="m">const</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">MAX</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">256</span><span class="sy">;</span></p>
<p><span class="c">// a fast lookup for inorder's element -&gt; index</span></p>
<p><span class="c">// binary tree's element must be in the range of [0, MAX-1]</span></p>
<p><span class="t">int</span><span class="h"> </span><span class="v">mapIndex</span><span class="sy">[</span><span class="i">MAX</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="t">void</span><span class="h"> </span><span class="e">mapToIndices</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">inorder</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">assert</span><span class="sy">(</span><span class="cn">0</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="v">inorder</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">inorder</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">MAX</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">mapIndex</span><span class="sy">[</span><span class="v">inorder</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">i</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="c">// precondition: mapToIndices must be called before entry</span></p>
<p><span class="e">Node *</span><span class="e">buildInorderPreorder</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="st">in</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">pre</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">offset</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">assert</span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">n</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">rootVal</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">pre</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">mapIndex</span><span class="sy">[</span><span class="i">rootVal</span><span class="sy">]</span><span class="o">-</span><span class="i">offset</span><span class="sy">;</span><span class="h">  </span><span class="c">// the divider's index</span></p>
<p><span class="h">  </span><span class="e">Node *</span><span class="v">root</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="r">new</span><span class="h"> </span><span class="e">Node</span><span class="sy">(</span><span class="i">rootVal</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">root</span><span class="o">-&gt;</span><span class="v">left</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">buildInorderPreorder</span><span class="sy">(</span><span class="st">in</span><span class="sy">,</span><span class="h"> </span><span class="i">pre</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">i</span><span class="sy">,</span><span class="h"> </span><span class="i">offset</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">root</span><span class="o">-&gt;</span><span class="v">right</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">buildInorderPreorder</span><span class="sy">(</span><span class="st">in</span><span class="o">+</span><span class="i">i</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">pre</span><span class="o">+</span><span class="i">i</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">offset</span><span class="o">+</span><span class="i">i</span><span class="o">+</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">root</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

Now, if we are given *inorder and postorder* traversal, can we construct
the binary tree?

The answer is yes, using very similar approach as above. Below is the
code:

// precondition: mapToIndices must be called before entry
Node \*buildInorderPostorder(int in[], int post[], int n, int offset) {
assert(n \>= 0); if (n == 0) return NULL; int rootVal = post[n-1]; int i
= mapIndex[rootVal]-offset; // the divider's index Node \*root = new
Node(rootVal); root-\>left = buildInorderPostorder(in, post, i, offset);
root-\>right = buildInorderPostorder(in+i+1, post+i, n-i-1, offset+i+1);
return root; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="c">// precondition: mapToIndices must be called before entry</span></p>
<p><span class="e">Node *</span><span class="e">buildInorderPostorder</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="st">in</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">post</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">offset</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">assert</span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">n</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">rootVal</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">post</span><span class="sy">[</span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">mapIndex</span><span class="sy">[</span><span class="i">rootVal</span><span class="sy">]</span><span class="o">-</span><span class="i">offset</span><span class="sy">;</span><span class="h">  </span><span class="c">// the divider's index</span></p>
<p><span class="h">  </span><span class="e">Node *</span><span class="v">root</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="r">new</span><span class="h"> </span><span class="e">Node</span><span class="sy">(</span><span class="i">rootVal</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">root</span><span class="o">-&gt;</span><span class="v">left</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">buildInorderPostorder</span><span class="sy">(</span><span class="st">in</span><span class="sy">,</span><span class="h"> </span><span class="i">post</span><span class="sy">,</span><span class="h"> </span><span class="i">i</span><span class="sy">,</span><span class="h"> </span><span class="i">offset</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">root</span><span class="o">-&gt;</span><span class="v">right</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">buildInorderPostorder</span><span class="sy">(</span><span class="st">in</span><span class="o">+</span><span class="i">i</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">post</span><span class="o">+</span><span class="i">i</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">offset</span><span class="o">+</span><span class="i">i</span><span class="o">+</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">root</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**<span>Further Thoughts:</span>**

1.  If we are given *preorder and postorder* traversal, can we construct
    the binary tree? Why or why not?
2.  Given *preorder, inorder, and postorder* traversal, how can you
    verify if these traversals are referring to the *exact same* binary
    tree?
3.  Remember from my earlier post: [Serialization/Deserialization of a
    Binary
    Tree](http://www.leetcode.com/2010/09/serializationdeserialization-of-binary.html)?
    It is trivial to see this as an alternative method to
    serialize/deserialize a binary tree.
    ![:)](http://leetcode.com/wp-includes/images/smilies/icon_smile.gif)

VN:F [1.9.22\_1171]

Rating: 4.6/**5** (61 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Construct Binary Tree From Inorder and Preorder/Postorder
Traversal</span></span>, <span class="rating"><span
class="average">4.6</span> out of <span class="best">5</span> based on
<span class="votes">61</span> ratings <span
class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2011/04/construct-binary-tree-from-inorder-and-preorder-postorder-traversal.html>

> Convert a BST to a sorted circular doubly-linked list in-place. Think
> of the left and right pointers as synonymous to the previous and next
> pointers in a doubly-linked list.

<span id="more-63"></span>  
If the problem statement is still not clear to you, below is a pictorial
representation of what you need to do:

[![](http://4.bp.blogspot.com/_UElib2WLeDE/TPRo1mUmf2I/AAAAAAAACZM/BzwriSAGybw/s1600/tree.png)](http://4.bp.blogspot.com/_UElib2WLeDE/TPRo1mUmf2I/AAAAAAAACZM/BzwriSAGybw/s1600/tree.png)

<span>i) an ordered binary tree (BST) storing numbers from 1 – 5.</span>

[![](http://4.bp.blogspot.com/_UElib2WLeDE/TPRo9cJLq_I/AAAAAAAACZQ/aiBIfOyQFX0/s1600/treelist2.gif)](http://4.bp.blogspot.com/_UElib2WLeDE/TPRo9cJLq_I/AAAAAAAACZQ/aiBIfOyQFX0/s1600/treelist2.gif)

<span>ii) original tree converted to a sorted circular doubly-linked
list. Its <span>left </span>and <span>right </span>pointers were
modified to point to its previous and next node.</span>

I originally read this interesting problem here: [The Great Tree-List
Recursion
Problem](http://cslibrary.stanford.edu/109/TreeListRecursion.html).

**Hint:**  
Think of in-order traversal. How do you ensure that the last element’s
right pointer points back to the first element?

[![](http://1.bp.blogspot.com/_UElib2WLeDE/TPR8ILKoieI/AAAAAAAACZY/BoU90YXHePc/s1600/doublylist.gif)](http://1.bp.blogspot.com/_UElib2WLeDE/TPR8ILKoieI/AAAAAAAACZY/BoU90YXHePc/s1600/doublylist.gif)

<span>A circular doubly-linked list. Think of the left and right
pointers in a tree as synonymous to the previous and next pointers in a
list.</span>

**Solution:**  
When I first see this problem, my first thought was in-order traversal.
Couldn’t we modify the nodes’ left and right pointers as we do an
in-order traversal of the tree? However, we have to beware not to modify
the pointers and accessing it at a later time.

As we traverse the tree in-order, we could safely modify a node’s left
pointer to point to the previously traversed node as we never use it
once we reach a node. We would also need to modify the previously
traversed node’s right pointer to point to the current node. Note: The
previously traversed node meant here is **not** its parent node. It is
the node’s previous smaller element.

Easy approach, right? But wait, we are still missing two more steps.
First, we did not assign the list’s head pointer. Second, the last
element’s right pointer does not point to the first element (similar to
the first element’s left pointer).

How do we solve this? My approach is pretty easy: Just update the
current node’s right pointer to point back to the head and the head’s
left pointer to point to current node in each recursive call. As the
recursion ends, the list’s head and tail would be automagically updated
with the correct pointers. Don’t forget to check for this special case:
A list with only one element should have its left and right pointers
both pointing back to itself.

[![](http://3.bp.blogspot.com/_UElib2WLeDE/TPR6fN00nnI/AAAAAAAACZU/xzaMlH9f4VI/s1600/single.gif)](http://3.bp.blogspot.com/_UElib2WLeDE/TPR6fN00nnI/AAAAAAAACZU/xzaMlH9f4VI/s1600/single.gif)

<span>A double-linked list with a length of one.</span>

Do you think this approach works? I bet it did! The run time complexity
for this solution is *O*(*N*) since we are essentially doing a modified
in-order traversal. It does have some extra assignments in each
recursive call though. But overall I am quite satisfied with this
approach because it is intuitive and easy to follow. Besides, we are
adapting an existing algorithm (in-order traversal) to solve this
problem, isn’t this just neat?

// This is a modified in-order traversal adapted to this problem. //
prev (init to NULL) is used to keep track of previously traversed node.
// head pointer is updated with the list's head as recursion ends. void
treeToDoublyList(Node \*p, Node \*& prev, Node \*& head) { if (!p)
return; treeToDoublyList(p-\>left, prev, head); // current node's left
points to previous node p-\>left = prev; if (prev) prev-\>right = p; //
previous node's right points to current node else head = p; // current
node (smallest element) is head of // the list if previous node is not
available // as soon as the recursion ends, the head's left pointer //
points to the last node, and the last node's right pointer // points to
the head pointer. Node \*right = p-\>right; head-\>left = p; p-\>right =
head; // updates previous node prev = p; treeToDoublyList(right, prev,
head); } // Given an ordered binary tree, returns a sorted circular //
doubly-linked list. The conversion is done in-place. Node\*
treeToDoublyList(Node \*root) { Node \*prev = NULL; Node \*head = NULL;
treeToDoublyList(root, prev, head); return head; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="c">// This is a modified in-order traversal adapted to this problem.</span></p>
<p><span class="c">// prev (init to NULL) is used to keep track of previously traversed node.</span></p>
<p><span class="c">// head pointer is updated with the list's head as recursion ends.</span></p>
<p><span class="t">void</span><span class="h"> </span><span class="e">treeToDoublyList</span><span class="sy">(</span><span class="e">Node *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="o">&amp;</span><span class="h"> </span><span class="i">prev</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="o">&amp;</span><span class="h"> </span><span class="i">head</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">treeToDoublyList</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">prev</span><span class="sy">,</span><span class="h"> </span><span class="i">head</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="c">// current node's left points to previous node</span></p>
<p><span class="h">  </span><span class="i">p</span><span class="o">-&gt;</span><span class="v">left</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">prev</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">prev</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="i">prev</span><span class="o">-&gt;</span><span class="v">right</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="sy">;</span><span class="h">  </span><span class="c">// previous node's right points to current node</span></p>
<p><span class="h">  </span><span class="st">else</span></p>
<p><span class="h">    </span><span class="v">head</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="sy">;</span><span class="h"> </span><span class="c">// current node (smallest element) is head of</span></p>
<p><span class="h">              </span><span class="c">// the list if previous node is not available</span></p>
<p><span class="h">  </span><span class="c">// as soon as the recursion ends, the head's left pointer </span></p>
<p><span class="h">  </span><span class="c">// points to the last node, and the last node's right pointer</span></p>
<p><span class="h">  </span><span class="c">// points to the head pointer.</span></p>
<p><span class="h">  </span><span class="e">Node *</span><span class="v">right</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">head</span><span class="o">-&gt;</span><span class="v">left</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">p</span><span class="o">-&gt;</span><span class="v">right</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">head</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="c">// updates previous node</span></p>
<p><span class="h">  </span><span class="v">prev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">treeToDoublyList</span><span class="sy">(</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">prev</span><span class="sy">,</span><span class="h"> </span><span class="i">head</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="c">// Given an ordered binary tree, returns a sorted circular</span></p>
<p><span class="c">// doubly-linked list. The conversion is done in-place.</span></p>
<p><span class="e">Node*</span><span class="h"> </span><span class="e">treeToDoublyList</span><span class="sy">(</span><span class="e">Node *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="e">Node *</span><span class="v">prev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Node *</span><span class="v">head</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">treeToDoublyList</span><span class="sy">(</span><span class="i">root</span><span class="sy">,</span><span class="h"> </span><span class="i">prev</span><span class="sy">,</span><span class="h"> </span><span class="i">head</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">head</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Alternative Solution:**  
There is an alternative solution which doesn’t use in-order traversal.
Instead, it uses a divide and conquer method which is quite neat. I
highly recommend you to read the solution (code provided)
[here](http://cslibrary.stanford.edu/109/TreeListRecursion.html).

VN:F [1.9.22\_1171]

Rating: 4.5/**5** (52 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Convert Binary Search Tree (BST) to Sorted Doubly-Linked
List</span></span>, <span class="rating"><span
class="average">4.5</span> out of <span class="best">5</span> based on
<span class="votes">52</span> ratings <span
class="summary"></span></span></span>

> Given an array where elements are sorted in ascending order, convert
> it to a height balanced BST.

<span id="more-61"></span>  
If you are having hard time in understanding my previous post: [Largest
Binary Search Tree (BST) in a binary
tree](http://www.leetcode.com/2010/11/largest-binary-search-tree-bst-in_22.html),
do not fret as that problem is a comparably trickier tree problem for an
interview session. But that should not be an excuse for you to not
improve your ability to think recursively (without your brain stack
being overflowed of course
![](http://4.bp.blogspot.com/_UElib2WLeDE/TK7aJSBFXSI/AAAAAAAACW8/5f8CRD5dJ8o/s1600/smiley.jpg)).

Recursion is a very powerful problem-solving mechanism, and you would
not go very far without it during an interview session. Here might be an
easier tree problem for you to start before you hop on those challenging
ones.

**Hint:**  
This question is highly recursive in nature. Think of how binary search
works.

[![](http://1.bp.blogspot.com/_UElib2WLeDE/TO7ejbeZT6I/AAAAAAAACY8/ObPohELAfV4/s400/height_balanced_tree.png)](http://1.bp.blogspot.com/_UElib2WLeDE/TO7ejbeZT6I/AAAAAAAACY8/ObPohELAfV4/s1600/height_balanced_tree.png)

<span>An example of a height-balanced tree. A height-balanced tree is a
tree whose subtrees differ in height by no more than one and the
subtrees are height-balanced, too. </span>

**Solution:**  
If you would have to choose an array element to be the root of a
balanced BST, which element would you pick? The root of a balanced BST
should be the middle element from the sorted array.

You would pick the middle element from the sorted array in each
iteration. You then create a node in the tree initialized with this
element. After the element is chosen, what is left? Could you identify
the sub-problems within the problem?

There are two arrays left — The one on its left and the one on its
right. These two arrays are the sub-problems of the original problem,
since both of them are sorted. Furthermore, they are subtrees of the
current node’s left and right child.

The code below creates a balanced BST from the sorted array in *O*(*N*)
time (*N* is the number of elements in the array). Compare how similar
the code is to a binary search algorithm. Both are using the divide and
conquer methodology.

BinaryTree\* sortedArrayToBST(int arr[], int start, int end) { if
(start \> end) return NULL; // same as (start+end)/2, avoids overflow.
int mid = start + (end - start) / 2; BinaryTree \*node = new
BinaryTree(arr[mid]); node-\>left = sortedArrayToBST(arr, start, mid-1);
node-\>right = sortedArrayToBST(arr, mid+1, end); return node; }
BinaryTree\* sortedArrayToBST(int arr[], int n) { return
sortedArrayToBST(arr, 0, n-1); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="e">BinaryTree*</span><span class="h"> </span><span class="e">sortedArrayToBST</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">start</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="st">end</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">start</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="st">end</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="c">// same as (start+end)/2, avoids overflow.</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">mid</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">start</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="st">end</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">start</span><span class="sy">)</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">2</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">BinaryTree *</span><span class="v">node</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="r">new</span><span class="h"> </span><span class="e">BinaryTree</span><span class="sy">(</span><span class="v">arr</span><span class="sy">[</span><span class="i">mid</span><span class="sy">]</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">node</span><span class="o">-&gt;</span><span class="v">left</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">sortedArrayToBST</span><span class="sy">(</span><span class="i">arr</span><span class="sy">,</span><span class="h"> </span><span class="i">start</span><span class="sy">,</span><span class="h"> </span><span class="i">mid</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">node</span><span class="o">-&gt;</span><span class="v">right</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">sortedArrayToBST</span><span class="sy">(</span><span class="i">arr</span><span class="sy">,</span><span class="h"> </span><span class="i">mid</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="st">end</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">node</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="e">BinaryTree*</span><span class="h"> </span><span class="e">sortedArrayToBST</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="e">sortedArrayToBST</span><span class="sy">(</span><span class="i">arr</span><span class="sy">,</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Further Thoughts:**

Consider changing the problem statement to “Converting a singly linked
list to a balanced BST”. How would your implementation change from the
above?

Check out my next post: [Convert Sorted List to Balanced Binary Search
Tree
(BST)](http://www.leetcode.com/2010/11/convert-sorted-list-to-balanced-binary.html)
for the best solution.

VN:F [1.9.22\_1171]

Rating: 4.4/**5** (53 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Convert Sorted Array to Balanced Binary Search Tree
(BST)</span></span>, <span class="rating"><span
class="average">4.4</span> out of <span class="best">5</span> based on
<span class="votes">53</span> ratings <span
class="summary"></span></span></span>

> Given a singly linked list where elements are sorted in ascending
> order, convert it to a height balanced BST.

<span id="more-62"></span>  
If you have not checked out my previous post: [Convert Sorted Array to
Balanced Binary Search Tree
(BST)](http://www.leetcode.com/2010/11/convert-sorted-array-into-balanced.html),
you should check it out now as this solution is built upon the previous
solution.

Things get a little more complicated when you have a singly linked list
instead of an array. Please note that in linked list, you no longer have
random access to an element in *O*(1) time.

[![](http://1.bp.blogspot.com/_UElib2WLeDE/TPIbm4Fw2dI/AAAAAAAACZE/5HheaBU1RrM/s1600/Singly-linked-list.png)](http://1.bp.blogspot.com/_UElib2WLeDE/TPIbm4Fw2dI/AAAAAAAACZE/5HheaBU1RrM/s1600/Singly-linked-list.png)

<span>Singly-linked lists contain nodes which have a data field as well
as a *next* field, which points to the next node in the linked
list.</span>

**Naive Solution:**  
A naive way is to apply the previous solution directly. In each
recursive call, you would have to traverse half of the list’s length to
find the middle element. The run time complexity is clearly *O*(*N* lg
*N*), where *N* is the total number of elements in the list. This is
because each level of recursive call requires a total of *N*/2 traversal
steps in the list, and there are a total of lg *N* number of levels (ie,
the height of the balanced tree).

**Hint:**  
How about inserting nodes following the list’s order? If we can achieve
this, we no longer need to find the middle element, as we are able to
traverse the list while inserting nodes to the tree.

**Best Solution:**  
As usual, the best solution requires you to think from another
perspective. In other words, we no longer create nodes in the tree using
the top-down approach. We create nodes bottom-up, and assign them to its
parents. The bottom-up approach enables us to access the list in its
order while creating nodes.

Isn’t the bottom-up approach neat? Each time you are stucked with the
top-down approach, give bottom-up a try. Although bottom-up approach is
not the most natural way we think, it is extremely helpful in some
cases. However, you should prefer top-down instead of bottom-up in
general, since the latter is more difficult to verify in correctness.

Below is the code for converting a singly linked list to a balanced BST.
Please note that the algorithm requires the list’s length to be passed
in as the function’s parameters. The list’s length could be found in
*O*(*N*) time by traversing the entire list’s once. The recursive calls
traverse the list and create tree’s nodes by the list’s order, which
also takes *O*(*N*) time. Therefore, the overall run time complexity is
still *O*(*N*).

BinaryTree\* sortedListToBST(ListNode \*& list, int start, int end) { if
(start \> end) return NULL; // same as (start+end)/2, avoids overflow
int mid = start + (end - start) / 2; BinaryTree \*leftChild =
sortedListToBST(list, start, mid-1); BinaryTree \*parent = new
BinaryTree(list-\>data); parent-\>left = leftChild; list = list-\>next;
parent-\>right = sortedListToBST(list, mid+1, end); return parent; }
BinaryTree\* sortedListToBST(ListNode \*head, int n) { return
sortedListToBST(head, 0, n-1); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="e">BinaryTree*</span><span class="h"> </span><span class="e">sortedListToBST</span><span class="sy">(</span><span class="e">ListNode *</span><span class="o">&amp;</span><span class="h"> </span><span class="i">list</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">start</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="st">end</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">start</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="st">end</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="c">// same as (start+end)/2, avoids overflow</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">mid</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">start</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="st">end</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">start</span><span class="sy">)</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">2</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">BinaryTree *</span><span class="v">leftChild</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">sortedListToBST</span><span class="sy">(</span><span class="i">list</span><span class="sy">,</span><span class="h"> </span><span class="i">start</span><span class="sy">,</span><span class="h"> </span><span class="i">mid</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">BinaryTree *</span><span class="r">parent</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="r">new</span><span class="h"> </span><span class="e">BinaryTree</span><span class="sy">(</span><span class="i">list</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="r">parent</span><span class="o">-&gt;</span><span class="v">left</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">leftChild</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">list</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">list</span><span class="o">-&gt;</span><span class="i">next</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="r">parent</span><span class="o">-&gt;</span><span class="v">right</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">sortedListToBST</span><span class="sy">(</span><span class="i">list</span><span class="sy">,</span><span class="h"> </span><span class="i">mid</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="st">end</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="r">parent</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="e">BinaryTree*</span><span class="h"> </span><span class="e">sortedListToBST</span><span class="sy">(</span><span class="e">ListNode *</span><span class="i">head</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="e">sortedListToBST</span><span class="sy">(</span><span class="i">head</span><span class="sy">,</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.7/**5** (107 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Convert Sorted List to Balanced Binary Search Tree
(BST)</span></span>, <span class="rating"><span
class="average">4.7</span> out of <span class="best">5</span> based on
<span class="votes">107</span> ratings <span
class="summary"></span></span></span>

CTRL+A, CTRL+C, CTRL+V
======================

January 4, 2011 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> Imagine you have a special keyboard with the following keys:
>
> 1.  A
> 2.  Ctrl+A
> 3.  Ctrl+C
> 4.  Ctrl+V
>
> where CTRL+A, CTRL+C, CTRL+V each acts as one function key for “Select
> All”, “Copy”, and “Paste” operations respectively.
>
> If you can only press the keyboard for *N* times (with the above four
> keys), please write a program to produce maximum numbers of A. If
> possible, please also print out the sequence of keys.<span
> id="more-69"></span>
>
> That is to say, the input parameter is *N* (No. of keys that you can
> press), the output is *M* (No. of As that you can produce).

This question seemed like a brand new interview question from Google.
Someone posted this problem on a [discussion
board](http://www.careercup.com/question?id=7184083), and it generated a
lot of discussions, which unfortunately none of them is really helpful
in solving this problem. Here, I discuss my approach and solution to
this problem, and just like those other tricky questions from a typical
Google interview — the common pitfalls you might fall into.

One common strategy in problem solving is to always begin with small
examples.

It is trivial to notice that for *N* M = *N*. But how about the case
where *N* = 7? Here is where the most common pitfall that most people
would fall into (myself included).

Most people reason that for *N* = 7, the answer is *M* = 8, because the
sequence *S* = { A, A, A, A, CTRL+A, CTRL+C, CTRL+V } produces a total
of 8 A’s.

Wait, the copied text is still in the buffer after a paste operation. We
could have applied CTRL+V twice to double the previous text, sweet!
![](http://4.bp.blogspot.com/_UElib2WLeDE/TK7aJSBFXSI/AAAAAAAACW8/5f8CRD5dJ8o/s1600/smiley.jpg)

How about *S* = { A, A, A, CTRL+A, CTRL+C, CTRL+V, CTRL+V } which
produces a total of 9 A’s?

Unfortunately, both of the above answers are incorrect, as the correct
answer for *N* = 7 is *M* = 7. This is simply because the sequence of {
CTRL+A, CTRL+C, CTRL+V } does not double the previous text. Why? Take a
moment to let this to sink into your brain.

Answers for *N* up to 7 is easy, which is *M* = *N*. But how about *N* =
8?

For *N* = 8 the answer is *M* = 9, where *S* = { A, A, A, CTRL+A,
CTRL+C, CTRL+V, CTRL+V, CTRL+V }.

For *N* = 9 the answer is *M* = 12, where *S* = { A, A, A, CTRL+A,
CTRL+C, CTRL+V, CTRL+V, CTRL+V, CTRL+V }.

You might ask why all A’s are typed before the sequence of { CTRL+A,
CTRL+C, CTRL+V } operations.

Assume that we could insert A’s at the back of some sequence of {
CTRL+A, CTRL+C, CTRL+V } and yield a maximum sequence. If we take all
the A’s from the back and insert it at the front, this modified sequence
must yield a larger number of A’s, since the number of A’s is multipled
from the beginning. Therefore, by contradiction, all A’s must always be
inserted at the front to yield the maximum number of A’s. Similar for
the case where A’s are inserted in the middle of the sequence.

Before we proceed further, we introduce the following notation:

-   Define **4A** as a sequence of { A, A, A, A }. Therefore, **5A**
    would then mean { A, A, A, A, A }.
-   Define **2D** as a sequence of CTRL+A, CTRL+C, CTRL+V, CTRL+V, which
    simply means *double the previous text*. Note that **3D** does not
    double the previous text, it actually triples the previous text.

With this notation in place, it is much easier to work with this
problem. Using the above notation, we rewrite our answer for *N* = 8 and
*N* = 9.

*N* = 8, *S* = { **3A3D** }, *M* = 9.

*N* = 9, *S* = { **3A4D** }, *M* = 12.

The value of M could be obtained simply by multiplying the numbers,
isn’t that neat?

Working our way up:  
*N* = 10, *S* = { **4A4D** }, *M* = 16.

*N* = 11, *S* = { **5A4D** }, *M* = 20.

As you can see, the pattern here is pretty obvious, let’s summarize as
follow:

-   The solution so far for *N* \> 7 is to find integers *a* and *b*
    such that *ab* yields the largest product, subjected to the
    condition where *a*+*b* = *N*-2.
-   Both *a* and *b* are easy to find, as the largest product is found
    when the difference of *a* and *b* is less than or equal to one.

Similarly,  
*N* = 12, *S* = { **5A5D** }, *M* = 25.  
*N* = 13, *S* = { **5A6D** }, *M* = 30.  
*N* = 14, *S* = { **6A6D** }, *M* = 36.

Be extra cautious for *N* = 15.  
When *N* = 15, does the sequence { **6A7D** } yields the maximum where
*M* = 42?

Imagine if you have a very large number of keystrokes to enter, does
pressing CTRL+V forever gives you the maximum sequence? Remember, you
can redo the entire { CTRL+A, CTRL+C, CTRL+V } operations again and
potentially maximizes the sequence.

For *N* = 15, the maximum sequence should be:  
{ **3A4D4D** }, which yields *M* = 48.

Similarly,  
*N* = 16, *S* = { **4A4D4D** }, *M* = 64.  
…  
*N* = 21, *S* = { **3A4D4D4D** }, *M* = 192.  
…  
*N* = 25, *S* = { **4A5D5D5D** }, *M* = 500.  
*N* = 26, *S* = { **5A5D5D5D** }, *M* = 625.  
*N* = 27, *S* = { **3A4D4D4D4D** }, *M* = 768.

Let’s generalize the above:

*M* = MAX (*a*<sub>1</sub> . *a*<sub>2</sub> … *a<sub>k</sub>*),
where *  
a*<sub>1</sub> + *a*<sub>2</sub> + … + *a*<sub>k</sub> = *n* – 2(*k*-1)

To obtain *M* = MAX (*a*<sub>1</sub> . *a*<sub>2</sub> …
*a*<sub>k</sub>),  
it is necessary that the below condition must be met:

∀ *i*, *j* ∈{ 1, 2, … , *k* } : MAX ( | *a<sub>i</sub>* –
*a<sub>j</sub>* | ) = 1.

To obtain *M*, we can first divide *a*<sub>1</sub> + *a*<sub>2</sub> +
… + *a<sub>k</sub>* by *k* to obtain the average as a reference, and the
rest should be straightforward.

Now the final problem lies in how to obtain the value of *k*
efficiently. I am pretty sure this could be solved easily using [Number
Theory](http://en.wikipedia.org/wiki/Number_theory), but so far, my best
solution is to use a brute force method to obtain *k*.

Below is the C++ code for my solution. It is pretty straightforward to
output the sequence *S*. Given *N*, the function *f*() returns the
maximum value of *M*.

\#include \<iostream\> \#include \<cmath\> \#include \<cassert\> using
namespace std; int findMaxK(int n) { int power = 2; double max = 0.0;
int maxK = 0; while (n \> 0) { n -= 2; double t = (double)n/power;
double r = pow(t, (double)power); if (r \> max) { maxK = power; max = r;
} power++; } return maxK; } unsigned int f(int n) { if (n \<= 7) return
n; int k = findMaxK(n); int sum = n - 2\*(k-1); unsigned int mul = 1;
while (k \> 0) { int avg = sum/k; mul \*= avg; k--; sum -= avg; }
assert(sum == 0); return mul; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="p">#include &lt;iostream&gt;</span></p>
<p><span class="p">#include &lt;cmath&gt;</span></p>
<p><span class="p">#include &lt;cassert&gt;</span></p>
<p><span class="e">using </span><span class="t">namespace</span><span class="h"> </span><span class="i">std</span><span class="sy">;</span></p>
<p> </p>
<p><span class="t">int</span><span class="h"> </span><span class="e">findMaxK</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">power</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">2</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">double</span><span class="h"> </span><span class="v">max</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0.0</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">maxK</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="i">n</span><span class="h"> </span><span class="o">-</span><span class="o">=</span><span class="h"> </span><span class="cn">2</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="t">double</span><span class="h"> </span><span class="v">t</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="t">double</span><span class="sy">)</span><span class="i">n</span><span class="o">/</span><span class="i">power</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="t">double</span><span class="h"> </span><span class="v">r</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">pow</span><span class="sy">(</span><span class="i">t</span><span class="sy">,</span><span class="h"> </span><span class="sy">(</span><span class="t">double</span><span class="sy">)</span><span class="i">power</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">r</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">max</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">            </span><span class="v">maxK</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">power</span><span class="sy">;</span></p>
<p><span class="h">            </span><span class="v">max</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">r</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="sy">}</span></p>
<p><span class="h">        </span><span class="i">power</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="i">maxK</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">unsigned</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="e">f</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="cn">7</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">k</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">findMaxK</span><span class="sy">(</span><span class="i">n</span><span class="sy">)</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">sum</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">n</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">2</span><span class="o">*</span><span class="sy">(</span><span class="i">k</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">unsigned</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">mul</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">k</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="t">int</span><span class="h"> </span><span class="v">avg</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">sum</span><span class="o">/</span><span class="i">k</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="e">mul *</span><span class="o">=</span><span class="h"> </span><span class="i">avg</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="i">k</span><span class="o">--</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="i">sum</span><span class="h"> </span><span class="o">-</span><span class="o">=</span><span class="h"> </span><span class="i">avg</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p> </p>
<p><span class="h">    </span><span class="st">assert</span><span class="sy">(</span><span class="v">sum</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="i">mul</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.8/**5** (25 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">CTRL+A, CTRL+C, CTRL+V</span></span>, <span
class="rating"><span class="average">4.8</span> out of <span
class="best">5</span> based on <span class="votes">25</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2011/01/ctrla-ctrlc-ctrlv.html>

> Given a singly linked list, find if there exist a loop.

<span id="more-34"></span>This is one of the most common interview
questions asked during a technical interview. I call it the classic
linked list question.

The naive approach requires O(N^2) time and O(N) space. Basically you
store all visited nodes, and compare each of them while traversing each
node.

Hint: The best approach uses only O(N) time and O(1) space. Remember my
[previous
post](http://www.leetcode.com/2010/09/splitting-linked-list.html)? Try
to use two pointers to traverse the list.

Solution:  
The best solution runs in O(N) time and uses O(1) space. It uses two
pointers (one slow pointer and one fast pointer). The slow pointer
advances one node at a time, while the fast pointer traverses twice as
fast. If the list has loop in it, eventually the fast and slow pointer
will meet at the same node. On the other hand, if the loop has no loop,
the fast pointer will reach the end of list before the slow pointer
does.

bool hasLoop(Node \*head) { Node \*slow = head, \*fast = head; while
(slow && fast && fast-\>next) { slow = slow-\>next; fast =
fast-\>next-\>next; if (slow == fast) return true; } return false; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">bool</span><span class="h"> </span><span class="e">hasLoop</span><span class="sy">(</span><span class="e">Node *</span><span class="i">head</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="e">Node *</span><span class="v">slow</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">head</span><span class="sy">,</span><span class="h"> </span><span class="o">*</span><span class="v">fast</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">head</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">slow</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">fast</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">fast</span><span class="o">-&gt;</span><span class="i">next</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">slow</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">slow</span><span class="o">-&gt;</span><span class="i">next</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">fast</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">fast</span><span class="o">-&gt;</span><span class="i">next</span><span class="o">-&gt;</span><span class="i">next</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">slow</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">fast</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

This elegant algorithm is known as [Floyd’s cycle finding
algorithm](http://en.wikipedia.org/wiki/Floyd%27s_cycle-finding_algorithm#Tortoise_and_hare),
also called the Tortoise and hare algorithm.

**Alternative solutions:**  
There is another alternative solution that also runs in O(N) time and
O(1) space, but the catch is it requires modification to the list. Try
reversing the list if it has a loop in it. What do you see? Yes,
eventually you will arrive back at the beginning (the head node). Read
my post
[here](http://www.leetcode.com/2010/04/reversing-linked-list-iteratively-and.html)
on how to reverse a linked list iteratively and recursively.

**More linked list practice:**  
 If you are kind of rusty on pointers, solving all kinds of linked list
problems are good exercises.

Here are some very common questions on linked list from easy to
difficult, all available for download in a [single pdf
file](http://cslibrary.stanford.edu/105/LinkedListProblems.pdf). Highly
recommended!

» [Linked List
Problems](http://cslibrary.stanford.edu/105/LinkedListProblems.pdf)

VN:F [1.9.22\_1171]

Rating: 4.8/**5** (13 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Detecting a Loop in a Singly Linked List</span></span>, <span
class="rating"><span class="average">4.8</span> out of <span
class="best">5</span> based on <span class="votes">13</span> ratings
<span class="summary"></span></span></span>

> Write a function isBST(BinaryTree \*node) to verify if a given binary
> tree is a Binary Search Tree (BST) or not.

<span id="more-37"></span>

First, you must understand the difference between *Binary Tree* and
*Binary Search Tree (BST)*. Binary tree is a tree data structure in
which each node has at most two child nodes. A binary search tree (BST)
is based on binary tree, but with the following additional properties:  

-   The left subtree of a node contains only nodes with keys less than
    the node’s key.
-   The right subtree of a node contains only nodes with keys greater
    than the node’s key.
-   Both the left and right subtrees must also be binary search trees.

This question is a very good interview question, because it *really*
tests your understanding of the definition of BST. Most people will fall
to this first trap, and gives the following algorithm:

Assume that the current node’s value is *k*. Then for each node, check
if the left node’s value is less than *k* and the right node’s value is
greater than *k*. If all of the nodes satisfy this property, then it is
a BST.

It sounds correct and convincing, but look at this counter example
below: A sample tree which we name it as <span>binary tree (1)</span>.

        10
       /  \
      5   15     -------- binary tree (1)
         /  \
        6    20

It’s obvious that this is not a valid BST, since <span>(6)</span> could
never be on the right of <span>(10)</span>.

Based on BST’s definition, we can then easily devise a brute-force
solution:

Assume that the current node’s value is *k*. Then for each node, check
if all nodes of left subtree contain values that are less than *k*. Also
check if all nodes of right subtree contain values that are greater than
*k*. If all of the nodes satisfy this property, then it must be a BST.

Below is the brute force code (though inefficient, but works):

bool isSubTreeLessThan(BinaryTree \*p, int val) { if (!p) return true;
return (p-\>data \< val && isSubTreeLessThan(p-\>left, val) &&
isSubTreeLessThan(p-\>right, val)); } bool
isSubTreeGreaterThan(BinaryTree \*p, int val) { if (!p) return true;
return (p-\>data \> val && isSubTreeGreaterThan(p-\>left, val) &&
isSubTreeGreaterThan(p-\>right, val)); } bool
isBSTBruteForce(BinaryTree \*p) { if (!p) return true; return
isSubTreeLessThan(p-\>left, p-\>data) && isSubTreeGreaterThan(p-\>right,
p-\>data) && isBSTBruteForce(p-\>left) && isBSTBruteForce(p-\>right); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">bool</span><span class="h"> </span><span class="e">isSubTreeLessThan</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">val</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">val</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span></p>
<p><span class="h">          </span><span class="e">isSubTreeLessThan</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">val</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span></p>
<p><span class="h">          </span><span class="e">isSubTreeLessThan</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">val</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">bool</span><span class="h"> </span><span class="e">isSubTreeGreaterThan</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">val</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">val</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span></p>
<p><span class="h">          </span><span class="e">isSubTreeGreaterThan</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">val</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span></p>
<p><span class="h">          </span><span class="e">isSubTreeGreaterThan</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">val</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">bool</span><span class="h"> </span><span class="e">isBSTBruteForce</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="e">isSubTreeLessThan</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span></p>
<p><span class="h">         </span><span class="e">isSubTreeGreaterThan</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span></p>
<p><span class="h">         </span><span class="e">isBSTBruteForce</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span></p>
<p><span class="h">         </span><span class="e">isBSTBruteForce</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Solution:**  
Here is the much better solution. Instead of examining all nodes of both
subtrees in each pass, we only need to examine two nodes in each pass.

Refer back to the <span>binary tree (1)</span> above. As we traverse
down the tree from node <span>(10)</span> to right node
<span>(15)</span>, we know for sure that the right node’s value fall
between **10** and **+INFINITY**. Then, as we traverse further down from
node <span>(15)</span> to left node <span>(6)</span>, we know for sure
that the left node’s value fall between **10** and **15**. And since
<span>(6)</span> does not satisfy the above requirement, we can quickly
determine it is not a valid BST. All we need to do is to pass down the
low and high limits from node to node! Once we figure out this
algorithm, it is easy to code.

bool isBSTHelper(BinaryTree \*p, int low, int high) { if (!p) return
true; if (low \< p-\>data && p-\>data \< high) return
isBSTHelper(p-\>left, low, p-\>data) && isBSTHelper(p-\>right, p-\>data,
high); else return false; } bool isBST(BinaryTree \*root) { // INT\_MIN
and INT\_MAX are defined in C++'s \<climits\> library return
isBSTHelper(root, INT\_MIN, INT\_MAX); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">bool</span><span class="h"> </span><span class="e">isBSTHelper</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">low</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">high</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">low</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">high</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">isBSTHelper</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">low</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span></p>
<p><span class="h">           </span><span class="e">isBSTHelper</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">,</span><span class="h"> </span><span class="i">high</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">else</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">bool</span><span class="h"> </span><span class="e">isBST</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="c">// INT_MIN and INT_MAX are defined in C++'s &lt;climits&gt; library</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="e">isBSTHelper</span><span class="sy">(</span><span class="i">root</span><span class="sy">,</span><span class="h"> </span><span class="i">INT_MIN</span><span class="sy">,</span><span class="h"> </span><span class="i">INT_MAX</span><span class="sy">)</span><span class="sy">;</span><span class="h">  </span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

This algorithm runs in O(N) time, where N is the number of nodes of the
binary tree. It also uses O(1) space (neglecting the stack space used by
calling function recursively).

**Alternative Solution:**  
Another solution is to do an in-order traversal of the binary tree, and
verify that the previous value (can be passed into the recursive
function as reference) is less than the current value. This works
because when you do an in-order traversal on a BST, the elements must be
strictly in increasing order. This method also runs in O(N) time and
O(1) space.

bool isBSTInOrderHelper(BinaryTree \*p, int& prev) { if (!p) return
true; return (isBSTInOrderHelper(p-\>left, prev) && (p-\>data \> prev)
&& (prev = p-\>data) && isBSTInOrderHelper(p-\>right, prev)); } bool
isBSTInOrder(BinaryTree \*root) { int prev = INT\_MIN; return
isBSTInOrderHelper(root, prev); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">bool</span><span class="h"> </span><span class="e">isBSTInOrderHelper</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="o">&amp;</span><span class="h"> </span><span class="i">prev</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="e">isBSTInOrderHelper</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">prev</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span></p>
<p><span class="h">          </span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">prev</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="sy">(</span><span class="v">prev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span></p>
<p><span class="h">          </span><span class="e">isBSTInOrderHelper</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">prev</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">bool</span><span class="h"> </span><span class="e">isBSTInOrder</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">prev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">INT_MIN</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="e">isBSTInOrderHelper</span><span class="sy">(</span><span class="i">root</span><span class="sy">,</span><span class="h"> </span><span class="i">prev</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**<span>EDIT: (Bug fix)</span>**  
An id <span>han6</span> from the MITBBS forum pointed that the above
code has a bug. When one of the node’s value is 0, the function would
return false straight away, even though it is a valid BST. Why?

Below is the corrected code:

bool isBSTInOrderHelper(BinaryTree \*p, int& prev) { if (!p) return
true; if (isBSTInOrderHelper(p-\>left, prev)) { if (p-\>data \> prev) {
prev = p-\>data; return isBSTInOrderHelper(p-\>right, prev); } else {
return false; } } else { return false; } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">bool</span><span class="h"> </span><span class="e">isBSTInOrderHelper</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="o">&amp;</span><span class="h"> </span><span class="i">prev</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="e">isBSTInOrderHelper</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">prev</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">prev</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">prev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="e">isBSTInOrderHelper</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">prev</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Additional Exercise:**  
We know that the brute force solution is inefficient. But how does it
compare to the better solutions? In other words, what is the run time
complexity of the brute force solution? Try to estimate as best as you
can, and then find the correct answer by proving it using Math. Does
your estimate fares well with the correct answer? Why?

(Hint: The run time complexity for the brute force approach is NOT
exponential.)

VN:F [1.9.22\_1171]

Rating: 4.7/**5** (31 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Determine if a Binary Tree is a Binary Search Tree
(BST)</span></span>, <span class="rating"><span
class="average">4.7</span> out of <span class="best">5</span> based on
<span class="votes">31</span> ratings <span
class="summary"></span></span></span>

Determine If Two Rectangles Overlap
===================================

May 12, 2011 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> Given two axis-aligned rectangles A and B. Write a function to
> determine if the two rectangles overlap.

<span id="more-729"></span>  
 **Hint:**  
 If you are coming up with a complicated set of conditionals, you might
think too hard. There is an easier way. Try to think in the opposite
direction.

[![](http://www.leetcode.com/wp-content/uploads/2011/05/overlap_rect1.gif "overlap_rect1")](http://www.leetcode.com/wp-content/uploads/2011/05/overlap_rect1.gif)

Two overlapping rectangles. A rectangle can be defined by its upper left
and lower right corner.

**Solution:**  
 Assume that the two rectangles are given as point (P1, P2) and (P3, P4)
respectively. One direct way to attempt this problem is when two
rectangles overlap, one rectangle’s corner point(s) must contain in the
other rectangle. Do keep in mind of the following cases:

[![](http://www.leetcode.com/wp-content/uploads/2011/05/overlap_rect2.gif "overlap_rect2")](http://www.leetcode.com/wp-content/uploads/2011/05/overlap_rect2.gif)
[](http://www.leetcode.com/wp-content/uploads/2011/05/overlap_rect3.gif)
[![](http://www.leetcode.com/wp-content/uploads/2011/05/overlap_rect3.gif "overlap_rect3")](http://www.leetcode.com/wp-content/uploads/2011/05/overlap_rect3.gif)

More overlapping rectangles cases to consider.

As you can see, the conditionals can be pretty complicated as there are
a total eight of them. Can we simplify it further?

A much easier and better approach would be to think from the opposite.
How about asking yourself how the two rectangles *cannot* overlap each
other? Two rectangles do not overlap when one is above/below, or to the
left/right of the other rectangle.

The condition’s expression is:

    ! ( P2.y  P4.y || P2.x  P4.x )

Using [De Morgan’s
law](http://en.wikipedia.org/wiki/De_Morgan%27s_laws#Negation_of_a_disjunction),
we can further simplify the above expression to:

    ( P2.y = P3.y && P1.y = P4.y && P2.x = P3.x && P1.x = P4.x )

**Further Thoughts:**

-   What if the two rectangles are not necessarily axis-aligned? (That
    is, the rectangles can be rotated around its center at a certain
    angle.) Solving this problem requires more Math and understanding of
    linear algebra, so if you’re interested see my post on: [How to
    determine if a point is inside a
    rectangle](http://www.leetcode.com/2010/04/how-to-determine-if-point-is-inside.html).
-   Given a list of rectangles, how would you determine the set of
    overlapping rectangles efficiently? Why would this be useful?
    Imagine you have a number of windows opened on your desktop. The
    operating system would need to know the overlapped windows in order
    to repaint the dirty region as windows are being moved around.

VN:F [1.9.22\_1171]

Rating: 4.7/**5** (31 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Determine If Two Rectangles Overlap</span></span>, <span
class="rating"><span class="average">4.7</span> out of <span
class="best">5</span> based on <span class="votes">31</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2011/05/determine-if-two-rectangles-overlap.html>

### Leave a reply

### 3 trackbacks

-   *on October 10, 2011*
-   *on October 20, 2012*
-   *on September 30, 2014*

> A double-square number is an integer **X** which can be expressed as
> the sum of two perfect squares. For example, 10 is a double-square
> because 10 = 3<sup>2</sup> + 1<sup>2</sup>. Your task in this problem
> is, given X, determine the number of ways in which it can be written
> as the sum of two squares. <span id="more-71"></span>For example, 10
> can only be written as 32 + 12 (we don’t count 1<sup>2</sup> +
> 3<sup>2</sup> as being different). On the other hand, 25 can be
> written as 5<sup>2</sup> + 0<sup>2</sup> or as 4<sup>2</sup> +
> 3<sup>2</sup>.
>
> **Input**  
> You should first read an integer **N**, the number of test cases. The
> next **N** lines will contain **N** values of **X**.
>
> **Constraints**  
> 0 = **X** = 2147483647  
> 1 = **N** = 100
>
> **Output**  
> For each value of **X**, you should output the number of ways to write
> **X** as the sum of two squares.

Here is my problem analysis for Facebook Hacker Cup Qualification Round:
Double Square. While you are reading the problems, you would notice a
little subtitle under the main title “Facebook Hacker Cup” that says
“*Too hard for brute force, switching to dp*“. It’s there for a purpose.
![](http://4.bp.blogspot.com/_UElib2WLeDE/TK7aJSBFXSI/AAAAAAAACW8/5f8CRD5dJ8o/s1600/smiley.jpg)

**Double Square Problem Analysis:**  
This problem can be brute-forced (Read below for an efficient
*O*(<span>v</span>*M*) solution). At first I thought of an approach
using DP, but it would require an array of size 2147483647, which
requires at least 2GB of memory (assuming each element of the array is
of type unsigned char).

[![](http://3.bp.blogspot.com/_UElib2WLeDE/TSvs-LSU_pI/AAAAAAAACcU/WYL5gcT0Mjc/s1600/double_squares.JPG)](http://3.bp.blogspot.com/_UElib2WLeDE/TSvs-LSU_pI/AAAAAAAACcU/WYL5gcT0Mjc/s1600/double_squares.JPG)

<span>Some interesting double squares. Isn’t Math beautiful?</span>

Unfortunately, my C++ program failed to allocate such huge amount of
memory. I quickly thought of another approach using bit manipulation to
store two values in each array element (ie, each occupying 4 bits, half
of the size of unsigned char). Although this halved the memory usage
requirement, this also means the maximum value of each element could not
exceed 2<sup>4</sup> = 16, which is not true, since the largest value
could go up to 64. (ie, total number of double squares for the number
**1215306625** is **64**.)

The brute-force method is easy to implement and its complexity is
*O*(*M*), where *M* is the input number. Since the input specified that
*N* (total number of inputs) is at most 100, the brute force approach
still holds, even though it might take about 30 seconds to few minutes
to run.

int doubleSquare(unsigned int m) { int total = 0; int iUpper =
sqrt((double)m / 2.0); for (int i = 0; i \<= iUpper; i++) { unsigned int
ii = i\*i; for (int j = i; ; j++) { unsigned int sum = ii + j\*j; if
(sum == m) total++; else if (sum \> m) break; } } return total; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">doubleSquare</span><span class="sy">(</span><span class="t">unsigned</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">m</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">total</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">iUpper</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">sqrt</span><span class="sy">(</span><span class="sy">(</span><span class="t">double</span><span class="sy">)</span><span class="i">m</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">2.0</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">iUpper</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">unsigned</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">ii</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">i*</span><span class="i">i</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">i</span><span class="sy">;</span><span class="h"> </span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="t">unsigned</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">sum</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">ii</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="e">j*</span><span class="i">j</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">sum</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">m</span><span class="sy">)</span></p>
<p><span class="h">        </span><span class="i">total</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">sum</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">m</span><span class="sy">)</span></p>
<p><span class="h">        </span><span class="st">break</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">total</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Update:**

Thanks to a reader
[**Pingvin**](http://www.leetcode.com/2011/01/double-square-problem-analysis.html?showComment=1294708117368#c8866954883098506071),
who suggested an efficient *O*(<span>v</span>*M*) solution!

Consider that:  
*M* = *x*<sup>2</sup> + *y*<sup>2</sup>,

and we have *y*<sup>2</sup> = *M* – *x*<sup>2</sup>.

We can easily tell if (*M* - *x*<sup>2</sup>) is a perfect square by
taking the square root of it and compare it to its truncated value
(deleting its fractional part). If both are equal, then it must be a
perfect square, or else it is not. This observation is so subtle that
many will miss it, yet it just clicks in your head right when you see
it! Wow!

int doubleSquare(unsigned int m) { int p = sqrt((double)m / 2.0); int
total = 0; for (int i = 0; i \<= p; i++) { double j = sqrt((double)m -
i\*i); if (j - (int)j == 0.0) // might have precision issue, total++; //
can be resolved using |j-(int)j| == delta } return total; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">doubleSquare</span><span class="sy">(</span><span class="t">unsigned</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">m</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">p</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">sqrt</span><span class="sy">(</span><span class="sy">(</span><span class="t">double</span><span class="sy">)</span><span class="i">m</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">2.0</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">total</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">p</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">double</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">sqrt</span><span class="sy">(</span><span class="sy">(</span><span class="t">double</span><span class="sy">)</span><span class="i">m</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="e">i*</span><span class="i">i</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">j</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="sy">)</span><span class="v">j</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0.0</span><span class="sy">)</span><span class="h">   </span><span class="c">// might have precision issue, </span></p>
<p><span class="h">      </span><span class="i">total</span><span class="o">++</span><span class="sy">;</span><span class="h">  </span><span class="c">// can be resolved using |j-(int)j| == delta</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">total</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 3.7/**5** (12 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Double Square Problem Analysis</span></span>, <span
class="rating"><span class="average">3.7</span> out of <span
class="best">5</span> based on <span class="votes">12</span> ratings
<span class="summary"></span></span></span>

> Facebook decided to launch [Hacker
> Cup](http://www.facebook.com/hackercup), a programming contest to
> attract the world’s best talents to their HQ. The qualification round
> started on Friday 4pm (US’s PST timezone) and continues for 72 hours,
> so [go ahead and join now](http://www.facebook.com/hackercup).

[![](http://3.bp.blogspot.com/_UElib2WLeDE/TSgq0nxMx3I/AAAAAAAACcI/hDq_N_sTlMY/s400/hacker_cup_logo.jpg)](http://3.bp.blogspot.com/_UElib2WLeDE/TSgq0nxMx3I/AAAAAAAACcI/hDq_N_sTlMY/s1600/hacker_cup_logo.jpg)

<span>Facebook’s Hacker Cup, equivalent to Google’s Code Jam. The
cheapest way to attract the best talents from all over the world.</span>

Just finished [Facebook Hacker Cup Online Qualification
Round](http://www.facebook.com/hackercup/problems.php?round=4) and
thought that I might share some of my thoughts about it.

Just like [Google’s CodeJam](http://code.google.com/codejam/), this
round consisted a total of three problems, and you would need to solve
just one of the problem correctly to qualify for the next round.

I admit, I had a lot of fun in this round (which had a lot of hidden
surprise in the problems), but the contest’s interface totally suck the
hell out of a rhino’s @$$. And seemed like [I am not the only one who
agrees on
this](http://www.quora.com/Andrew-Brown-2/Facebook-Hacker-Cup-Resounding-Failure).

**The first glitch that really got on my nerves –**  
As you download the input file, the timer starts to countdown, without
you knowing about it. Then, I found a little notice on the corner saying
that you would have to refresh the browser after downloading the input
file to see the timer. I don’t know why, but this seemed stupid and
unacceptable to me.

[![](http://4.bp.blogspot.com/_UElib2WLeDE/TSgpqW-oTEI/AAAAAAAACcA/5KU_r2PTkcc/s1600/notice.JPG)](http://4.bp.blogspot.com/_UElib2WLeDE/TSgpqW-oTEI/AAAAAAAACcA/5KU_r2PTkcc/s1600/notice.JPG)

<span>I totally missed this notice box. Guess they don’t want many
people to know that there is actually a little timer.</span>

Second, when you want to submit the answer, it opens up a small text box
(by small I mean something like 10×100 pixels), and you are suppose to
paste your program’s output to that little text box. What a FAIL — They
could have done much better.

[![](http://1.bp.blogspot.com/_UElib2WLeDE/TSgpEbcgtyI/AAAAAAAACb8/LAnXgkdsvIs/s1600/submit_textbox.JPG)](http://1.bp.blogspot.com/_UElib2WLeDE/TSgpEbcgtyI/AAAAAAAACb8/LAnXgkdsvIs/s1600/submit_textbox.JPG)

<span>No kidding. This is the *original size* of the text box where you
are suppose to paste your answer into.</span>

Third, after you submitted the answer, there is a message box that
mentioned that you would need to wait until the contest is over to find
out if your answer is correct. Oh well… On the other hand, the timer
just continue on ticking until it says “Time expired”. You get multiple
chances to submit your answer, but ONLY within the limited time. I
learned the hard way. My advice to you is test your code carefully for
edge cases before downloading the input. During the limited time you
won’t be able to do much about it if you find that your code has a bug.

[![](http://3.bp.blogspot.com/_UElib2WLeDE/TSgqVDGUG8I/AAAAAAAACcE/bDebAd4I3fc/s400/hacker_cup.JPG)](http://3.bp.blogspot.com/_UElib2WLeDE/TSgqVDGUG8I/AAAAAAAACcE/bDebAd4I3fc/s1600/hacker_cup.JPG)

<span> Time expired… Grrr…</span>

Anyway, enough ranting and let’s move on to the fun part, which are the
problems itself.

**Double Squares:**  
This is a really fun problem with a little surprise behind it. While you
are reading the problem, you would notice a little subtitle under the
main title “Facebook Hacker Cup” that says “*Too hard for brute force,
switching to dp*“. It’s there for a purpose.
![](http://4.bp.blogspot.com/_UElib2WLeDE/TK7aJSBFXSI/AAAAAAAACW8/5f8CRD5dJ8o/s1600/smiley.jpg)
I knew I did not get this correct because of their timer display
requires a browser reload…

**Peg Game:**  
You need to read this problem carefully. Don’t worry, you won’t need
much from theory of probability. Reminds me of the binomial theorem. If
there are no missing pegs, then the probability of each column could be
calculated easily using binomial coefficients. This problem is pretty
straight forward, but you need to be some what careful.

**Studious Student:**  
This is a fun problem. It is easy to understand the problem statement
and it is also easy to fall into a trap. This problem is not as straight
forward as you think it might be.

I will post my analysis and solution after the contest is over. Till
then have fun solving the problems!

VN:F [1.9.22\_1171]

Rating: 4.0/**5** (1 vote cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Facebook Hacker Cup Online Qualification Round Begins
Now!</span></span>, <span class="rating"><span
class="average">4.0</span> out of <span class="best">5</span> based on
<span class="votes">1</span> rating <span
class="summary"></span></span></span>

> Given two sorted arrays A, B of size *m* and *n* respectively. Find
> the k-th smallest element in the union of A and B. You can assume that
> there are no duplicate elements.

<span id="more-76"></span>  
 Thanks to an [anonymous
reader](http://www.leetcode.com/2011/01/sliding-window-maximum.html?showComment=1296084234466#c2660564749129817681)
who posted this question.

I would have to admit that this problem is pretty tricky to solve. Like
most difficult problems, it requires some pretty clever observations to
solve in a neat way.

**The trivial way, *O*(*m*+*n*):**  
Merge both arrays and the k-th smallest element could be accessed
directly. Merging would require extra space of *O*(*m*+*n*). The linear
run time is pretty good, but could we improve it even further?

**A better way, *O*(*k*):**  
There is an improvement from the above method, thanks to readers who
suggested this. (See comments below by
[Martin](http://www.leetcode.com/2011/01/find-k-th-smallest-element-in-union-of.html?showComment=1296141596487#c7400073356635703229)
for an implementation). Using two pointers, you can traverse both arrays
without actually merging them, thus without the extra space. Both
pointers are initialized to point to head of A and B respectively, and
the pointer that has the <s>larger</s> smaller (thanks to a reader for
this correction) of the two is incremented one step. The k-th smallest
is obtained by traversing a total of *k* steps. This algorithm is very
similar to [finding intersection of two sorted
arrays](http://www.leetcode.com/2010/03/here-is-phone-screening-question-from.html).

**The best solution, but non-trivial, *O*(lg *m* + lg *n*):**  
Although the above solution is an improvement both in run time and space
complexity, it only works well for small values of *k*, and thus is
still in linear run time. Could we improve the run time further?

The above logarithmic complexity gives us one important hint. Binary
search is a great example of achieving logarithmic complexity by halving
its search space in each iteration. Therefore, to achieve the complexity
of *O*(lg *m* + lg *n*), we must halved the search space of A and B in
each iteration.

We try to approach this tricky problem by comparing middle elements of A
and B, which we identify as A<sub>i</sub> and B<sub>j</sub>. If
A<sub>i</sub> is between B<sub>j</sub> and B<sub>j-1</sub>, we have just
found the *i*+*j*+1 smallest element. Why? Therefore, if we choose *i*
and *j* such that *i*+*j* = *k*-1, we are able to find the k-th smallest
element. This is an important invariant that we must maintain for the
correctness of this algorithm.

Summarizing the above,

Maintaining the invariant  
 *i* + *j* = *k* – 1,
If B<sub>j-1</sub> i j, then A<sub>i</sub> must be the k-th smallest,  
or else if A<sub>i-1</sub> j i, then B<sub>j</sub> must be the k-th
smallest.

If one of the above conditions are satisfied, we are done. If not, we
will use *i* and *j* as the pivot index to subdivide the arrays. But
how? Which portion should we discard? How about A<sub>i</sub> and
B<sub>j</sub> itself?

We make an observation that when A<sub>i</sub> j, then it must be true
that A<sub>i</sub> j-1. On the other hand, if B<sub>j</sub> i, then
B<sub>j</sub> i-1. Why?

Using the above relationship, it becomes clear that when A<sub>i</sub>
j, A<sub>i</sub> and its lower portion could never be the k-th smallest
element. So do B<sub>j</sub> and its upper portion. Therefore, we could
conveniently discard A<sub>i</sub> with its lower portion and
B<sub>j</sub> with its upper portion.

If you are still not convince why the above argument is true, try
drawing blocks representing elements in A and B. Try visualize inserting
blocks of A up to A<sub>i</sub> in front of B<sub>j-1</sub>. You could
easily see that no elements in the inserted blocks would ever be the
k-th smallest. For the latter, you might want to keep the invariant
*i* + *j* = *k* – 1 in mind to reason why B<sub>j</sub> and its upper
portion could never be the k-th smallest.

On the other hand, the case for A<sub>i</sub> \> B<sub>j</sub> is just
the other way around. Easy.

Below is the code and I have inserted lots of assertion (highly
recommended programming style by the way) to help you understand the
code. Note that the below code is an example of [tail
recursion](http://en.wikipedia.org/wiki/Tail_recursion), so you could
technically convert it to an iterative method in a straightforward
manner. However, I would leave it as it is, since this is how I derive
the solution and it seemed more natural to be expressed in a recursive
manner.

Another side note is regarding the choices of *i* and *j*. The below
code would subdivide both arrays using its array sizes as weights. The
reason is it might be able to guess the k-th element quicker (as long as
the A and B is not differed in an extreme way; ie, all elements in A are
smaller than B). If you are wondering, yes, you could choose *i* to be
A’s middle. In theory, you could choose any values for *i* and *j* as
long as the invariant *i*+*j* = *k*-1 is satisfied.

int findKthSmallest(int A[], int m, int B[], int n, int k) {
assert(m \>= 0); assert(n \>= 0); assert(k \> 0); assert(k \<= m+n); int
i = (int)((double)m / (m+n) \* (k-1)); int j = (k-1) - i; assert(i \>=
0); assert(j \>= 0); assert(i \<= m); assert(j \<= n); // invariant: i +
j = k-1 // Note: A[-1] = -INF and A[m] = +INF to maintain invariant int
Ai\_1 = ((i == 0) ? INT\_MIN : A[i-1]); int Bj\_1 = ((j == 0) ? INT\_MIN
: B[j-1]); int Ai = ((i == m) ? INT\_MAX : A[i]); int Bj = ((j == n) ?
INT\_MAX : B[j]); if (Bj\_1 \< Ai && Ai \< Bj) return Ai; else if (Ai\_1
\< Bj && Bj \< Ai) return Bj; assert((Ai \> Bj && Ai\_1 \> Bj) || (Ai \<
Bj && Ai \< Bj\_1)); // if none of the cases above, then it is either:
if (Ai \< Bj) // exclude Ai and below portion // exclude Bj and above
portion return findKthSmallest(A+i+1, m-i-1, B, j, k-i-1); else /\* Bj
\< Ai \*/ // exclude Ai and above portion // exclude Bj and below
portion return findKthSmallest(A, i, B+j+1, n-j-1, k-j-1); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">findKthSmallest</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">m</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">B</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">k</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">assert</span><span class="sy">(</span><span class="i">m</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span><span class="h"> </span><span class="st">assert</span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span><span class="h"> </span><span class="st">assert</span><span class="sy">(</span><span class="i">k</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span><span class="h"> </span><span class="st">assert</span><span class="sy">(</span><span class="i">k</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">m</span><span class="o">+</span><span class="i">n</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="sy">)</span><span class="sy">(</span><span class="sy">(</span><span class="t">double</span><span class="sy">)</span><span class="i">m</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="sy">(</span><span class="i">m</span><span class="o">+</span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="o">*</span><span class="h"> </span><span class="sy">(</span><span class="i">k</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="i">k</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">i</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">assert</span><span class="sy">(</span><span class="i">i</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span><span class="h"> </span><span class="st">assert</span><span class="sy">(</span><span class="i">j</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span><span class="h"> </span><span class="st">assert</span><span class="sy">(</span><span class="i">i</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">m</span><span class="sy">)</span><span class="sy">;</span><span class="h"> </span><span class="st">assert</span><span class="sy">(</span><span class="i">j</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="c">// invariant: i + j = k-1</span></p>
<p><span class="h">  </span><span class="c">// Note: A[-1] = -INF and A[m] = +INF to maintain invariant</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">Ai_1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="v">i</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="i">INT_MIN</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">Bj_1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="v">j</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="i">INT_MIN</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="v">B</span><span class="sy">[</span><span class="i">j</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">Ai</span><span class="h">   </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="v">i</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">m</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="i">INT_MAX</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">Bj</span><span class="h">   </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="v">j</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="i">INT_MAX</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="v">B</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="sy">)</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">Bj_1</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">Ai</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">Ai</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">Bj</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="i">Ai</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">Ai_1</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">Bj</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">Bj</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">Ai</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="i">Bj</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">assert</span><span class="sy">(</span><span class="sy">(</span><span class="i">Ai</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">Bj</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">Ai_1</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">Bj</span><span class="sy">)</span><span class="h"> </span><span class="o">||</span><span class="h"> </span></p>
<p><span class="h">         </span><span class="sy">(</span><span class="i">Ai</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">Bj</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">Ai</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">Bj_1</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="c">// if none of the cases above, then it is either:</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">Ai</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">Bj</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="c">// exclude Ai and below portion</span></p>
<p><span class="h">    </span><span class="c">// exclude Bj and above portion</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">findKthSmallest</span><span class="sy">(</span><span class="i">A</span><span class="o">+</span><span class="i">i</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">m</span><span class="o">-</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">B</span><span class="sy">,</span><span class="h"> </span><span class="i">j</span><span class="sy">,</span><span class="h"> </span><span class="i">k</span><span class="o">-</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">else</span><span class="h"> </span><span class="c">/* Bj &lt; Ai */</span></p>
<p><span class="h">    </span><span class="c">// exclude Ai and above portion</span></p>
<p><span class="h">    </span><span class="c">// exclude Bj and below portion</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">findKthSmallest</span><span class="sy">(</span><span class="i">A</span><span class="sy">,</span><span class="h"> </span><span class="i">i</span><span class="sy">,</span><span class="h"> </span><span class="i">B</span><span class="o">+</span><span class="i">j</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="i">j</span><span class="o">-</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">k</span><span class="o">-</span><span class="i">j</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.7/**5** (145 votes cast)

<span class="hreview-aggregate"><span class="item"><span class="fn">Find
the k-th Smallest Element in the Union of Two Sorted
Arrays</span></span>, <span class="rating"><span
class="average">4.7</span> out of <span class="best">5</span> based on
<span class="votes">145</span> ratings <span
class="summary"></span></span></span>

Finding all unique triplets that sums to zero
=============================================

April 12, 2010 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> Given a set S of n integers, are there elements a, b, c in S such that
> a + b + c = 0? Find all unique triplets in the set which gives the sum
> of zero.<span id="more-12"></span>
>
> For example, given set S = {-1 0 1 2 -1 -4},
>
> One possible solution set is:  
> (-1, 0, 1)  
> (-1, 2, -1)
>
> Note that (0, 1, -1) is not part of the solution above, because (0,
> 1, -1) is the duplicate of (-1, 0, 1). Same with (-1, -1, 2).
>
> For a set S, there is probably no “the” solution, another solution
> could be:  
> (0, 1, -1)  
> (2, -1, -1)

**<span>Online Judge</span>**  
 This problem is available at [Online
Judge](http://www.leetcode.com/onlinejudge). [Head over
there](http://www.leetcode.com/onlinejudge) and it will judge your
solution. Currently only able to compile C++/Java code. If you are using
other languages, you can still verify your solution by looking at the
judge’s test cases and its expected output.

This is also known as [the 3sum
problem](http://en.wikipedia.org/wiki/3SUM). The 3sum problem is the
extension of the problem below:

> Given a set S of n integers, find all pairs of integers of a and b in
> S such that a + b = k?

The above problem can be solved in O(n) time, assuming that the set S is
already sorted. By using two index first and last, each pointing to the
first and last element, we look at the element pointed by first, which
we call A. We know that we need to find B = k – A, the complement of A.
If the element pointed by last is less than B, we know that the choice
is to increment pointer first by one step. Similarly, if the element
pointed by last is greater than B, we decrement pointer last by one
step. We are progressively refining the sum step by step. Since each
step we move a pointer one step, there are at most n steps, which gives
the complexity of O(n).

By incorporating the solution above, we can solve the 3sum problem in
O(n^2) time, which is a straight forward extension.

set\<vector\<int\> \> find\_triplets(vector\<int\> arr) {
sort(arr.begin(), arr.end()); set\<vector\<int\> \> triplets;
vector\<int\> triplet(3); int n = arr.size(); for (int i = 0;i \< n;
i++) { int j = i + 1; int k = n - 1; while (j \< k) { int sum\_two =
arr[i] + arr[j]; if (sum\_two + arr[k] \< 0) { j++; } else if
(sum\_two + arr[k] \> 0) { k--; } else { triplet[0] = arr[i]; triplet[1]
= arr[j]; triplet[2] = arr[k]; triplets.insert(triplet); j++; k--; } } }
return triplets; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="i">set</span><span class="o">&lt;</span><span class="i">vector</span><span class="o">&lt;</span><span class="t">int</span><span class="o">&gt;</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="e">find_triplets</span><span class="sy">(</span><span class="i">vector</span><span class="o">&lt;</span><span class="t">int</span><span class="o">&gt;</span><span class="h"> </span><span class="i">arr</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="e">sort</span><span class="sy">(</span><span class="v">arr</span><span class="sy">.</span><span class="e">begin</span><span class="sy">(</span><span class="sy">)</span><span class="sy">,</span><span class="h"> </span><span class="v">arr</span><span class="sy">.</span><span class="st">end</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">set</span><span class="o">&lt;</span><span class="i">vector</span><span class="o">&lt;</span><span class="t">int</span><span class="o">&gt;</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">triplets</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">vector</span><span class="o">&lt;</span><span class="t">int</span><span class="o">&gt;</span><span class="h"> </span><span class="e">triplet</span><span class="sy">(</span><span class="cn">3</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">n</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">arr</span><span class="sy">.</span><span class="e">size</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">k</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">n</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">j</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">k</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="t">int</span><span class="h"> </span><span class="v">sum_two</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">sum_two</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="i">k</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="i">j</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">sum_two</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="i">k</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="i">k</span><span class="o">--</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">triplet</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">triplet</span><span class="sy">[</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">triplet</span><span class="sy">[</span><span class="cn">2</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="i">k</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">triplets</span><span class="sy">.</span><span class="e">insert</span><span class="sy">(</span><span class="i">triplet</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="i">j</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="i">k</span><span class="o">--</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">triplets</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

Note that a set is chosen to store the triplets, because we are only
interested in unique triplets. Since the set S is already sorted, and we
don’t look back as it progresses forward, we can guarantee there will be
no duplicate triplets (Even though the set might have duplicate
elements.)

**Further Thoughts:**  
 Now, a challenge for you. Could you figure out a way to compute your
solution set with only unique triplets without the help of a build-in
data structure (such as set)?

VN:F [1.9.22\_1171]

Rating: 4.3/**5** (22 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Finding all unique triplets that sums to zero</span></span>,
<span class="rating"><span class="average">4.3</span> out of <span
class="best">5</span> based on <span class="votes">22</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/04/finding-all-unique-triplets-that-sums.html>

> Given a set T of characters and a string S, find the minimum window in
> S which will contain all the characters in T in complexity
> *O*(*n*).<span id="more-56"></span>
>
> eg,  
> S = “ADOBECODEBANC”  
> T = “ABC”
>
> Minimum window is “BANC”.

This is an interesting problem and interesting problems have multiple
approaches and the best approach is usually simple and beautiful.

In this post, I illustrate my approach when I first attempt this
problem. My first approach is more complicated and is not the best
solution (runs in O(*N* lg *M*) time). Later in this post, I explain the
best approach which runs in *O*(*N*) time with the help of images.

**Hint:**  
Using the above example **S** = “**ADOBECODEBANC**” and **T** =
“**ABC**“, we can easily find the first window which contains **T** is
“**ADOBEC**“. Another possible candidate is “**ADOBECODEBA**“. In fact,
we should skip this, because within it exists a sub-window “**CODEBA**”
that is both shorter and satisfy the constraint. The final window to
consider is “**BANC**“, which is also the minimum window.

To solve this problem efficiently, below are the two key points we need
to consider:

-   How do we determine if a particular window contains **T**? (ideally
    in *O*(1) time)
-   How do we select all windows efficiently? (ideally do not include
    other windows that wrap about a sub-window)

We definitely need the help from a hash table here. Hash table is able
to tell us if a letter exist in **T** in *O*(1) time.

**An *O*(*N* lg *M*) solution:**  
When I first approach this problem, I thought of having another table
which records the position of last-met character in **T**. That is, when
I first see ‘**A**‘, I record its position being **0**. Each time I see
‘**A**‘ again, I replace its position with the new position. This
approach is simple but flawed. Notice that **T** does not include
duplicate characters? If **T** includes duplicate characters, such as
“**AABC**“, this approach does not work.

In this case, the remedy is to maintain queues (instead of table) that
correspond to each unique character in **T**. For example, assume that
**T** = “**AABC**“, when you first see ‘**A**‘, push its position into
the ‘**A**‘ queue (which originally is empty). When you see ‘**A**‘
again, push its position to the back of ‘**A**‘ queue. The third time
you see ‘**A**‘, you would pop the front element, and push its position
to the back of ‘**A**‘ queue. By popping the element, we do not include
window that wrap around a sub-window. This approach works but the
difficulty is two-fold:

-   There is no way we could determine the starting and ending position
    of a window directly from the queue itself. A naive way is to scan
    the entire queue for minimum and maximum value.
-   How do we determine if the window satisfies the constraint? We would
    have to scan all queues to check if the sum of all queues’ sizes is
    equal to **T**‘s length.

The way I solve the above problem is to maintain a sorted map that maps
indices to character so that we can grab the minimum and maximum
position in *O*(1) time. But there is an extra cost for doing this. Each
time you pop an element from the queue, you would also need to update
the map by deleting the corresponding element and inserting a new
element. To check if the window satisfies the constraint, we check the
map’s size; a valid window is found if the map’s size is equal to
**T’**s length.

The complexity of the method is *O*(*N* lg *M*), where *N* is the length
of **S**, and *M* is the length of **T**. The extra lg *M* term is due
to the extra cost of deleting and inserting an element in the map, where
each costs O(lg *M*) time in the worst case (Note that *M* is the map’s
maximum size. Why?)

// Returns false if no valid window is found. Else returns // true and
updates minWindowBegin and minWindowEnd with the // starting and ending
position of the minimum window. bool findMinWindow(const char \*str,
const char \*pattern, int &minWindowBegin, int &minWindowEnd) { int N =
strlen(str); int M = strlen(pattern); int minWindowLen = INT\_MAX; //
hash table init all to 0s // used to check how many letters left in T to
be filled int needToFill[256] = {0}; for (int i = 0; i \< M; i++)
needToFill[pattern[i]]++; // set the rest to -1 so we know that letter
is not in T for (int i = 0; i \< 256; i++) if (needToFill[i] == 0)
needToFill[i] = -1; // array of queues, each corresponds to a unique
char in T queue\<int\> q[256]; // maintains a sorted map (maps indices
to char), // the first and last element tells us the // starting and
ending position of the window map\<int,char\> m; for (int i = 0; i \< N;
i++) { // skips characters not in T if (needToFill[str[i]] == -1)
continue; // push character to queue if (q[str[i]].size() \<
needToFill[str[i]]) { q[str[i]].push(i); m[i] = str[i]; } // replace the
character in the queue // and updates the corresponding element in the
map else { int idxToErase = q[str[i]].front(); map\<int,char\>::iterator
it = m.find(idxToErase); m.erase(it); m[i] = str[i]; q[str[i]].pop();
q[str[i]].push(i); } // found a window, check for minimum if (m.size()
== M) { int end = m.rbegin()-\>first; int begin = m.begin()-\>first; int
windowLen = end - begin + 1; if (windowLen \< minWindowLen) {
minWindowLen = windowLen; minWindowBegin = begin; minWindowEnd = end; }
} // end if } // end for return (m.size() == M) ? true : false; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
<p>47</p>
<p>48</p>
<p>49</p>
<p>50</p>
<p>51</p>
<p>52</p>
<p>53</p>
<p>54</p>
<p>55</p>
<p>56</p>
<p>57</p>
<p>58</p>
<p>59</p>
<p>60</p>
<p>61</p>
<p>62</p>
<p>63</p>
<p>64</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="c">// Returns false if no valid window is found. Else returns </span></p>
<p><span class="c">// true and updates minWindowBegin and minWindowEnd with the </span></p>
<p><span class="c">// starting and ending position of the minimum window.</span></p>
<p><span class="t">bool</span><span class="h"> </span><span class="e">findMinWindow</span><span class="sy">(</span><span class="m">const</span><span class="h"> </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="i">str</span><span class="sy">,</span><span class="h"> </span><span class="m">const</span><span class="h"> </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="i">pattern</span><span class="sy">,</span><span class="h"> </span></p>
<p><span class="h">                   </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">minWindowBegin</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">minWindowEnd</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">N</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">strlen</span><span class="sy">(</span><span class="i">str</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">M</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">strlen</span><span class="sy">(</span><span class="i">pattern</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">minWindowLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">INT_MAX</span><span class="sy">;</span></p>
<p><span class="h">   </span></p>
<p><span class="h">  </span><span class="c">// hash table init all to 0s</span></p>
<p><span class="h">  </span><span class="c">// used to check how many letters left in T to be filled</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">needToFill</span><span class="sy">[</span><span class="cn">256</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">{</span><span class="cn">0</span><span class="sy">}</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">M</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="v">needToFill</span><span class="sy">[</span><span class="v">pattern</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">]</span><span class="o">++</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="c">// set the rest to -1 so we know that letter is not in T</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="cn">256</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">needToFill</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">needToFill</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="c">// array of queues, each corresponds to a unique char in T</span></p>
<p><span class="h">  </span><span class="i">queue</span><span class="o">&lt;</span><span class="t">int</span><span class="o">&gt;</span><span class="h"> </span><span class="v">q</span><span class="sy">[</span><span class="cn">256</span><span class="sy">]</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="c">// maintains a sorted map (maps indices to char), </span></p>
<p><span class="h">  </span><span class="c">// the first and last element tells us the </span></p>
<p><span class="h">  </span><span class="c">// starting and ending position of the window</span></p>
<p><span class="h">  </span><span class="i">map</span><span class="o">&lt;</span><span class="t">int</span><span class="sy">,</span><span class="t">char</span><span class="o">&gt;</span><span class="h"> </span><span class="i">m</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">N</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="c">// skips characters not in T</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">needToFill</span><span class="sy">[</span><span class="v">str</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="st">continue</span><span class="sy">;</span></p>
<p><span class="h">    </span></p>
<p><span class="h">    </span><span class="c">// push character to queue</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">q</span><span class="sy">[</span><span class="v">str</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">]</span><span class="sy">.</span><span class="e">size</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="v">needToFill</span><span class="sy">[</span><span class="v">str</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">q</span><span class="sy">[</span><span class="v">str</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">]</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">i</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">m</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">str</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="c">// replace the character in the queue </span></p>
<p><span class="h">    </span><span class="c">// and updates the corresponding element in the map</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="t">int</span><span class="h"> </span><span class="v">idxToErase</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">q</span><span class="sy">[</span><span class="v">str</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">]</span><span class="sy">.</span><span class="e">front</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="i">map</span><span class="o">&lt;</span><span class="t">int</span><span class="sy">,</span><span class="t">char</span><span class="o">&gt;</span><span class="o">::</span><span class="e">iterator </span><span class="v">it</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">m</span><span class="sy">.</span><span class="e">find</span><span class="sy">(</span><span class="i">idxToErase</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">m</span><span class="sy">.</span><span class="e">erase</span><span class="sy">(</span><span class="i">it</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">m</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">str</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">q</span><span class="sy">[</span><span class="v">str</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">]</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">q</span><span class="sy">[</span><span class="v">str</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">]</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">i</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p> </p>
<p><span class="h">    </span><span class="c">// found a window, check for minimum</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">m</span><span class="sy">.</span><span class="e">size</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">M</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="t">int</span><span class="h"> </span><span class="st">end</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">m</span><span class="sy">.</span><span class="e">rbegin</span><span class="sy">(</span><span class="sy">)</span><span class="o">-&gt;</span><span class="i">first</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="t">int</span><span class="h"> </span><span class="v">begin</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">m</span><span class="sy">.</span><span class="e">begin</span><span class="sy">(</span><span class="sy">)</span><span class="o">-&gt;</span><span class="i">first</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="t">int</span><span class="h"> </span><span class="v">windowLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="st">end</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">begin</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">windowLen</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">minWindowLen</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">minWindowLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">windowLen</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">minWindowBegin</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">begin</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">minWindowEnd</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="st">end</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="c">// end if</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h"> </span><span class="c">// end for</span></p>
<p><span class="h">   </span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="v">m</span><span class="sy">.</span><span class="e">size</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">M</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="t">true</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Best solution:**  
The best solution, is in fact simpler. This best approach is suggested
by someone who called <span> stormrage </span>.

Notice how complicated the above solution is. It uses a hash table, a
queue, and a sorted map. During an interview, the problems tend to be
short and the solution usually can be coded in about 50 lines of code.
So be sure that you say out loud what you are thinking and keep
communication opened with the interviewer. Check if your approach is
unnecessary complex, he/she might be able to give you guidance. The last
thing you want to do is to get stuck in a corner and keep silent.

To help illustrate this approach, I use a different example: **S** =
“**acbbaca**” and **T** = “**aba**“. The idea is mainly based on the
help of two pointers (begin and end position of the window) and two
tables (*needToFind* and *hasFound*) while traversing **S**.
*needToFind* stores the total count of a character in **T** and
*hasFound* stores the total count of a character met so far. We also use
a *count* variable to store the total characters in **T** that’s met so
far (not counting characters where hasFound[*x*] ** exceeds
needToFind[*x*]). When count equals **T**‘s length, we know a valid
window is found.

Each time we advance the end pointer (pointing to an element *x*), we
increment hasFound[*x*] by one. We also increment *count* by one if
hasFound[*x*] is less than or equal to needToFind[*x*]. Why? When the
constraint is met (that is, *count* equals to **T**‘s size), we
immediately advance begin pointer as far right as possible while
maintaining the constraint.

How do we check if it is maintaining the constraint? Assume that begin
points to an element *x*, we check if hasFound[*x*] is greater than
needToFind[*x*]. If it is, we can decrement hasFound[*x*] by one and
advancing begin pointer without breaking the constraint. On the other
hand, if it is not, we stop immediately as advancing begin pointer
breaks the window constraint.

Finally, we check if the minimum window length is less than the current
minimum. Update the current minimum if a new minimum is found.

Essentially, the algorithm finds the first window that satisfies the
constraint, then continue maintaining the constraint throughout.

[![](http://2.bp.blogspot.com/_UElib2WLeDE/TOBuvjG6exI/AAAAAAAACYE/uludVXtJ8OY/s400/sliding.gif)](http://2.bp.blogspot.com/_UElib2WLeDE/TOBuvjG6exI/AAAAAAAACYE/uludVXtJ8OY/s1600/sliding.gif)

<span>i) **S** = “**acbbaca**” and **T** = “**aba**“.  
</span>

[![](http://4.bp.blogspot.com/_UElib2WLeDE/TOBvHRLbOAI/AAAAAAAACYI/38QLgUIMePU/s400/sliding_2.gif)](http://4.bp.blogspot.com/_UElib2WLeDE/TOBvHRLbOAI/AAAAAAAACYI/38QLgUIMePU/s1600/sliding_2.gif)

<span>ii) The first minimum window is found. Notice that we cannot
advance begin pointer as hasFound['a'] == needToFind['a'] == 2.
Advancing would mean breaking the constraint.  
</span>

[![](http://3.bp.blogspot.com/_UElib2WLeDE/TOBvLH1aLcI/AAAAAAAACYM/pbJLl7qoduo/s400/sliding_3.gif)](http://3.bp.blogspot.com/_UElib2WLeDE/TOBvLH1aLcI/AAAAAAAACYM/pbJLl7qoduo/s1600/sliding_3.gif)

<span>iii) The second window is found. begin pointer still points to the
first element ‘a’. hasFound['a'] (**3**) is greater than needToFind['a']
(**2**). We decrement hasFound['a'] by one and advance begin pointer to
the right.  
</span>

[![](http://2.bp.blogspot.com/_UElib2WLeDE/TOBvOljpz0I/AAAAAAAACYQ/TxuWgWGTOF4/s400/sliding_4.gif)](http://2.bp.blogspot.com/_UElib2WLeDE/TOBvOljpz0I/AAAAAAAACYQ/TxuWgWGTOF4/s1600/sliding_4.gif)

<span>iv) We skip ‘c’ since it is not found in **T**. Begin pointer now
points to ‘b’. hasFound['b'] (**2**) is greater than needToFind['b']
(**1**). We decrement hasFound['b'] by one and advance begin pointer to
the right.  
</span>

[![](http://2.bp.blogspot.com/_UElib2WLeDE/TOBvSOl6RdI/AAAAAAAACYU/R4O1dPXVvBQ/s400/sliding_5.gif)](http://2.bp.blogspot.com/_UElib2WLeDE/TOBvSOl6RdI/AAAAAAAACYU/R4O1dPXVvBQ/s1600/sliding_5.gif)

<span>v) Begin pointer now points to the next ‘b’. hasFound['b'] (1) is
equal to needToFind['b'] (1). We stop immediately and this is our newly
found minimum window.  
</span>

Both the begin and end pointers can advance at most *N* steps (where *N*
is **S**‘s size) in the worst case, adding to a total of 2*N* times.
Therefore, the run time complexity must be in *O*(*N*).

// Returns false if no valid window is found. Else returns // true and
updates minWindowBegin and minWindowEnd with the // starting and ending
position of the minimum window. bool minWindow(const char\* S, const
char \*T, int &minWindowBegin, int &minWindowEnd) { int sLen =
strlen(S); int tLen = strlen(T); int needToFind[256] = {0}; for (int i =
0; i \< tLen; i++) needToFind[T[i]]++; int hasFound[256] = {0}; int
minWindowLen = INT\_MAX; int count = 0; for (int begin = 0, end = 0; end
\< sLen; end++) { // skip characters not in T if (needToFind[S[end]] ==
0) continue; hasFound[S[end]]++; if (hasFound[S[end]] \<=
needToFind[S[end]]) count++; // if window constraint is satisfied if
(count == tLen) { // advance begin index as far right as possible, //
stop when advancing breaks window constraint. while
(needToFind[S[begin]] == 0 || hasFound[S[begin]] \>
needToFind[S[begin]]) { if (hasFound[S[begin]] \> needToFind[S[begin]])
hasFound[S[begin]]--; begin++; } // update minWindow if a minimum length
is met int windowLen = end - begin + 1; if (windowLen \< minWindowLen) {
minWindowBegin = begin; minWindowEnd = end; minWindowLen = windowLen; }
// end if } // end if } // end for return (count == tLen) ? true :
false; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="c">// Returns false if no valid window is found. Else returns </span></p>
<p><span class="c">// true and updates minWindowBegin and minWindowEnd with the </span></p>
<p><span class="c">// starting and ending position of the minimum window.</span></p>
<p><span class="t">bool</span><span class="h"> </span><span class="e">minWindow</span><span class="sy">(</span><span class="m">const</span><span class="h"> </span><span class="t">char</span><span class="o">*</span><span class="h"> </span><span class="i">S</span><span class="sy">,</span><span class="h"> </span><span class="m">const</span><span class="h"> </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="i">T</span><span class="sy">,</span><span class="h"> </span></p>
<p><span class="h">               </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">minWindowBegin</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">minWindowEnd</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">sLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">strlen</span><span class="sy">(</span><span class="i">S</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">tLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">strlen</span><span class="sy">(</span><span class="i">T</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">needToFind</span><span class="sy">[</span><span class="cn">256</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">{</span><span class="cn">0</span><span class="sy">}</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">tLen</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="v">needToFind</span><span class="sy">[</span><span class="v">T</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">]</span><span class="o">++</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">hasFound</span><span class="sy">[</span><span class="cn">256</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">{</span><span class="cn">0</span><span class="sy">}</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">minWindowLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">INT_MAX</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">count</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">begin</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="st">end</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="st">end</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">sLen</span><span class="sy">;</span><span class="h"> </span><span class="st">end</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="c">// skip characters not in T</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">needToFind</span><span class="sy">[</span><span class="v">S</span><span class="sy">[</span><span class="st">end</span><span class="sy">]</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="st">continue</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">hasFound</span><span class="sy">[</span><span class="v">S</span><span class="sy">[</span><span class="st">end</span><span class="sy">]</span><span class="sy">]</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">hasFound</span><span class="sy">[</span><span class="v">S</span><span class="sy">[</span><span class="st">end</span><span class="sy">]</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="v">needToFind</span><span class="sy">[</span><span class="v">S</span><span class="sy">[</span><span class="st">end</span><span class="sy">]</span><span class="sy">]</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="i">count</span><span class="o">++</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">    </span><span class="c">// if window constraint is satisfied</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">count</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">tLen</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="c">// advance begin index as far right as possible,</span></p>
<p><span class="h">      </span><span class="c">// stop when advancing breaks window constraint.</span></p>
<p><span class="h">      </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="v">needToFind</span><span class="sy">[</span><span class="v">S</span><span class="sy">[</span><span class="i">begin</span><span class="sy">]</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="h"> </span><span class="o">||</span></p>
<p><span class="h">            </span><span class="v">hasFound</span><span class="sy">[</span><span class="v">S</span><span class="sy">[</span><span class="i">begin</span><span class="sy">]</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="v">needToFind</span><span class="sy">[</span><span class="v">S</span><span class="sy">[</span><span class="i">begin</span><span class="sy">]</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">hasFound</span><span class="sy">[</span><span class="v">S</span><span class="sy">[</span><span class="i">begin</span><span class="sy">]</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="v">needToFind</span><span class="sy">[</span><span class="v">S</span><span class="sy">[</span><span class="i">begin</span><span class="sy">]</span><span class="sy">]</span><span class="sy">)</span></p>
<p><span class="h">          </span><span class="v">hasFound</span><span class="sy">[</span><span class="v">S</span><span class="sy">[</span><span class="i">begin</span><span class="sy">]</span><span class="sy">]</span><span class="o">--</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="i">begin</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span></p>
<p> </p>
<p><span class="h">      </span><span class="c">// update minWindow if a minimum length is met</span></p>
<p><span class="h">      </span><span class="t">int</span><span class="h"> </span><span class="v">windowLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="st">end</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">begin</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">windowLen</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">minWindowLen</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">minWindowBegin</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">begin</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">minWindowEnd</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="st">end</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">minWindowLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">windowLen</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span><span class="h"> </span><span class="c">// end if</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="c">// end if</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h"> </span><span class="c">// end for</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="v">count</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">tLen</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="t">true</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Test Cases:**  
» [<span>Download sample test cases with
answers</span>](https://sites.google.com/site/ihas1337code/minwindow.txt)

VN:F [1.9.22\_1171]

Rating: 4.8/**5** (70 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Finding the Minimum Window in S which Contains All Elements
from T</span></span>, <span class="rating"><span
class="average">4.8</span> out of <span class="best">5</span> based on
<span class="votes">70</span> ratings <span
class="summary"></span></span></span>

Finding prime numbers
=====================

April 23, 2010 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> Output all prime numbers up to a specified integer n.

<span id="more-20"></span>

This is a phone screen question from one of my interviews. An efficient
way to generate prime numbers is using [Sieve of
Eratosthenes](http://en.wikipedia.org/wiki/Sieve_of_eratosthenes). We
store the primes in a table of true false values, so we are able to
determine if a number is a prime number efficiently using this table.

Below is one possible implementation, you can read more in-depth
analysis about generating prime numbers in [Programming
Pearls](http://www.cs.bell-labs.com/cm/cs/pearls/).

/\* Generate a prime list from 0 up to n, using The Sieve of
Erantosthenes param n The upper bound of the prime list (including n)
param prime[] An array of truth value whether a number is prime \*/ void
prime\_sieve(int n, bool prime[]) { prime[0] = false; prime[1] = false;
int i; for (i = 2; i \<= n; i++) prime[i] = true; int limit = sqrt(n);
for (i = 2; i \<= limit; i++) { if (prime[i]) { for (int j = i \* i; j
\<= n; j += i) prime[j] = false; } } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="c">/* Generate a prime list from 0 up to n, using The Sieve of Erantosthenes</span></p>
<p><span class="c">param n The upper bound of the prime list (including n)</span></p>
<p><span class="c">param prime[] An array of truth value whether a number is prime</span></p>
<p><span class="c">*/</span></p>
<p><span class="t">void</span><span class="h"> </span><span class="e">prime_sieve</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="t">bool</span><span class="h"> </span><span class="v">prime</span><span class="sy">[</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="v">prime</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">prime</span><span class="sy">[</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="i">i</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">2</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="v">prime</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">limit</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">sqrt</span><span class="sy">(</span><span class="i">n</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">2</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">limit</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">prime</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">i *</span><span class="h"> </span><span class="i">i</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">+</span><span class="o">=</span><span class="h"> </span><span class="i">i</span><span class="sy">)</span></p>
<p><span class="h">        </span><span class="v">prime</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.7/**5** (16 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Finding prime numbers</span></span>, <span
class="rating"><span class="average">4.7</span> out of <span
class="best">5</span> based on <span class="votes">16</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/04/finding-prime-numbers.html>

### Leave a reply

> Given a binary tree
>
> struct Node { Node\* leftChild; Node\* rightChild; Node\* nextRight; }
> <table>
> <colgroup>
> <col width="50%" />
> <col width="50%" />
> </colgroup>
> <tbody>
> <tr class="odd">
> <td align="left"></td>
> <td align="left"><div class="crayon-pre">
> <p><span class="t">struct</span><span class="h"> </span><span class="e">Node</span><span class="h"> </span><span class="sy">{</span></p>
> <p><span class="h">  </span><span class="e">Node*</span><span class="h"> </span><span class="i">leftChild</span><span class="sy">;</span></p>
> <p><span class="h">  </span><span class="e">Node*</span><span class="h"> </span><span class="i">rightChild</span><span class="sy">;</span></p>
> <p><span class="h">  </span><span class="e">Node*</span><span class="h"> </span><span class="i">nextRight</span><span class="sy">;</span></p>
> <p><span class="sy">}</span></p>
> </div></td>
> </tr>
> </tbody>
> </table>
>
> Populate the nextRight pointers in each node.
>
> <span id="more-8"></span>You may assume that it is a full binary tree
> (ie, each node other than the leaves has two children.)

The solution is not immediately obvious to me at first. However, with
some help of diagrams, there are some observations can be made.

1.  Most likely this can be implemented recursively, because you can
    identify the linking of nodes as sub-problems.
2.  The main difficulty of this problem is linking rightChild with the
    nextSibling of rightChild.
3.  Each node has no parent pointer. Therefore, there is no way linking
    the rightChild with its nextSibling at a level.

My first thought is to use Breadth-First Search (BFS). After all, we are
connecting the nextRight node level-by-level, it is only natural to
apply BFS to this problem. I mentioned this approach to the interviewer,
but he was not too satisfied with it.

BFS requires memory space to store Nodes into a queue. Can we do better
without extra space?

To do that, we need to first solve the 3 problems mentioned above. We
know this problem requires a recursive solution, and most people will
start with something like: “Connect the current node to its sibling,
then pass the leftChild to itself, and then the rightChild to itself.
Stop recursion when node is NULL.” This will not work. You are only
connecting the leftChild with the rightChild. How about the rightChild?
The next pointer of rightChild still do not point to anywhere!
<span>(EDIT: This method will work with one small modification, see
below)</span>

The first key to solving this problem is we have the nextRight pointer.
Assume that the nextRight pointers are already populated for this level.
How can we populate the next level? Easy… just populate by iterating all
nodes on this level. Another key to this problem is you have to populate
the next level before you go down to the next level, because once you go
down, you have no parent pointer, and you would have hard time
populating, as I mentioned in the observation I made earlier.

With the problem sorted out, we can implement this in code in a pretty
straight-forward manner. (But beware of checking for NULL de-referencing
pointers!)

void connect(Node\* p) { if (p == NULL) return; if (p-\>leftChild ==
NULL || p-\>rightChild == NULL) return; Node\* rightSibling; Node\* p1 =
p; while (p1) { if (p1-\>nextRight) rightSibling =
p1-\>nextRight-\>leftChild; else rightSibling = NULL;
p1-\>leftChild-\>nextRight = p1-\>rightChild;
p1-\>rightChild-\>nextRight = rightSibling; p1 = p1-\>nextRight; }
connect(p-\>leftChild); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">connect</span><span class="sy">(</span><span class="e">Node*</span><span class="h"> </span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">p</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="t">NULL</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="v">leftChild</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="t">NULL</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="v">rightChild</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="t">NULL</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Node*</span><span class="h"> </span><span class="i">rightSibling</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Node*</span><span class="h"> </span><span class="v">p1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">p1</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">p1</span><span class="o">-&gt;</span><span class="i">nextRight</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">rightSibling</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p1</span><span class="o">-&gt;</span><span class="i">nextRight</span><span class="o">-&gt;</span><span class="i">leftChild</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">else</span></p>
<p><span class="h">      </span><span class="v">rightSibling</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">p1</span><span class="o">-&gt;</span><span class="i">leftChild</span><span class="o">-&gt;</span><span class="v">nextRight</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p1</span><span class="o">-&gt;</span><span class="i">rightChild</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">p1</span><span class="o">-&gt;</span><span class="i">rightChild</span><span class="o">-&gt;</span><span class="v">nextRight</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">rightSibling</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">p1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p1</span><span class="o">-&gt;</span><span class="i">nextRight</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="e">connect</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">leftChild</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

<span>EDIT: (Added alternative solution)</span>  
Here is a more elegant solution. The trick is to re-use the populated
nextRight pointers. As mentioned earlier, we just need one more step for
it to work. Before we passed the leftChild and rightChild to the
recursion function itself, we connect the rightChild’s nextRight to the
current node’s nextRight’s leftChild. In order for this to work, the
current node’s nextRight pointer must be populated, which is true in
this case. Why? Try to draw a series of diagram how the recursion
deepens, you will immediately see that it is doing DFS (Depth first
search).

void connect(Node\* p) { if (!p) return; if (p-\>leftChild)
p-\>leftChild-\>nextRight = p-\>rightChild; if (p-\>rightChild)
p-\>rightChild-\>nextRight = (p-\>nextRight) ? p-\>nextRight-\>leftChild
: NULL; connect(p-\>leftChild); connect(p-\>rightChild); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">connect</span><span class="sy">(</span><span class="e">Node*</span><span class="h"> </span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">leftChild</span><span class="sy">)</span></p>
<p><span class="h">  </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">leftChild</span><span class="o">-&gt;</span><span class="v">nextRight</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">rightChild</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">rightChild</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">rightChild</span><span class="o">-&gt;</span><span class="v">nextRight</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">nextRight</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span></p>
<p><span class="h">                               </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">nextRight</span><span class="o">-&gt;</span><span class="i">leftChild</span><span class="h"> </span><span class="o">:</span></p>
<p><span class="h">                               </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">connect</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">leftChild</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">connect</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">rightChild</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.6/**5** (32 votes cast)

<span class="hreview-aggregate"><span class="item"><span class="fn">A
binary tree problem - Populating next right pointers in each
node</span></span>, <span class="rating"><span
class="average">4.6</span> out of <span class="best">5</span> based on
<span class="votes">32</span> ratings <span
class="summary"></span></span></span>

Fun with Bit Operations
=======================

September 8, 2010 <span>in [bit
operations](http://leetcode.com/category/bit-operations "View all posts in bit operations")</span>
<span class="post-utility alignright"></span>

> What does the following function mystery() do?

bool mystery(unsigned int x) { return !(x & (x-1)); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">bool</span><span class="h"> </span><span class="e">mystery</span><span class="sy">(</span><span class="t">unsigned</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">x</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="o">!</span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="sy">(</span><span class="i">x</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

<span id="more-29"></span>Interviewer loves to ask bit operations
questions, because it can be tricky and highly deceptive.

Here is the hint: Assume the bits of <span>x</span> is
<span>“101000″</span>, then <span>x-1</span> is <span>“100111″</span>.
The transformation from <span>x » x-1</span> is easy, the rightmost bit
that is ’1′ will be changed to ’0′, and all the ’0′ bits to the right
will be changed to ’1′. Therefore, when you do an & operation between
them, the rightmost ’1′ bit will turn to ’0′.

An integer that is a power of two has exactly one bit that is ’1′.
Therefore, this function returns whether an integer is a power of two.

The fun does not stop here. Look out for my next post to discover more
fun with bit operations!

<span>EDIT: (A small bug fix)</span>  
Sharp readers might find that passing 0 into the function returns true
(while 0 is not a power of two). In order to remedy this, use:

return x && !(x & (x-1));
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="st">return</span><span class="h"> </span><span class="i">x</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="o">!</span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="sy">(</span><span class="i">x</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
</div></td>
</tr>
</tbody>
</table>

If you are able to point this out during the interview, I’m sure the
interviewer will be very impressed.

VN:F [1.9.22\_1171]

Rating: 4.5/**5** (11 votes cast)

<span class="hreview-aggregate"><span class="item"><span class="fn">Fun
with Bit Operations</span></span>, <span class="rating"><span
class="average">4.5</span> out of <span class="best">5</span> based on
<span class="votes">11</span> ratings <span
class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/09/fun-with-bit-operations.html>

### Leave a reply

### 2 trackbacks

-   *on October 21, 2012*
-   *on October 8, 2014*

> Google Code Jam has begun and there is still time to compete, so
> register and start coding now if you have not!
>
> » [Participate in Google Code Jam
> Now!](http://code.google.com/codejam)

<span id="more-24"></span>

For now, I would like to give some overview on the qualification round.

<span>Problem A: Snapper Chain</span> is solved by most people
(<span>3597</span> people so far), with the number of correct being
<span>79%</span> so far. <span>Problem B: Fair Warning</span> is the
most difficult, being solved by only <span>847</span> people so far,
correct rate being <span>76%</span>. <span>Problem C: Theme Park</span>
is solved by a total of <span>2370</span> people so far, with correct
rate being <span>92%</span>.

I would say Problem C is the easiest problem among the three, but only
for the small input. The large input is quite tricky and you have to be
careful of some traps. (Hint: Do your big(O) analysis before you attempt
the large input!). I predict that Problem C: large input is gonna have
the lowest correct rate among all.

Although Problem A is the most solved problem, it is a bit tricky as
well, as you can see from the correct rate being only <span>79%</span>
(Compared to Problem C: small input – <span>92%</span>). The problem
description is also unnecessary complicated. This problem is easy after
you discovered the pattern. Then generalizing it is straight forward
from there.

Problem B is the hardest among all. So far I am still stucked on this
problem. First of all, the question does take some time to digest. It
seems like a Math problem to me, but so far I do not have any idea how
to approach this problem. The large input for this problem contains
integer up to <span>10^50</span>, which is quite intimidating.

I would update this blog with tips and solutions to the problems once
the qualification round has ended, so stay tune!

**Update:**  
Qualification round has just ended! I hope everybody has a great time
solving the problems!

If you scored at least **33** points, congratulations because you are
qualified to the next round! The next round starts on **May 22**, and
you’ve got 3 chances to qualify (called **Round1A**, **1B** and **1C**).
Each round is limited to 2 and a half hours and your rank need to be
within the top **1000** in order to qualify for **Round 2**.

Google is also nice to provide a detailed [contest
analysis](http://code.google.com/codejam/contest/dashboard?c=433101#s=a),
and solutions for each problems. According to them, this year’s
questions are tougher than usual. **Problem B: Fair Warning** is indeed
the toughest question. Besides, it is the first question in Code Jam
that uses Big Integer, so be prepared for a good Big Integer library
(some language provides it) in the future!

As predicted, **Problem C**: large input has the lowest correct rate of
all (only **40%** of the attempts passed the large input). This is why
complexity analysis is very important in this situation.

VN:F [1.9.22\_1171]

Rating: 0.0/**5** (0 votes cast)

Hacking a Google interview (From MIT)
=====================================

April 14, 2010 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

Google interview is so popular that even MIT dedicates a course to it!

» [Hacking a Google Interview Course
Website](http://courses.csail.mit.edu/iap/interview/materials.php)<span
id="more-15"></span>

Directly from MIT’s course website,  

> Learn the tricks. Beat the system.
>
> Ever wanted to work at a company like Google, Apple, or Facebook?
> There’s just one thing standing in your way: the interview. But
> there’s no need to fear. We’ve mastered the interview questions and
> topics, and we want to show you how you can nail every programming
> question. Whether you’re a beginning programmer or a seasoned expert,
> this class is for you.

There are a total 5 handouts available for download, with the first few
handouts discussing basic data structures and common interview questions
with complete solutions. 5 stars and highly recommended!

Below are direct links for the handouts:  
» [Handout
1](http://courses.csail.mit.edu/iap/interview/Hacking_a_Google_Interview_Handout_1.pdf)  
» [Handout
2](http://courses.csail.mit.edu/iap/interview/Hacking_a_Google_Interview_Handout_2.pdf)  
» [Handout
3](http://courses.csail.mit.edu/iap/interview/Hacking_a_Google_Interview_Handout_3.pdf)  
» [Common Questions Part
1](http://courses.csail.mit.edu/iap/interview/Hacking_a_Google_Interview_Practice_Questions_Person_A.pdf)  
» [Common Questions Part
2](http://courses.csail.mit.edu/iap/interview/Hacking_a_Google_Interview_Practice_Questions_Person_B.pdf)

**Additional Resources:**  
 TopCoder is a very good resource to get started in solving programming
problems.

» [How to find a
solution](http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=findSolution)  
» [Dynamic Programming: From novice to
advanced](http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=dynProg)  
» [More algorithm tutorials at
TopCoder](http://www.topcoder.com/tc?d1=tutorials&d2=alg_index&module=Static)

VN:F [1.9.22\_1171]

Rating: 4.5/**5** (31 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Hacking a Google interview (From MIT)</span></span>, <span
class="rating"><span class="average">4.5</span> out of <span
class="best">5</span> based on <span class="votes">31</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/04/hacking-google-interview-from-mit.html>

String Reorder Distance Apart
=============================

May 1, 2010 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> Given a string of lowercase characters, reorder them such that the
> same characters are at least distance <span>d</span> from each
> other.<span id="more-22"></span>
>
> Input: { a, b, b }, distance = 2  
> Output: { b, a, b }

I think it’s quite an interesting question. So if you want to do some
brainstorming and do not wish to spoil the fun, please feel free to do
so and beware of the spoilers ahead.

<span>\*\*\* Spoilers alert! \*\*\*</span>  
<span>\*\*\* Spoilers alert! \*\*\*</span>  
<span>\*\*\* Spoilers alert! \*\*\*</span>  
The solution below involves a greedy strategy, that is: The character
that has the most duplicates has the highest priority of being chosen to
put in the new list. If that character cannot be chosen (due to the
distance constraint), we go for the character that has the next highest
priority. We also use some tables to improve the efficiency. (i.e.,
keeping track of \# of duplicates of each character.)

int find\_max(int freq[], bool excep[]) { int max\_i = -1; int max = -1;
for (char c = 'a'; c \<= 'z'; c++) { if (!excep[c] && freq[c] \> 0 &&
freq[c] \> max) { max = freq[c]; max\_i = c; } } return max\_i; } void
create(char\* str, int d, char ans[]) { int n = strlen(str); int
freq[256] = {0}; for (int i = 0; i \< n; i++) freq[str[i]]++; int
used[256] = {0}; for (int i = 0; i \< n; i++) { bool excep[256] =
{false}; bool done = false; while (!done) { int j = find\_max(freq,
excep); if (j == -1) { cout \<\< "Error!\\n"; return; } excep[j] = true;
if (used[j] \<= 0) { ans[i] = j; freq[j]--; used[j] = d; done = true; }
} for (int i = 0; i \< 256; i++) used[i]--; } ans[n] = '\\0'; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">find_max</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">freq</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">bool</span><span class="h"> </span><span class="v">excep</span><span class="sy">[</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">max_i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">max</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">char</span><span class="h"> </span><span class="v">c</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="s">'a'</span><span class="sy">;</span><span class="h"> </span><span class="i">c</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="s">'z'</span><span class="sy">;</span><span class="h"> </span><span class="i">c</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">excep</span><span class="sy">[</span><span class="i">c</span><span class="sy">]</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">freq</span><span class="sy">[</span><span class="i">c</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="cn">0</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">freq</span><span class="sy">[</span><span class="i">c</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">max</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">max</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">freq</span><span class="sy">[</span><span class="i">c</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">max_i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">c</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">max_i</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">void</span><span class="h"> </span><span class="e">create</span><span class="sy">(</span><span class="t">char</span><span class="o">*</span><span class="h"> </span><span class="i">str</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">d</span><span class="sy">,</span><span class="h"> </span><span class="t">char</span><span class="h"> </span><span class="v">ans</span><span class="sy">[</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">n</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">strlen</span><span class="sy">(</span><span class="i">str</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">freq</span><span class="sy">[</span><span class="cn">256</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">{</span><span class="cn">0</span><span class="sy">}</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">  </span><span class="v">freq</span><span class="sy">[</span><span class="v">str</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">]</span><span class="o">++</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">used</span><span class="sy">[</span><span class="cn">256</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">{</span><span class="cn">0</span><span class="sy">}</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">bool</span><span class="h"> </span><span class="v">excep</span><span class="sy">[</span><span class="cn">256</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">{</span><span class="t">false</span><span class="sy">}</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">bool</span><span class="h"> </span><span class="v">done</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">done</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">find_max</span><span class="sy">(</span><span class="i">freq</span><span class="sy">,</span><span class="h"> </span><span class="i">excep</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">j</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;Error!\n&quot;</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="v">excep</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">used</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">ans</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">j</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">freq</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="o">--</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">used</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">d</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">done</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="cn">256</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="v">used</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="o">--</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="v">ans</span><span class="sy">[</span><span class="i">n</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="s">'\0'</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 2.5/**5** (22 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">String Reorder Distance Apart</span></span>, <span
class="rating"><span class="average">2.5</span> out of <span
class="best">5</span> based on <span class="votes">22</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/05/here-is-another-google-phone-interview.html>

> Given only putchar (no sprintf, itoa, etc.) write a routine putlong
> that prints out an unsigned long in decimal.

<span id="more-7"></span>

Here is one of the questions from Microsoft interview.

It’s obvious that you can use the modulus operator (%10) and loop thru
the digits one-by-one. Since n%10 gives you only the last digit, you
need to somehow store it in a temporary array. I am sure the interviewer
will not be too pleased with this and ask you to rethink again without
using temporary storage.

The key is to think recursively. Recursion is very powerful and is able
to solve this question easily. In fact, it is often used in conjunction
with pointers to weed out candidates. Read [this article on how
Microsoft conduct
interviews](http://www.joelonsoftware.com/articles/GuerrillaInterviewing3.html)
to get what I mean. Think of recursion as the allocation of a stack…
Push the last digit onto the stack, then continue with the 2nd last, …,
up until the first digit. Then when the function pops off the stack, you
get the digit in the correct order. Voila!

You will probably attempt something like this at first try:

void putlong(unsigned long n) { if (n == 0) return; putlong(n / 10);
putchar(n % 10 + '0'); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">putlong</span><span class="sy">(</span><span class="t">unsigned</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">n</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">putlong</span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">10</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">putchar</span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">%</span><span class="h"> </span><span class="cn">10</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="s">'0'</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

Guess what’s wrong?

You forgot to consider the special case when n == 0!

The above code can be modified to handle the special case of n == 0:

void putlong(unsigned long n) { if (n \< 10) { putchar(n + '0'); return;
} putlong(n / 10); putchar(n % 10 + '0'); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">putlong</span><span class="sy">(</span><span class="t">unsigned</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="cn">10</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="e">putchar</span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="s">'0'</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="e">putlong</span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">10</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">putchar</span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">%</span><span class="h"> </span><span class="cn">10</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="s">'0'</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

Great! Now you are able to think recursively
![:)](http://leetcode.com/wp-includes/images/smilies/icon_smile.gif)
Here is another similar question that often pops up in a job interview:

> Print a string in reverse order.

void printReverse(const char \*str) { if (!\*str) return;
printReverse(str + 1); putchar(\*str); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">printReverse</span><span class="sy">(</span><span class="m">const</span><span class="h"> </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="i">str</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="o">*</span><span class="i">str</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">printReverse</span><span class="sy">(</span><span class="i">str</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">putchar</span><span class="sy">(</span><span class="o">*</span><span class="i">str</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

Reversing linked-list can be done recursively too. Can you figure out
how to do it? Find out how in my next post.

VN:F [1.9.22\_1171]

Rating: 5.0/**5** (10 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Recursion to the rescue!</span></span>, <span
class="rating"><span class="average">5.0</span> out of <span
class="best">5</span> based on <span class="votes">10</span> ratings
<span class="summary"></span></span></span>

> Find the intersection of two sorted arrays.

<span id="more-9"></span>

Let’s called array1 as A and array2 as B, each with size m and n.

The obvious brute-force solution is to scan through each element in A,
and for each element in A, scan if that element exist in B. The running
time complexity is O(m\*n). Not good! Can we do better? Absolutely!

First, we know that both arrays are sorted. Can we somehow use this
information to our advantage?

We can apply binary search to search if an element of A exist in B. So,
the only modification from the brute-force approach is modifying linear
search to binary search. This seems like a good improvement, we manage
to reduce the complexity to O(m\*lg(n)).

Of course, you know you can trade space for running time by using a hash
table. Is it really useful? We can definitely hash each element in B to
an array index (takes O(n) time). Therefore, to find if an element of A
exist in B, it would require just O(1) time. The complexity improves to
O(m+n).

But there is a problem, what if n is very big? (ie, n is one billion!).
We have a problem here. The hash table will either requires a large
amount of memory space, or there will be lots of collision in the table,
which makes access time no longer O(1) time. Therefore, using a hash
table is not a good general solution to this problem. Besides, using
hash table DO NOT require that the array being sorted in the first
place.

Here is the most important observation in order to solve this problem.
Both arrays ARE sorted. This provides a very important clue. We must
make full use of this information that they ARE in fact sorted.

We can have two index, which both starts at zero. Compare the two first
elements of A and B. If A[0] is greater than B[0], we increase index of
B by one. If B[0] is greater than A[0], we increase index of A by one.
If they are equal, we know an intersection has occurred, so add it to
the list and increment index of A and B by one. Once either index
reaches the end of A or B, we have found all the intersections of A and
B.

The complexity of this approach is still O(m+n), but it does not
requires any extra space that a hash table requires. The complexity is
O(m+n) because in the worse case, there would be no intersection between
the two arrays, and we need to increment first index a total of m times
and increment second index a total of n times, which is a total of m+n
times.

Below is the C++ code for this approach:

vector\<int\> findIntersection(vector\<int\> A, vector\<int\> B) {
vector\<int\> intersection; int n1 = A.size(); int n2 = B.size(); int i
= 0, j = 0; while (i \< n1 && j \< n2) { if (A[i] \> B[j]) { j++; } else
if (B[j] \> A[i]) { i++; } else { intersection.push\_back(A[i]); i++;
j++; } } return intersection; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="i">vector</span><span class="o">&lt;</span><span class="t">int</span><span class="o">&gt;</span><span class="h"> </span><span class="e">findIntersection</span><span class="sy">(</span><span class="i">vector</span><span class="o">&lt;</span><span class="t">int</span><span class="o">&gt;</span><span class="h"> </span><span class="i">A</span><span class="sy">,</span><span class="h"> </span><span class="i">vector</span><span class="o">&lt;</span><span class="t">int</span><span class="o">&gt;</span><span class="h"> </span><span class="i">B</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="i">vector</span><span class="o">&lt;</span><span class="t">int</span><span class="o">&gt;</span><span class="h"> </span><span class="i">intersection</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">n1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">A</span><span class="sy">.</span><span class="e">size</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">n2</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">B</span><span class="sy">.</span><span class="e">size</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n1</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n2</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="v">B</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">j</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">B</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">i</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">intersection</span><span class="sy">.</span><span class="e">push_back</span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="i">i</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="i">j</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">intersection</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

Do you think that this approach always work better? Not necessarily…
Think what happens when n is very large, say one billion…

Compare this approach with the binary search approach.  
O(m+n) and O(m\*lg(n))

lg(n) is much smaller than n when n is very big. However, this does not
necessarily means binary search is better in this case. In fact, binary
search approach is only better when m

All of our above approaches assume that we have enough space to load
both arrays to the memory. Here are some interesting questions to ponder
about:

i) What if elements of array B is stored on disk, and the memory is
limited such that you cannot load all elements into the memory at
once?  
ii) How will the complexity change in this case? Are there any factors
you need to consider?  
iii) How do you change your solution to adapt to this situation?

VN:F [1.9.22\_1171]

Rating: 5.0/**5** (26 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Finding intersection of two sorted arrays</span></span>,
<span class="rating"><span class="average">5.0</span> out of <span
class="best">5</span> based on <span class="votes">26</span> ratings
<span class="summary"></span></span></span>

How to determine if a point is inside a rectangle?
==================================================

April 12, 2010 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> Given a 2D point and a rectangle, determine if the point is inside the
> rectangle.

<span id="more-11"></span>

This is a problem that is related to Computer Graphics.

This question is trivial if the rectangle is not aligned to the x and
y-axis:

Assume point P’s coordinate is (x<sub>p</sub>,y<sub>p</sub>), and the
rectangle’s upper left point is (x<sub>1</sub>,y<sub>1</sub>) and lower
right point is (x<sub>2</sub>,y<sub>2</sub>):

if (x<sub>p</sub> is between x<sub>1</sub> and x<sub>2</sub>) AND
(y<sub>p</sub> is between y<sub>1</sub> and y<sub>2</sub>)  
 then the point(x<sub>p</sub>,y<sub>p</sub>) is inside the rectangle.

But what if the rectangle is rotated?

Although the question becomes much harder now, it is not too difficult
to think of another solution that utilizes the previous solution. If we
could transform the point and the rectangle such that the rectangle
become axis-aligned, we could solve the problem in the direct way
mentioned above. In other words, we are transforming the rectangle’s
coordinate space to the x-y coordinate space.

First, the rectangle’s center is translated to the origin, then the
rectangle is rotated such that it is axis-aligned with the major axes.
The rotation equation can be written as x’ = ux\*x + uy\*y and y’ =
vx\*x + vy\*y, where (x,y) is the original point, (x’,y’) is the rotated
point, (ux,uy) and (vx,vy) are both the normalized orthogonal vector of
the axes of the rectangle (see figure above). To understand why this is
so, you need to understand the [change of
basis](http://en.wikipedia.org/wiki/Change_of_basis) in linear algebra.

Translating and rotating points involve lots of multiplications. Can we
do better than this?

The answer is yes, we can utilize dot product. The trick is to use dot
product to find the projected line from point P onto the rectangle
sides, and if its length is shorter than the sides, then the point must
be inside the rectangle.

Assume that we have a pre-written Vector2d class
![:)](http://leetcode.com/wp-includes/images/smilies/icon_smile.gif)

bool is\_point\_in\_rectangle(const Rect& rect, const Point& p) {
Vector2d P1(rect.p1.x, rect.p1.y); Vector2d P2(rect.p2.x, rect.p2.y);
Vector2d P3(rect.p3.x, rect.p3.y); Vector2d P4(rect.p4.x, rect.p4.y);
Vector2d P(p.x, p.y); Vector2d P1\_P4 = P1 - P4; Vector2d P3\_P4 = P3 -
P4; Vector2d TWO\_P\_C = 2.0\*P - P1 - P3; // TWO\_P\_C=2P-C, C=Center
of rectangle return (P3\_P4.Dot(TWO\_P\_C - P3\_P4) \<= 0 &&
P3\_P4.Dot(TWO\_P\_C + P3\_P4) \>= 0) && (P1\_P4.Dot(TWO\_P\_C - P1\_P4)
\<= 0 && P1\_P4.Dot(TWO\_P\_C + P1\_P4) \>= 0); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">bool</span><span class="h"> </span><span class="e">is_point_in_rectangle</span><span class="sy">(</span><span class="m">const</span><span class="h"> </span><span class="i">Rect</span><span class="o">&amp;</span><span class="h"> </span><span class="i">rect</span><span class="sy">,</span><span class="h"> </span><span class="m">const</span><span class="h"> </span><span class="i">Point</span><span class="o">&amp;</span><span class="h"> </span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="e">Vector2d </span><span class="e">P1</span><span class="sy">(</span><span class="v">rect</span><span class="sy">.</span><span class="v">p1</span><span class="sy">.</span><span class="i">x</span><span class="sy">,</span><span class="h"> </span><span class="v">rect</span><span class="sy">.</span><span class="v">p1</span><span class="sy">.</span><span class="i">y</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Vector2d </span><span class="e">P2</span><span class="sy">(</span><span class="v">rect</span><span class="sy">.</span><span class="v">p2</span><span class="sy">.</span><span class="i">x</span><span class="sy">,</span><span class="h"> </span><span class="v">rect</span><span class="sy">.</span><span class="v">p2</span><span class="sy">.</span><span class="i">y</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Vector2d </span><span class="e">P3</span><span class="sy">(</span><span class="v">rect</span><span class="sy">.</span><span class="v">p3</span><span class="sy">.</span><span class="i">x</span><span class="sy">,</span><span class="h"> </span><span class="v">rect</span><span class="sy">.</span><span class="v">p3</span><span class="sy">.</span><span class="i">y</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Vector2d </span><span class="e">P4</span><span class="sy">(</span><span class="v">rect</span><span class="sy">.</span><span class="v">p4</span><span class="sy">.</span><span class="i">x</span><span class="sy">,</span><span class="h"> </span><span class="v">rect</span><span class="sy">.</span><span class="v">p4</span><span class="sy">.</span><span class="i">y</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">Vector2d</span><span class="h"> </span><span class="e">P</span><span class="sy">(</span><span class="v">p</span><span class="sy">.</span><span class="i">x</span><span class="sy">,</span><span class="h"> </span><span class="v">p</span><span class="sy">.</span><span class="i">y</span><span class="sy">)</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="e">Vector2d </span><span class="v">P1_P4</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">P1</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">P4</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Vector2d </span><span class="v">P3_P4</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">P3</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">P4</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Vector2d </span><span class="v">TWO_P_C</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">2.0</span><span class="o">*</span><span class="i">P</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">P1</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">P3</span><span class="sy">;</span><span class="h">    </span><span class="c">// TWO_P_C=2P-C, C=Center of rectangle</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="v">P3_P4</span><span class="sy">.</span><span class="e">Dot</span><span class="sy">(</span><span class="i">TWO_P_C</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">P3_P4</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="cn">0</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">P3_P4</span><span class="sy">.</span><span class="e">Dot</span><span class="sy">(</span><span class="i">TWO_P_C</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="i">P3_P4</span><span class="sy">)</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span></p>
<p><span class="h">         </span><span class="sy">(</span><span class="v">P1_P4</span><span class="sy">.</span><span class="e">Dot</span><span class="sy">(</span><span class="i">TWO_P_C</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">P1_P4</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="cn">0</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">P1_P4</span><span class="sy">.</span><span class="e">Dot</span><span class="sy">(</span><span class="i">TWO_P_C</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="i">P1_P4</span><span class="sy">)</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 2.4/**5** (18 votes cast)

<span class="hreview-aggregate"><span class="item"><span class="fn">How
to determine if a point is inside a rectangle?</span></span>, <span
class="rating"><span class="average">2.4</span> out of <span
class="best">5</span> based on <span class="votes">18</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/04/how-to-determine-if-point-is-inside.html>

### Leave a reply

> Have you ever thought of pretty-printing a binary tree?  
> <span id="more-41"></span>

Wouldn’t it be cool to output your binary tree like this?

                  ______________30______________
                 /                              \
          ______20______                  ______40______
         /              \                /              \
      __10__            25__            35            __50
     /      \               \                        /       
     5      15              28                      41

Or, if you prefer, output the tree like this instead? (to save some
horizontal space)

            ______30______
           /              \
        __20__          __40__
       /      \        /      \
      10      25      35      50
     /  \       \            /   
     5  15      28          41

I thought it would be really useful to you while you are cracking on
binary tree interview questions. Checking if your binary tree is read in
correctly into the program takes a lot of effort while you are testing
your algorithm.

That’s why I wrote the following C++ code myself. Check out the *60+*
lines of code below. Please note that the displayed code below did not
include some functions, such as *maxHeight()* and *intToString()*. For
the full source code which includes a sample driver demo program, please
download the source file below.

**Implementation:**  
This implementation is based on my previous post: [Printing a Binary
Tree in Level
Order](http://www.leetcode.com/2010/09/printing-binary-tree-in-level-order.html).
I use a deque (double-ended queue) instead of a queue because I want to
use std::iterator (in C++, deque supports it but not queue).

For a level, each node is spaced equally with neighboring nodes. This
allows a Math equation to be derived easily to calculate the exact
location a node will appear in a level.

Last time, when we see an “empty” node, we do not push anything onto the
queue. However, this time we need to push two “empty” nodes when we see
an “empty” node, since we need to print out the “empty” node as spaces
in order to produce a pretty output. Besides, it eases the programming a
lot since we do not need to keep track of the number of empty nodes that
appear before a valid node.

In the next post, I will talk about the methods I used to read/write a
binary tree from/to a file, so that you can run test cases easily.

**Huge Update Planned:**

I am planning to update **all** (most, if not all) of my previous posts
with sample input/output data sets, as requested by one of my fellow
readers, thanks
![:)](http://leetcode.com/wp-includes/images/smilies/icon_smile.gif) .
In the future, you should be able to test your algorithms easily!

**Download Sample Demo Program:**

// Print the arm branches (eg, / \\ ) on a line void printBranches(int
branchLen, int nodeSpaceLen, int startLen, int nodesInThisLevel, const
deque\<BinaryTree\*\>& nodesQueue, ostream& out) {
deque\<BinaryTree\*\>::const\_iterator iter = nodesQueue.begin(); for
(int i = 0; i \< nodesInThisLevel / 2; i++) { out \<\< ((i == 0) ?
setw(startLen-1) : setw(nodeSpaceLen-2)) \<\< "" \<\< ((\*iter++) ? "/"
: " "); out \<\< setw(2\*branchLen+2) \<\< "" \<\< ((\*iter++) ? "\\\\"
: " "); } out \<\< endl; } // Print the branches and node (eg,
\_\_\_10\_\_\_ ) void printNodes(int branchLen, int nodeSpaceLen, int
startLen, int nodesInThisLevel, const deque\<BinaryTree\*\>& nodesQueue,
ostream& out) { deque\<BinaryTree\*\>::const\_iterator iter =
nodesQueue.begin(); for (int i = 0; i \< nodesInThisLevel; i++, iter++)
{ out \<\< ((i == 0) ? setw(startLen) : setw(nodeSpaceLen)) \<\< "" \<\<
((\*iter && (\*iter)-\>left) ? setfill('\_') : setfill(' ')); out \<\<
setw(branchLen+2) \<\< ((\*iter) ? intToString((\*iter)-\>data) : "");
out \<\< ((\*iter && (\*iter)-\>right) ? setfill('\_') : setfill(' '))
\<\< setw(branchLen) \<\< "" \<\< setfill(' '); } out \<\< endl; } //
Print the leaves only (just for the bottom row) void printLeaves(int
indentSpace, int level, int nodesInThisLevel, const
deque\<BinaryTree\*\>& nodesQueue, ostream& out) {
deque\<BinaryTree\*\>::const\_iterator iter = nodesQueue.begin(); for
(int i = 0; i \< nodesInThisLevel; i++, iter++) { out \<\< ((i == 0) ?
setw(indentSpace+2) : setw(2\*level+2)) \<\< ((\*iter) ?
intToString((\*iter)-\>data) : ""); } out \<\< endl; } // Pretty
formatting of a binary tree to the output stream // @ param // level
Control how wide you want the tree to sparse (eg, level 1 has the
minimum space between nodes, while level 2 has a larger space between
nodes) // indentSpace Change this to add some indent space to the left
(eg, indentSpace of 0 means the lowest level of the left node will stick
to the left margin) void printPretty(BinaryTree \*root, int level, int
indentSpace, ostream& out) { int h = maxHeight(root); int
nodesInThisLevel = 1; int branchLen = 2\*((int)pow(2.0,h)-1) -
(3-level)\*(int)pow(2.0,h-1); // eq of the length of branch for each
node of each level int nodeSpaceLen = 2 + (level+1)\*(int)pow(2.0,h); //
distance between left neighbor node's right arm and right neighbor
node's left arm int startLen = branchLen + (3-level) + indentSpace; //
starting space to the first node to print of each level (for the left
most node of each level only) deque\<BinaryTree\*\> nodesQueue;
nodesQueue.push\_back(root); for (int r = 1; r \< h; r++) {
printBranches(branchLen, nodeSpaceLen, startLen, nodesInThisLevel,
nodesQueue, out); branchLen = branchLen/2 - 1; nodeSpaceLen =
nodeSpaceLen/2 + 1; startLen = branchLen + (3-level) + indentSpace;
printNodes(branchLen, nodeSpaceLen, startLen, nodesInThisLevel,
nodesQueue, out); for (int i = 0; i \< nodesInThisLevel; i++) {
BinaryTree \*currNode = nodesQueue.front(); nodesQueue.pop\_front(); if
(currNode) { nodesQueue.push\_back(currNode-\>left);
nodesQueue.push\_back(currNode-\>right); } else {
nodesQueue.push\_back(NULL); nodesQueue.push\_back(NULL); } }
nodesInThisLevel \*= 2; } printBranches(branchLen, nodeSpaceLen,
startLen, nodesInThisLevel, nodesQueue, out); printLeaves(indentSpace,
level, nodesInThisLevel, nodesQueue, out); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
<p>47</p>
<p>48</p>
<p>49</p>
<p>50</p>
<p>51</p>
<p>52</p>
<p>53</p>
<p>54</p>
<p>55</p>
<p>56</p>
<p>57</p>
<p>58</p>
<p>59</p>
<p>60</p>
<p>61</p>
<p>62</p>
<p>63</p>
<p>64</p>
<p>65</p>
<p>66</p>
<p>67</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="c">// Print the arm branches (eg, /    \ ) on a line</span></p>
<p><span class="t">void</span><span class="h"> </span><span class="e">printBranches</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">branchLen</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">nodeSpaceLen</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">startLen</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">nodesInThisLevel</span><span class="sy">,</span><span class="h"> </span><span class="m">const</span><span class="h"> </span><span class="i">deque</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="o">&amp;</span><span class="h"> </span><span class="i">nodesQueue</span><span class="sy">,</span><span class="h"> </span><span class="i">ostream</span><span class="o">&amp;</span><span class="h"> </span><span class="i">out</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="i">deque</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="o">::</span><span class="e">const_iterator </span><span class="v">iter</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">begin</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">nodesInThisLevel</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">2</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span><span class="h">  </span></p>
<p><span class="h">    </span><span class="i">out</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="v">i</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="e">setw</span><span class="sy">(</span><span class="i">startLen</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="e">setw</span><span class="sy">(</span><span class="i">nodeSpaceLen</span><span class="o">-</span><span class="cn">2</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;&quot;</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="o">*</span><span class="i">iter</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="s">&quot;/&quot;</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">out</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="e">setw</span><span class="sy">(</span><span class="cn">2</span><span class="o">*</span><span class="i">branchLen</span><span class="o">+</span><span class="cn">2</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;&quot;</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="o">*</span><span class="i">iter</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="s">&quot;\\&quot;</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="i">out</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">endl</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="c">// Print the branches and node (eg, ___10___ )</span></p>
<p><span class="t">void</span><span class="h"> </span><span class="e">printNodes</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">branchLen</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">nodeSpaceLen</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">startLen</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">nodesInThisLevel</span><span class="sy">,</span><span class="h"> </span><span class="m">const</span><span class="h"> </span><span class="i">deque</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="o">&amp;</span><span class="h"> </span><span class="i">nodesQueue</span><span class="sy">,</span><span class="h"> </span><span class="i">ostream</span><span class="o">&amp;</span><span class="h"> </span><span class="i">out</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="i">deque</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="o">::</span><span class="e">const_iterator </span><span class="v">iter</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">begin</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">nodesInThisLevel</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">,</span><span class="h"> </span><span class="i">iter</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">out</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="v">i</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="e">setw</span><span class="sy">(</span><span class="i">startLen</span><span class="sy">)</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="e">setw</span><span class="sy">(</span><span class="i">nodeSpaceLen</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;&quot;</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="o">*</span><span class="i">iter</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="i">iter</span><span class="sy">)</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="e">setfill</span><span class="sy">(</span><span class="s">'_'</span><span class="sy">)</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="e">setfill</span><span class="sy">(</span><span class="s">' '</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">out</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="e">setw</span><span class="sy">(</span><span class="i">branchLen</span><span class="o">+</span><span class="cn">2</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="o">*</span><span class="i">iter</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="e">intToString</span><span class="sy">(</span><span class="sy">(</span><span class="o">*</span><span class="i">iter</span><span class="sy">)</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">)</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="s">&quot;&quot;</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">out</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="o">*</span><span class="i">iter</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="i">iter</span><span class="sy">)</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="e">setfill</span><span class="sy">(</span><span class="s">'_'</span><span class="sy">)</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="e">setfill</span><span class="sy">(</span><span class="s">' '</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="e">setw</span><span class="sy">(</span><span class="i">branchLen</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;&quot;</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="e">setfill</span><span class="sy">(</span><span class="s">' '</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="i">out</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">endl</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="c">// Print the leaves only (just for the bottom row)</span></p>
<p><span class="t">void</span><span class="h"> </span><span class="e">printLeaves</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">indentSpace</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">level</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">nodesInThisLevel</span><span class="sy">,</span><span class="h"> </span><span class="m">const</span><span class="h"> </span><span class="i">deque</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="o">&amp;</span><span class="h"> </span><span class="i">nodesQueue</span><span class="sy">,</span><span class="h"> </span><span class="i">ostream</span><span class="o">&amp;</span><span class="h"> </span><span class="i">out</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="i">deque</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="o">::</span><span class="e">const_iterator </span><span class="v">iter</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">begin</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">nodesInThisLevel</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">,</span><span class="h"> </span><span class="i">iter</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">out</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="v">i</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="e">setw</span><span class="sy">(</span><span class="i">indentSpace</span><span class="o">+</span><span class="cn">2</span><span class="sy">)</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="e">setw</span><span class="sy">(</span><span class="cn">2</span><span class="o">*</span><span class="i">level</span><span class="o">+</span><span class="cn">2</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="o">*</span><span class="i">iter</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="e">intToString</span><span class="sy">(</span><span class="sy">(</span><span class="o">*</span><span class="i">iter</span><span class="sy">)</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">)</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="s">&quot;&quot;</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="i">out</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">endl</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="c">// Pretty formatting of a binary tree to the output stream</span></p>
<p><span class="c">// @ param</span></p>
<p><span class="c">// level  Control how wide you want the tree to sparse (eg, level 1 has the minimum space between nodes, while level 2 has a larger space between nodes)</span></p>
<p><span class="c">// indentSpace  Change this to add some indent space to the left (eg, indentSpace of 0 means the lowest level of the left node will stick to the left margin)</span></p>
<p><span class="t">void</span><span class="h"> </span><span class="e">printPretty</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">level</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">indentSpace</span><span class="sy">,</span><span class="h"> </span><span class="i">ostream</span><span class="o">&amp;</span><span class="h"> </span><span class="i">out</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">h</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">maxHeight</span><span class="sy">(</span><span class="i">root</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">nodesInThisLevel</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">branchLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">2</span><span class="o">*</span><span class="sy">(</span><span class="sy">(</span><span class="t">int</span><span class="sy">)</span><span class="e">pow</span><span class="sy">(</span><span class="cn">2.0</span><span class="sy">,</span><span class="i">h</span><span class="sy">)</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="sy">(</span><span class="cn">3</span><span class="o">-</span><span class="i">level</span><span class="sy">)</span><span class="o">*</span><span class="sy">(</span><span class="t">int</span><span class="sy">)</span><span class="e">pow</span><span class="sy">(</span><span class="cn">2.0</span><span class="sy">,</span><span class="i">h</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span><span class="h">  </span><span class="c">// eq of the length of branch for each node of each level</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">nodeSpaceLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">2</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="i">level</span><span class="o">+</span><span class="cn">1</span><span class="sy">)</span><span class="o">*</span><span class="sy">(</span><span class="t">int</span><span class="sy">)</span><span class="e">pow</span><span class="sy">(</span><span class="cn">2.0</span><span class="sy">,</span><span class="i">h</span><span class="sy">)</span><span class="sy">;</span><span class="h">  </span><span class="c">// distance between left neighbor node's right arm and right neighbor node's left arm</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">startLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">branchLen</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="cn">3</span><span class="o">-</span><span class="i">level</span><span class="sy">)</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="i">indentSpace</span><span class="sy">;</span><span class="h">  </span><span class="c">// starting space to the first node to print of each level (for the left most node of each level only)</span></p>
<p><span class="h">    </span></p>
<p><span class="h">  </span><span class="i">deque</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="h"> </span><span class="i">nodesQueue</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">push_back</span><span class="sy">(</span><span class="i">root</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">r</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">r</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">h</span><span class="sy">;</span><span class="h"> </span><span class="i">r</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="e">printBranches</span><span class="sy">(</span><span class="i">branchLen</span><span class="sy">,</span><span class="h"> </span><span class="i">nodeSpaceLen</span><span class="sy">,</span><span class="h"> </span><span class="i">startLen</span><span class="sy">,</span><span class="h"> </span><span class="i">nodesInThisLevel</span><span class="sy">,</span><span class="h"> </span><span class="i">nodesQueue</span><span class="sy">,</span><span class="h"> </span><span class="i">out</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">branchLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">branchLen</span><span class="o">/</span><span class="cn">2</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">nodeSpaceLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">nodeSpaceLen</span><span class="o">/</span><span class="cn">2</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">startLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">branchLen</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="cn">3</span><span class="o">-</span><span class="i">level</span><span class="sy">)</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="i">indentSpace</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="e">printNodes</span><span class="sy">(</span><span class="i">branchLen</span><span class="sy">,</span><span class="h"> </span><span class="i">nodeSpaceLen</span><span class="sy">,</span><span class="h"> </span><span class="i">startLen</span><span class="sy">,</span><span class="h"> </span><span class="i">nodesInThisLevel</span><span class="sy">,</span><span class="h"> </span><span class="i">nodesQueue</span><span class="sy">,</span><span class="h"> </span><span class="i">out</span><span class="sy">)</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">nodesInThisLevel</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="e">BinaryTree *</span><span class="v">currNode</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">front</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">pop_front</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">currNode</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">       </span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">push_back</span><span class="sy">(</span><span class="i">currNode</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">       </span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">push_back</span><span class="sy">(</span><span class="i">currNode</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">push_back</span><span class="sy">(</span><span class="t">NULL</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">push_back</span><span class="sy">(</span><span class="t">NULL</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="e">nodesInThisLevel *</span><span class="o">=</span><span class="h"> </span><span class="cn">2</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="e">printBranches</span><span class="sy">(</span><span class="i">branchLen</span><span class="sy">,</span><span class="h"> </span><span class="i">nodeSpaceLen</span><span class="sy">,</span><span class="h"> </span><span class="i">startLen</span><span class="sy">,</span><span class="h"> </span><span class="i">nodesInThisLevel</span><span class="sy">,</span><span class="h"> </span><span class="i">nodesQueue</span><span class="sy">,</span><span class="h"> </span><span class="i">out</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">printLeaves</span><span class="sy">(</span><span class="i">indentSpace</span><span class="sy">,</span><span class="h"> </span><span class="i">level</span><span class="sy">,</span><span class="h"> </span><span class="i">nodesInThisLevel</span><span class="sy">,</span><span class="h"> </span><span class="i">nodesQueue</span><span class="sy">,</span><span class="h"> </span><span class="i">out</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.9/**5** (14 votes cast)

<span class="hreview-aggregate"><span class="item"><span class="fn">How
to Pretty Print a Binary Tree</span></span>, <span class="rating"><span
class="average">4.9</span> out of <span class="best">5</span> based on
<span class="votes">14</span> ratings <span
class="summary"></span></span></span>

> Write C code to implement the *strstr* (Search for a substring)
> function. Do not use any system library such as *strlen*.

<span id="more-49"></span>  
The *strstr* function locates a specified substring within a source
string. *Strstr* returns a pointer to the first occurrence of the
substring in the source. If the substring is not found, *strstr* returns
a null pointer.

As expected, this question is very popular among technical interviews.
This question tests your ability in manipulating strings using pointers,
as well as your coding ability.

Of course, you can demonstrate to your interviewer that this problem can
be solved using known efficient algorithms such as [Rabin-Karp
algorithm](http://en.wikipedia.org/wiki/Rabin-Karp_algorithm), [KMP
algorithm](http://en.wikipedia.org/wiki/Knuth-morris-pratt_algorithm),
and the [Boyer-Moore
algorithm](http://en.wikipedia.org/wiki/Boyer_moore_algorithm). Since
these algorithms are usually studied in advanced algorithms class, for
an interview it is sufficient to solve it using the most direct method —
The *brute force method*.

For non-C programmers who are not familiar with C-style strings, your
first reaction is to obtain the length of the string. But remember, use
of system library is not allowed. If you are not familiar with pointer
manipulation, it’s time to brush up your pointer skills.

The brute force method is straightforward to implement. We scan the
substring (the target) with the string from its first position and start
matching all subsequent letters one by one. If one of the letter doesn’t
match, we start over again with the next position in the string. Assume
that ***N*** = length of string, ***M*** = length of substring, then the
complexity is *O*(***N*\**M***).

Think you’ve got it all in your head? Try writing the code down on a
piece of paper. Remember to test for special cases.

char\* StrStr(const char \*str, const char \*target) { if (!\*target)
return str; char \*p1 = (char\*)str; while (\*p1) { char \*p1Begin =
p1, \*p2 = (char\*)target; while (\*p1 && \*p2 && \*p1 == \*p2) { p1++;
p2++; } if (!\*p2) return p1Begin; p1 = p1Begin + 1; } return NULL; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">char</span><span class="o">*</span><span class="h"> </span><span class="e">StrStr</span><span class="sy">(</span><span class="m">const</span><span class="h"> </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="i">str</span><span class="sy">,</span><span class="h"> </span><span class="m">const</span><span class="h"> </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="i">target</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="o">*</span><span class="i">target</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="i">str</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="v">p1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="t">char</span><span class="o">*</span><span class="sy">)</span><span class="i">str</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="i">p1</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="v">p1Begin</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p1</span><span class="sy">,</span><span class="h"> </span><span class="o">*</span><span class="v">p2</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="t">char</span><span class="o">*</span><span class="sy">)</span><span class="i">target</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="i">p1</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="o">*</span><span class="i">p2</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="o">*</span><span class="v">p1</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="o">*</span><span class="i">p2</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">p1</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="i">p2</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="o">*</span><span class="i">p2</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="i">p1Begin</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">p1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p1Begin</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

Did you handle the special case correctly? That is, when the target
substring is an empty string. What should you return in this case? The
correct implementation of *strstr* should return the full string in this
case.

The above solution is usually good enough for an interview. But it turns
out we are able to improve the code a little further. Note that the
above code iterates at most ***N*** times in the outer loop.

The improvement is based on one observation: We only need to iterate at
most ***N*-*M*+1** times in the outer loop. Why? Because after looping
more than ***N*-*M*+1** times, the string has less than ***M***
characters to be matched with the substring. In this case, we know no
more substring will be found in the string, and therefore saving us from
additional comparisons (which might be substantial especially when
***M*** is large compared to ***N***.)

How do we loop for only ***N*-*M*+1** times? We are able to calculate
the size of the string and substring by iterating a total of ***N*+*M***
times. In fact, finding just the length of the substring, ***M*** is
sufficient. We use an additional pointer, *p1Adv* and advance it
***M*-1** times ahead of the string pointer. Therefore, when *p1Adv*
points to ‘\\0′, we know that it has iterated ***N*-*M*+1** times.

char\* StrStr(const char \*str, const char \*target) { if (!\*target)
return str; char \*p1 = (char\*)str, \*p2 = (char\*)target; char \*p1Adv
= (char\*)str; while (\*++p2) p1Adv++; while (\*p1Adv) { char \*p1Begin
= p1; p2 = (char\*)target; while (\*p1 && \*p2 && \*p1 == \*p2) { p1++;
p2++; } if (!\*p2) return p1Begin; p1 = p1Begin + 1; p1Adv++; } return
NULL; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">char</span><span class="o">*</span><span class="h"> </span><span class="e">StrStr</span><span class="sy">(</span><span class="m">const</span><span class="h"> </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="i">str</span><span class="sy">,</span><span class="h"> </span><span class="m">const</span><span class="h"> </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="i">target</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="o">*</span><span class="i">target</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="i">str</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="v">p1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="t">char</span><span class="o">*</span><span class="sy">)</span><span class="i">str</span><span class="sy">,</span><span class="h"> </span><span class="o">*</span><span class="v">p2</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="t">char</span><span class="o">*</span><span class="sy">)</span><span class="i">target</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="v">p1Adv</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="t">char</span><span class="o">*</span><span class="sy">)</span><span class="i">str</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="o">++</span><span class="i">p2</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="i">p1Adv</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="i">p1Adv</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="v">p1Begin</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p1</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">p2</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="t">char</span><span class="o">*</span><span class="sy">)</span><span class="i">target</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="i">p1</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="o">*</span><span class="i">p2</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="o">*</span><span class="v">p1</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="o">*</span><span class="i">p2</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">p1</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="i">p2</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="o">*</span><span class="i">p2</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="i">p1Begin</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">p1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p1Begin</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">p1Adv</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.5/**5** (40 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Implement strstr() to Find a Substring in a
String</span></span>, <span class="rating"><span
class="average">4.5</span> out of <span class="best">5</span> based on
<span class="votes">40</span> ratings <span
class="summary"></span></span></span>

> Given a node from a cyclic linked list which has been sorted, write a
> function to insert a value into the list such that it remains a cyclic
> sorted list. The given node can be any single node in the list.

<span id="more-846"></span>  
 **EDIT:**  
 Thanks to dear readers
**[Saurabh](http://www.leetcode.com/2011/08/insert-into-a-cyclic-sorted-list.html#comment-2190)**
and
**[reader](http://www.leetcode.com/2011/08/insert-into-a-cyclic-sorted-list.html#comment-10447)**
who pointed out my mistake. When the list has only one value, inserting
a different value would be handled by case 3), **not** case 1). Besides,
I believe I did not explain “What is a cyclic sorted list” nicely, as
this had caused some confusion. Imagine you have a sorted list, but its
tail points back to its head. In other words, the list must have a
minimum node, continue in a non-descending order, and eventually points
back to this minimum node itself. And the only way to access the list is
via aNode, which can point to any node in the list and **does not**
necessarily point to the minimum node.

First, it is important that you understand what a cyclic linked list is.
A cyclic linked list differs from a normal linked list in that its tail
node points back to its head node instead of NULL.

This problem seems a little tricky because the given node is not
necessarily the list’s head (ie, the node that has the smallest
element). It shouldn’t take you too long to come up with an idea, but
beware. There are hidden traps around the corner and you are bound to
make some mistakes if you are not careful in your thoughts.

[![](http://www.leetcode.com/wp-content/uploads/2011/08/cyclic_list1.png "cyclic_list1")](http://www.leetcode.com/wp-content/uploads/2011/08/cyclic_list1.png)A
cyclic sorted linked list. Note that the tail is pointing back to its
head. The only reference to the list is a given node which can be any
node in the list. Let’s say that you need to insert 4 into the list.

[![](http://www.leetcode.com/wp-content/uploads/2011/08/cyclic_list2.png "cyclic_list2")](http://www.leetcode.com/wp-content/uploads/2011/08/cyclic_list2.png)This
is how the cyclic list becomes after inserting 4. Note that the cyclic
linked list remained in sorted order.

**Hints:**  
 It is best to list all kinds of cases first before you jump into
coding. Then, it is much easier to reduce the number of cases your code
need to handle by combining some of them into a more generic case. Try
to also list down all possible edge cases if you have time. You might
discover a bug before you even start coding!

**Solution:**  
 Basically, you would have a loop that traverse the cyclic sorted list
and find the point where you insert the value (Let’s assume the value
being inserted called *x*). You would only need to consider the
following three cases:

**prev→val ≤ *x* ≤ current→val:**
Insert between prev and current.
***x* is the maximum or minimum value in the list:**
Insert before the head. (ie, the head has the smallest value and its
prev→val \> head→val.
**Traverses back to the starting point:**
Insert before the starting point.

Most people have no problem getting case 1) working, while case 2) is
easy to miss or being handled incorrectly. Case 3), on the other hand is
more subtle and is not immediately clear what kind of test cases would
hit this condition. It seemed that case 1) and 2) should take care of
all kinds of cases and case 3) is not needed. Think again… How can you
be sure of that? Could you come up with one case where it hits case 3)?

Q: What if the list has only one value?  
A: <s>Handled by case 1)</s>. Handled by case 3).

Q: What if the list is passed in as NULL?  
A: Then handle this special case by creating a new node pointing back to
itself and return.

Q: What if the list contains all duplicates?  
A: Then it has been handled by case 3).

Below is the code. You could combine both negation of case 1) and case
2) in the while loop’s condition, but I prefer to use break statements
here to illustrate the above idea clearer.

void insert(Node \*& aNode, int x) { if (!aNode) { aNode = new Node(x);
aNode-\>next = aNode; return; } Node \*p = aNode; Node \*prev = NULL; do
{ prev = p; p = p-\>next; if (x \<= p-\>data && x \>= prev-\>data)
break; // For case 1) if ((prev-\>data \> p-\>data) && (x \< p-\>data ||
x \> prev-\>data)) break; // For case 2) } while (p != aNode); // when
back to starting point, then stop. For case 3) Node \*newNode = new
Node(x); newNode-\>next = p; prev-\>next = newNode; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">insert</span><span class="sy">(</span><span class="e">Node *</span><span class="o">&amp;</span><span class="h"> </span><span class="i">aNode</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">x</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">aNode</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">aNode</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="r">new</span><span class="h"> </span><span class="e">Node</span><span class="sy">(</span><span class="i">x</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">aNode</span><span class="o">-&gt;</span><span class="v">next</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">aNode</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p> </p>
<p><span class="h">  </span><span class="e">Node *</span><span class="v">p</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">aNode</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Node *</span><span class="v">prev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">do</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">prev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">p</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">next</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">x</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="i">prev</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">)</span><span class="h"> </span><span class="st">break</span><span class="sy">;</span><span class="h">   </span><span class="c">// For case 1)</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">prev</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">x</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">prev</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="st">break</span><span class="sy">;</span><span class="h"> </span><span class="c">// For case 2)</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h"> </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">p</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="i">aNode</span><span class="sy">)</span><span class="sy">;</span><span class="h">   </span><span class="c">// when back to starting point, then stop. For case 3)</span></p>
<p> </p>
<p><span class="h">  </span><span class="e">Node *</span><span class="v">newNode</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="r">new</span><span class="h"> </span><span class="e">Node</span><span class="sy">(</span><span class="i">x</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">newNode</span><span class="o">-&gt;</span><span class="v">next</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">prev</span><span class="o">-&gt;</span><span class="v">next</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">newNode</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.6/**5** (61 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Insert into a Cyclic Sorted List</span></span>, <span
class="rating"><span class="average">4.6</span> out of <span
class="best">5</span> based on <span class="votes">61</span> ratings
<span class="summary"></span></span></span>

If you are majoring in Computer Science, chances are you’ll be working
with jobs that require some degree of programming. When you’re looking
for a job in the market, you’ll be having a lot of interviews.
Interviewer loves to challenge you by asking some technical interview
questions. <span id="more-4"></span>There are 3 types of technical
questions in general:

1) Algorithms/Data structure  
2) Programming language-specific / General CS knowledge  
3) Brain teaser

I’ll go over with more details on each of them:  
1) Algorithms/Data structure  
You should understand these topics deeply from a typical data structure
course: Array, Linked-list, Binary tree, Hash table… You should be able
to tell when to use an array vs. linked-list, implementation details of
linked list such as reversing a list…

Interviewer typically test your problem-solving ability by asking
algorithmic questions. Some examples are:  
- Reversing the words in a sentence.  
- Reversing the letters in a word. (Try both iteration and recursion
solutions)  
- How to find duplicate data in a list.  
- Generating permutations of n digits. (hint: recursion)  
- Find the median of combination of two sorted arrays of numbers. (hint:
divide and conquer)  
- How to spell-check and correct a word (hint: edit distance)

2) Programming language-specific / General CS knowledge  
If you’re applying a C++ programmer position, be prepared for lots of
C++ questions. Same with other languages. If the position you applying
does not have a language-specific role, you may be asked general CS
knowledge, such as difference between allocating on a stack and heap, …

Some C++ related questions I encounter often:  
- What are virtual functions? How is it implemented? What are the
trade-offs using virtual functions?  
- What is a virtual destructor? When do you need them? What if you don’t
implement a destructor as virtual?  
- What is copy constructor and when is it being called?  
- What’s the difference between malloc and new?

3) Brain teaser  
Some interviewers like to ask a brain teaser question to end the
interview
![:)](http://leetcode.com/wp-includes/images/smilies/icon_smile.gif)
You’ll know it when they ask: Do you like puzzles? Prepare for some
creative thinking
![:)](http://leetcode.com/wp-includes/images/smilies/icon_smile.gif)

Some sample questions:  
- Two eggs problem:  
You have two identical eggs and you are given access to a 100 story
building. You would like to know the highest floor for the egg not to
break when dropped. The problem is the egg might break on the 1st floor,
or even the 100th floor, you just don’t know. Find the maximum number of
trials you need to conduct in order to find the answer.

- Reverse the bits in one byte data as fast as possible.

- You have 5 identical jars. 4 of the jars contain balls with identical
size weighing 10g each, while 1 of the jar contains balls weighing 9g
each. You are given a digital scale, find out the 1 jar that has the 9g
balls with only 1 weighing.

VN:F [1.9.22\_1171]

Rating: 4.5/**5** (21 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Interview tips for programmers</span></span>, <span
class="rating"><span class="average">4.5</span> out of <span
class="best">5</span> based on <span class="votes">21</span> ratings
<span class="summary"></span></span></span>

> Given a binary tree, find the largest Binary Search Tree (BST), where
> largest means BST with largest number of nodes in it. The largest BST
> may or may not include all of its descendants.

<span id="more-60"></span>  

**Note:**

In this post, we develop a solution to find the largest BST in a binary
tree. Please note that the largest BST may or may not include all of its
descendants. If you are interested in the solution for finding the
largest BST subtree where it must include all of its descendants, read
my previous post: [Largest Subtree Which is a Binary Search Tree
(BST)](http://www.leetcode.com/2010/11/largest-binary-search-tree-bst-in.html).

An<span> </span>[anonymous
reader](http://www.leetcode.com/2010/11/largest-binary-search-tree-bst-in.html#comments)
left an interesting comment in my [previous
post](http://www.leetcode.com/2010/11/largest-binary-search-tree-bst-in.html)
where the interviewer was asking what if the largest BST may or may not
include all of its descendants.

From now onwards, we use the term ***largest BST*** for *largest BST
which may or may not include all of its descendants*, while ***largest
BST subtree*** is for *largest BST subtree which must include all of its
descendants*.

The example I showed in my last post was too trivial, so here I show a
slightly more complicated example.

                   ___________________15___________________
                  /                                        \ 
      ___________10___________                             20
     /                        \ 
     5                   _____7____
                        /          \
                      __2__       __5
                     /     \     / 
                     0      8    3 

The ***largest BST*** (may or may not include all of its descendants)
from the above example should be:

             ____15____
            /          \
          _10          20 
         /                 
         5

while the ***largest BST subtree*** (must include all of its
descendants) should be:

          __2_
         /    \
         0     8               

**An Incorrect Solution:**

One might try to do an in-order traversal of the binary tree and find
the longest increasing contiguous sequence or the [longest increasing
subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence).
Although these two approaches seemed to work for many cases, they are
flawed and cannot handle the above case.

Let’s do an in-order traversal for the above binary tree:

    5 10 0 2 8 7 3 5 15 20

The longest increasing contiguous sequence is:

    3 5 15 20

The longest increasing subsequence is:

    0 2 3 5 15 20

As you can see, neither one of them is correct.

**A Top-down Approach:**  
The largest BST subtree solution requires a bottom-up approach where the
min and max values are passed bottom-up. The main reason of doing this
is when one of the nodes does not satisfy the BST properties, all
subtrees above (which includes this node as well) must also **not**
satisfy the BST requirements.

However, finding the largest BST requires a slightly different approach.
We want the largest BST by including as many nodes as possible while we
traverse down the tree, as long the current BST constraint is
maintained. What happens when we see a node that breaks the current BST
constraint? The answer is we can simply exclude it. However, we must
treat it as an entirely new tree (ie, find in that tree if there is
another larger BST). As you can see, we are passing the min and max
values top-down, while the nodes count are passed bottom-up (Read my
[previous
post](http://www.leetcode.com/2010/11/largest-binary-search-tree-bst-in.html)
to know how).

As a tree is defined recursively using its left and right subtrees, you
could not simply return root node of the largest BST as this would
include all of its subtrees. You would need to create copies of the
subtrees or delete nodes from the original binary tree. My code below
create copies of the subtrees. As it does not handle the deletion of
trees, some of the subtrees that are created dynamically will eventually
be memory-leaked. Handling this problem would require more complicated
code. I will not demonstrate how to do it here since this post is to
illustrate the algorithm.

// Find the largest BST in a binary tree. // This code does not delete
dynamically-allocated nodes, // so memory will be leaked upon exit. //
The min and max values are passed top-down to check if // including a
node satisfies the current BST constraint. // The child nodes are passed
bottom-up to be assigned // to its parent. // Returns the total number
of nodes the child holds. int findLargestBST(BinaryTree \*p, int min,
int max, int &maxNodes, BinaryTree \*& largestBST, BinaryTree \*& child)
{ if (!p) return 0; if (min \< p-\>data && p-\>data \< max) { int
leftNodes = findLargestBST(p-\>left, min, p-\>data, maxNodes,
largestBST, child); BinaryTree \*leftChild = (leftNodes == 0) ? NULL :
child; int rightNodes = findLargestBST(p-\>right, p-\>data, max,
maxNodes, largestBST, child); BinaryTree \*rightChild = (rightNodes ==
0) ? NULL : child; // create a copy of the current node and // assign
its left and right child. BinaryTree \*parent = new
BinaryTree(p-\>data); parent-\>left = leftChild; parent-\>right =
rightChild; // pass the parent as the child to the above tree. child =
parent; int totalNodes = leftNodes + rightNodes + 1; if (totalNodes \>
maxNodes) { maxNodes = totalNodes; largestBST = parent; } return
totalNodes; } else { // include this node breaks the BST constraint, //
so treat this node as an entirely new tree and // check if a larger BST
exist in this tree findLargestBST(p, INT\_MIN, INT\_MAX, maxNodes,
largestBST, child); // must return 0 to exclude this node return 0; } }
BinaryTree\* findLargestBST(BinaryTree \*root) { BinaryTree \*largestBST
= NULL; BinaryTree \*child; int maxNodes = INT\_MIN;
findLargestBST(root, INT\_MIN, INT\_MAX, maxNodes, largestBST, child);
return largestBST; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="c">// Find the largest BST in a binary tree.</span></p>
<p><span class="c">// This code does not delete dynamically-allocated nodes,</span></p>
<p><span class="c">// so memory will be leaked upon exit.</span></p>
<p><span class="c">// The min and max values are passed top-down to check if</span></p>
<p><span class="c">// including a node satisfies the current BST constraint.</span></p>
<p><span class="c">// The child nodes are passed bottom-up to be assigned </span></p>
<p><span class="c">// to its parent.</span></p>
<p><span class="c">// Returns the total number of nodes the child holds.</span></p>
<p><span class="t">int</span><span class="h"> </span><span class="e">findLargestBST</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">min</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">max</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">maxNodes</span><span class="sy">,</span><span class="h"> </span></p>
<p><span class="h">                   </span><span class="e">BinaryTree *</span><span class="o">&amp;</span><span class="h"> </span><span class="i">largestBST</span><span class="sy">,</span><span class="h"> </span><span class="e">BinaryTree *</span><span class="o">&amp;</span><span class="h"> </span><span class="r">child</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">min</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">max</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">leftNodes</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">findLargestBST</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">min</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">,</span><span class="h"> </span><span class="i">maxNodes</span><span class="sy">,</span><span class="h"> </span><span class="i">largestBST</span><span class="sy">,</span><span class="h"> </span><span class="r">child</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="e">BinaryTree *</span><span class="v">leftChild</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="v">leftNodes</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="t">NULL</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="r">child</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">rightNodes</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">findLargestBST</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">,</span><span class="h"> </span><span class="i">max</span><span class="sy">,</span><span class="h"> </span><span class="i">maxNodes</span><span class="sy">,</span><span class="h"> </span><span class="i">largestBST</span><span class="sy">,</span><span class="h"> </span><span class="r">child</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="e">BinaryTree *</span><span class="v">rightChild</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="v">rightNodes</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="t">NULL</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="r">child</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="c">// create a copy of the current node and </span></p>
<p><span class="h">    </span><span class="c">// assign its left and right child.</span></p>
<p><span class="h">    </span><span class="e">BinaryTree *</span><span class="r">parent</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="r">new</span><span class="h"> </span><span class="e">BinaryTree</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="r">parent</span><span class="o">-&gt;</span><span class="v">left</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">leftChild</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="r">parent</span><span class="o">-&gt;</span><span class="v">right</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">rightChild</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="c">// pass the parent as the child to the above tree.</span></p>
<p><span class="h">    </span><span class="r">child</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="r">parent</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">totalNodes</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">leftNodes</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="i">rightNodes</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">totalNodes</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">maxNodes</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">maxNodes</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">totalNodes</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">largestBST</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="r">parent</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="i">totalNodes</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="c">// include this node breaks the BST constraint,</span></p>
<p><span class="h">    </span><span class="c">// so treat this node as an entirely new tree and </span></p>
<p><span class="h">    </span><span class="c">// check if a larger BST exist in this tree</span></p>
<p><span class="h">    </span><span class="e">findLargestBST</span><span class="sy">(</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="i">INT_MIN</span><span class="sy">,</span><span class="h"> </span><span class="i">INT_MAX</span><span class="sy">,</span><span class="h"> </span><span class="i">maxNodes</span><span class="sy">,</span><span class="h"> </span><span class="i">largestBST</span><span class="sy">,</span><span class="h"> </span><span class="r">child</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="c">// must return 0 to exclude this node</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="e">BinaryTree*</span><span class="h"> </span><span class="e">findLargestBST</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="e">BinaryTree *</span><span class="v">largestBST</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">BinaryTree *</span><span class="r">child</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">maxNodes</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">INT_MIN</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">findLargestBST</span><span class="sy">(</span><span class="i">root</span><span class="sy">,</span><span class="h"> </span><span class="i">INT_MIN</span><span class="sy">,</span><span class="h"> </span><span class="i">INT_MAX</span><span class="sy">,</span><span class="h"> </span><span class="i">maxNodes</span><span class="sy">,</span><span class="h"> </span><span class="i">largestBST</span><span class="sy">,</span><span class="h"> </span><span class="r">child</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">largestBST</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.6/**5** (33 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Largest Binary Search Tree (BST) in a Binary
Tree</span></span>, <span class="rating"><span
class="average">4.6</span> out of <span class="best">5</span> based on
<span class="votes">33</span> ratings <span
class="summary"></span></span></span>

> Given a binary tree, find the largest subtree which is a Binary Search
> Tree (BST), where largest means subtree with largest number of nodes
> in it.

<span id="more-58"></span>  

**Note:**

In this post, we develop a solution to find the largest BST subtree in a
binary tree. Please note that a subtree must include all of its
descendants. If you are only interested in the solution of finding the
largest BST where it may or may not include all of its descendants, read
my next post: [Largest Binary Search Tree (BST) in a Binary
Tree](http://www.leetcode.com/2010/11/largest-binary-search-tree-bst-in_22.html).

An [<span>anonymous
reader</span>](http://www.leetcode.com/2010/11/finding-minimum-window-in-s-which.html?showComment=1289930318245#comment-c8804992155578793351)
asked this interesting question, so here you are.
[Amazon](http://www.leetcode.com/search/label/amazon%20interview) had
asked this in technical interviews and it seemed to me that this is not
a popular tree question. It is one of the trickier ones, since you are
required to combine the idea from this problem: [Determine if a Binary
Tree is a Binary Search
Tree](http://www.leetcode.com/2010/09/determine-if-binary-tree-is-binary.html),
and also the idea of doing a Depth-first search (DFS).

It’s important that you understand the question correctly. Let’s try an
example below. Which is the largest BST subtree?

             ____10____
            /          \
          __5_         15_
         /    \           \
         1     8           7

For most people, there would be two possible interpretations for the
term “subtree”.

Is this <span>( subtree (1) )</span> the largest BST subtree?

             ____10____
            /          \
          __5_         15     -------- subtree (1)
         /    \ 
         1     8 

How about this one<span> ( subtree (2) ) </span>?

          __5_
         /    \               -------- subtree (2)
         1     8 

According to [Wikipedia](http://en.wikipedia.org/wiki/Subtree), a
subtree of a tree T is a tree consisting of a node in T and all of its
descendants in T. Therefore, there is no doubt that <span>subtree
(2)</span> is the correct answer, as <span>subtree (1)</span> does not
include all of its descendants. It is important that you understand the
term subtree correctly. If you are not sure, ask the interviewer and you
should not make any assumptions.

**Naive Approach:**  
A naive approach is to reuse the solution from [Determine if a Binary
Tree is a Binary Search
Tree](http://www.leetcode.com/2010/09/determine-if-binary-tree-is-binary.html).
Starting from the root, we process in the order of current node, left
child, then right child. For each node, you would call *isBST()* to
check if the current subtree is a BST. If it is, then we have found the
largest BST subtree. If it is not, then we have to continue examining
its left and right child. If only one of the subtrees is BST, then we
can return that subtree. However, if both left and right subtrees are
BSTs, then we have to compare which subtree is larger (has more
descendant nodes), then return the larger one.

Assume that we have a complete tree (ie, all leaves are at the same
depth) with *n* nodes, the naive approach’s run time complexity is
*O*(*n* lg *n*). The proof is left as an exercise to the reader.
![](http://4.bp.blogspot.com/_UElib2WLeDE/TK7aJSBFXSI/AAAAAAAACW8/5f8CRD5dJ8o/s1600/smiley.jpg)

**A Flawed Approach:**

How about doing an in-order traversal for the binary tree? The longest
increasing contiguous sequence must be the largest BST subtree. Try to
do an in-order traversal for the example tree above. This approach
simply does not work. Period.

**A Bottom-up Approach:**  
The naive approach is using a top-down approach. It is hardly efficient,
simply because we are calling *isBST()* over and over again. Each time
*isBST()* is called, it traverses down to the leaves to verify if the
subtree is a BST.

Let’s think from another perspective. Instead of traversing down the
tree, why not traverse up the tree using a bottom-up approach? In other
words, we verify the deeper nodes before we verify if the above nodes
satisfy the BST requirements.

The main reason of doing this is when one of the nodes does not satisfy
the BST properties, all subtrees above (which includes this node as
well) must also **not** satisfy the BST requirements.

First, let’s review our definition of a BST. A tree is a BST if the
following properties are satisfied:

-   Both left and right subtrees of a node are BSTs.
-   The node’s value is greater than its left subtree’s maximum.
-   The node’s value is less than its right subtree’s minimum.

Using a bottom-up approach, we need to pass some information up the
tree. Obviously, we need to pass minimum and maximum values of the
subtree as we traverse up the tree, so the above subtrees could be
verified for BST’s properties.

As compared to the top-down approach, the bottom-up approach is such an
awesome choice because the results for total number of nodes could be
passed up the tree. This saves us from recalculating over and over
again. The total number of nodes for a subtree is simply the total
number of nodes of its left and right subtrees plus one.

Isn’t the bottom-up approach neat? It acts like magic until you
understand it, and solves all the problems that the top-down approach
has. The run-time complexity for the bottom-up approach is *O*(*n*).
Beware of this gotcha when you implement the algorithm. Even though a
node’s left subtree is not a BST, you must still continue traverse its
right subtree as the largest BST subtree might be contained in its right
subtree.

// Find the largest BST subtree in a binary tree. // If the subtree is a
BST, return total number of nodes. // If the subtree is not a BST, -1 is
returned. int findLargestBSTSubtree(BinaryTree \*p, int &min, int &max,
int &maxNodes, BinaryTree \*& largestBST) { if (!p) return 0; bool isBST
= true; int leftNodes = findLargestBSTSubtree(p-\>left, min, max,
maxNodes, largestBST); int currMin = (leftNodes == 0) ? p-\>data : min;
if (leftNodes == -1 || (leftNodes != 0 && p-\>data \<= max)) isBST =
false; int rightNodes = findLargestBSTSubtree(p-\>right, min, max,
maxNodes, largestBST); int currMax = (rightNodes == 0) ? p-\>data : max;
if (rightNodes == -1 || (rightNodes != 0 && p-\>data \>= min)) isBST =
false; if (isBST) { min = currMin; max = currMax; int totalNodes =
leftNodes + rightNodes + 1; if (totalNodes \> maxNodes) { maxNodes =
totalNodes; largestBST = p; } return totalNodes; } else { return -1; //
This subtree is not a BST } } BinaryTree\*
findLargestBSTSubtree(BinaryTree \*root) { BinaryTree \*largestBST =
NULL; int min, max; int maxNodes = INT\_MIN; findLargestBSTSubtree(root,
min, max, maxNodes, largestBST); return largestBST; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="c">// Find the largest BST subtree in a binary tree.</span></p>
<p><span class="c">// If the subtree is a BST, return total number of nodes.</span></p>
<p><span class="c">// If the subtree is not a BST, -1 is returned.</span></p>
<p><span class="t">int</span><span class="h"> </span><span class="e">findLargestBSTSubtree</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">min</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">max</span><span class="sy">,</span><span class="h"> </span></p>
<p><span class="h">                   </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">maxNodes</span><span class="sy">,</span><span class="h"> </span><span class="e">BinaryTree *</span><span class="o">&amp;</span><span class="h"> </span><span class="i">largestBST</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">bool</span><span class="h"> </span><span class="v">isBST</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">leftNodes</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">findLargestBSTSubtree</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">min</span><span class="sy">,</span><span class="h"> </span><span class="i">max</span><span class="sy">,</span><span class="h"> </span><span class="i">maxNodes</span><span class="sy">,</span><span class="h"> </span><span class="i">largestBST</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">currMin</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="v">leftNodes</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="i">min</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">leftNodes</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="o">-</span><span class="cn">1</span><span class="h"> </span><span class="o">||</span><span class="h"> </span></p>
<p><span class="h">     </span><span class="sy">(</span><span class="i">leftNodes</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="cn">0</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">max</span><span class="sy">)</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="v">isBST</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">rightNodes</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">findLargestBSTSubtree</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">min</span><span class="sy">,</span><span class="h"> </span><span class="i">max</span><span class="sy">,</span><span class="h"> </span><span class="i">maxNodes</span><span class="sy">,</span><span class="h"> </span><span class="i">largestBST</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">currMax</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="v">rightNodes</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="i">max</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">rightNodes</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="o">-</span><span class="cn">1</span><span class="h"> </span><span class="o">||</span><span class="h"> </span></p>
<p><span class="h">     </span><span class="sy">(</span><span class="i">rightNodes</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="cn">0</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="i">min</span><span class="sy">)</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="v">isBST</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">isBST</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">min</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">currMin</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">max</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">currMax</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">totalNodes</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">leftNodes</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="i">rightNodes</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">totalNodes</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">maxNodes</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">maxNodes</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">totalNodes</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">largestBST</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="i">totalNodes</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span><span class="h">   </span><span class="c">// This subtree is not a BST</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="e">BinaryTree*</span><span class="h"> </span><span class="e">findLargestBSTSubtree</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="e">BinaryTree *</span><span class="v">largestBST</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="i">min</span><span class="sy">,</span><span class="h"> </span><span class="i">max</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">maxNodes</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">INT_MIN</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">findLargestBSTSubtree</span><span class="sy">(</span><span class="i">root</span><span class="sy">,</span><span class="h"> </span><span class="i">min</span><span class="sy">,</span><span class="h"> </span><span class="i">max</span><span class="sy">,</span><span class="h"> </span><span class="i">maxNodes</span><span class="sy">,</span><span class="h"> </span><span class="i">largestBST</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">largestBST</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Further Thoughts:**

Here is a variant of the largest BST problem. What if we want to find
the largest BST in a tree where it may or may not include all of its
descendants? Read my next post: [Largest Binary Search Tree (BST) in a
Binary
Tree](http://www.leetcode.com/2010/11/largest-binary-search-tree-bst-in_22.html)
to find out.

VN:F [1.9.22\_1171]

Rating: 4.6/**5** (19 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Largest Subtree Which is a Binary Search Tree
(BST)</span></span>, <span class="rating"><span
class="average">4.6</span> out of <span class="best">5</span> based on
<span class="votes">19</span> ratings <span
class="summary"></span></span></span>

> Given a string S, find the longest palindromic substring in S.

<span id="more-951"></span>  
 This interesting problem has been featured in the famous [Greplin
programming challenge](http://challenge.greplin.com/), and is asked
quite often in the interviews. Why? Because this problem can be attacked
in so many ways. There are five different solutions that I am aware of.
Are you up to the challenge?

Head over to **[Online Judge](http://www.leetcode.com/onlinejudge)** to
solve it now! (you may submit either C++ or Java solution)

**Hint:**  
 First, make sure you understand what a palindrome means. A palindrome
is a string which reads the same in both directions. For example, “aba”
is a palindome, “abc” is not.

**A common mistake:**  
 Some people will be tempted to come up with a quick solution, which is
unfortunately flawed (however can be corrected easily):

Reverse S and become S’. Find the [longest common
substring](http://en.wikipedia.org/wiki/Longest_common_substring)
between S and S’, which must also be the longest palindromic substring.

This seemed to work, let’s see some examples below.

For example,  
 S = “caba”, S’ = “abac”.  
 The longest common substring between S and S’ is “aba”, which is the
answer.

Let’s try another example:  
 S = “abacdfgdcaba”, S’ = “abacdgfdcaba”.  
 The longest common substring between S and S’ is “abacd”. Clearly, this
is not a valid palindrome.

We could see that the longest common substring method fails when there
exists *a reversed copy of a non-palindromic substring in some other
part of S*. To rectify this, each time we find a longest common
substring candidate, we check if the substring’s indices are the same as
the reversed substring’s original indices. If it is, then we attempt to
update the longest palindrome found so far; if not, we skip this and
find the next candidate.

This gives us a O(N<sup>2</sup>) DP solution which uses O(N<sup>2</sup>)
space (could be improved to use O(N) space). Please read more about
Longest Common Substring
[here](http://en.wikipedia.org/wiki/Longest_common_substring).

**Brute force solution, O(N<sup>3</sup>):**  
 The obvious brute force solution is to pick all possible starting and
ending positions for a substring, and verify if it is a palindrome.
There are a total of C(N, 2) such substrings (excluding the trivial
solution where a character itself is a palindrome).

Since verifying each substring takes O(N) time, the run time complexity
is O(N<sup>3</sup>).

**Dynamic programming solution, O(N<sup>2</sup>) time and
O(N<sup>2</sup>) space:**  
 To improve over the brute force solution from a DP approach, first
think how we can avoid unnecessary re-computation in validating
palindromes. Consider the case “ababa”. If we already knew that “bab” is
a palindrome, it is obvious that “ababa” must be a palindrome since the
two left and right end letters are the same.

Stated more formally below:

Define P[ i, j ] ← true **iff** the substring S<sub>i</sub> …
S<sub>j</sub> is a palindrome, otherwise false.

Therefore,

P[ i, j ] ← ( P[ i+1, j-1 ] **and** S<sub>i</sub> = S<sub>j</sub> )

The base cases are:

P[ i, i ] ← true  
 P[ i, i+1 ] ← ( S<sub>i</sub> = S<sub>i+1</sub> )

This yields a straight forward DP solution, which we first initialize
the one and two letters palindromes, and work our way up finding all
three letters palindromes, and so on… 

This gives us a run time complexity of O(N<sup>2</sup>) and uses
O(N<sup>2</sup>) space to store the table.

string longestPalindromeDP(string s) { int n = s.length(); int
longestBegin = 0; int maxLen = 1; bool table[1000][1000] = {false}; for
(int i = 0; i \< n; i++) { table[i][i] = true; } for (int i = 0; i \<
n-1; i++) { if (s[i] == s[i+1]) { table[i][i+1] = true; longestBegin =
i; maxLen = 2; } } for (int len = 3; len \<= n; len++) { for (int i = 0;
i \< n-len+1; i++) { int j = i+len-1; if (s[i] == s[j] &&
table[i+1][j-1]) { table[i][j] = true; longestBegin = i; maxLen = len; }
} } return s.substr(longestBegin, maxLen); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">string</span><span class="h"> </span><span class="e">longestPalindromeDP</span><span class="sy">(</span><span class="t">string</span><span class="h"> </span><span class="i">s</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">n</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">length</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">longestBegin</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">maxLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">bool</span><span class="h"> </span><span class="v">table</span><span class="sy">[</span><span class="cn">1000</span><span class="sy">]</span><span class="sy">[</span><span class="cn">1000</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">{</span><span class="t">false</span><span class="sy">}</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">table</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">s</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="v">s</span><span class="sy">[</span><span class="i">i</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">table</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">i</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">longestBegin</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">i</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">maxLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">2</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">len</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">3</span><span class="sy">;</span><span class="h"> </span><span class="i">len</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">len</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="i">len</span><span class="o">+</span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">i</span><span class="o">+</span><span class="i">len</span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">s</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="v">s</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">table</span><span class="sy">[</span><span class="i">i</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">table</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">longestBegin</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">i</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">maxLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">len</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">substr</span><span class="sy">(</span><span class="i">longestBegin</span><span class="sy">,</span><span class="h"> </span><span class="i">maxLen</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Additional exercise:**  
 Could you improve the above space complexity further and how?

**A simpler approach, O(N<sup>2</sup>) time and O(1) space:**  
 In fact, we could solve it in O(N<sup>2</sup>) time without any extra
space.

We observe that a palindrome mirrors around its center. Therefore, a
palindrome can be expanded from its center, and there are only 2N-1 such
centers.

You might be asking why there are 2N-1 but not N centers? The reason is
the center of a palindrome can be in between two letters. Such
palindromes have even number of letters (such as “abba”) and its center
are between the two ‘b’s.

Since expanding a palindrome around its center could take O(N) time, the
overall complexity is O(N<sup>2</sup>).

string expandAroundCenter(string s, int c1, int c2) { int l = c1, r =
c2; int n = s.length(); while (l \>= 0 && r \<= n-1 && s[l] == s[r]) {
l--; r++; } return s.substr(l+1, r-l-1); } string
longestPalindromeSimple(string s) { int n = s.length(); if (n == 0)
return ""; string longest = s.substr(0, 1); // a single char itself is a
palindrome for (int i = 0; i \< n-1; i++) { string p1 =
expandAroundCenter(s, i, i); if (p1.length() \> longest.length())
longest = p1; string p2 = expandAroundCenter(s, i, i+1); if
(p2.length() \> longest.length()) longest = p2; } return longest; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">string</span><span class="h"> </span><span class="e">expandAroundCenter</span><span class="sy">(</span><span class="t">string</span><span class="h"> </span><span class="i">s</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">c1</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">c2</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">l</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">c1</span><span class="sy">,</span><span class="h"> </span><span class="v">r</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">c2</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">n</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">length</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">l</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">r</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">s</span><span class="sy">[</span><span class="i">l</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="v">s</span><span class="sy">[</span><span class="i">r</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">l</span><span class="o">--</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">r</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">substr</span><span class="sy">(</span><span class="i">l</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">r</span><span class="o">-</span><span class="i">l</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">string</span><span class="h"> </span><span class="e">longestPalindromeSimple</span><span class="sy">(</span><span class="t">string</span><span class="h"> </span><span class="i">s</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">n</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">length</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">n</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="s">&quot;&quot;</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">string</span><span class="h"> </span><span class="v">longest</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">substr</span><span class="sy">(</span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span><span class="h">  </span><span class="c">// a single char itself is a palindrome</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">string</span><span class="h"> </span><span class="v">p1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">expandAroundCenter</span><span class="sy">(</span><span class="i">s</span><span class="sy">,</span><span class="h"> </span><span class="i">i</span><span class="sy">,</span><span class="h"> </span><span class="i">i</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">p1</span><span class="sy">.</span><span class="e">length</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="v">longest</span><span class="sy">.</span><span class="e">length</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">longest</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p1</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">    </span><span class="t">string</span><span class="h"> </span><span class="v">p2</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">expandAroundCenter</span><span class="sy">(</span><span class="i">s</span><span class="sy">,</span><span class="h"> </span><span class="i">i</span><span class="sy">,</span><span class="h"> </span><span class="i">i</span><span class="o">+</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">p2</span><span class="sy">.</span><span class="e">length</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="v">longest</span><span class="sy">.</span><span class="e">length</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">longest</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p2</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">longest</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**<span>Further Thoughts:</span>**  
 Does an O(N) solution exist? You bet! However, it is not trivial and
requires some very clever observation. The O(N) solution is explained in
my [next
post](http://www.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html).

**<span>» Continue reading</span> [Longest Palindromic Substring Part
II.](http://www.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html)**

VN:F [1.9.22\_1171]

Rating: 4.9/**5** (103 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Longest Palindromic Substring Part I</span></span>, <span
class="rating"><span class="average">4.9</span> out of <span
class="best">5</span> based on <span class="votes">103</span> ratings
<span class="summary"></span></span></span>

Longest Palindromic Substring Part II
=====================================

November 20, 2011 <span>in
[string](http://leetcode.com/category/string "View all posts in string")</span>
<span class="post-utility alignright"></span>

> Given a string S, find the longest palindromic substring in S.

**<span>Note:</span>**  
 This is Part II of the article: [Longest Palindromic
Substring](http://www.leetcode.com/2011/11/longest-palindromic-substring-part-i.html).
Here, we describe an algorithm (Manacher’s algorithm) which finds the
longest palindromic substring in linear time. Please read [Part
I](http://www.leetcode.com/2011/11/longest-palindromic-substring-part-i.html)
for more background information.  
 <span id="more-993"></span>  
 In my [previous
post](http://www.leetcode.com/2011/11/longest-palindromic-substring-part-i.html)
we discussed a total of four different methods, among them there’s a
pretty simple algorithm with O(N<sup>2</sup>) run time and constant
space complexity. Here, we discuss an algorithm that runs in O(N) time
and O(N) space, also known as Manacher’s algorithm.

**Hint:**  
 Think how you would improve over the simpler O(N<sup>2</sup>) approach.
Consider the worst case scenarios. The worst case scenarios are the
inputs with multiple palindromes overlapping each other. For example,
the inputs: “aaaaaaaaa” and “cabcbabcbabcba”. In fact, we could take
advantage of the palindrome’s symmetric property and avoid some of the
unnecessary computations.

**An O(N) Solution (Manacher’s Algorithm):**  
 First, we transform the input string, S, to another string T by
inserting a special character ‘\#’ in between letters. The reason for
doing so will be immediately clear to you soon.

For example: S = “abaaba”, T = “\#a\#b\#a\#a\#b\#a\#”.

To find the longest palindromic substring, we need to expand around each
T<sub>i</sub> such that T<sub>i-d</sub> … T<sub>i+d</sub> forms a
palindrome. You should immediately see that *d* is the length of the
palindrome itself centered at T<sub>i</sub>.

We store intermediate result in an array P, where P[ i ] equals to the
length of the palindrome centers at T<sub>i</sub>. The longest
palindromic substring would then be the maximum element in P.

Using the above example, we populate P as below (from left to right):

    T = # a # b # a # a # b # a #
    P = 0 1 0 3 0 1 6 1 0 3 0 1 0

Looking at P, we immediately see that the longest palindrome is
“abaaba”, as indicated by P<sub>6</sub> = 6.

Did you notice by inserting special characters (\#) in between letters,
both palindromes of odd and even lengths are handled graciously? (Please
note: This is to demonstrate the idea more easily and is not necessarily
needed to code the algorithm.)

Now, imagine that you draw an imaginary vertical line at the center of
the palindrome “abaaba”. Did you notice the numbers in P are symmetric
around this center? That’s not only it, try another palindrome “aba”,
the numbers also reflect similar symmetric property. Is this a
coincidence? The answer is yes and no. This is only true subjected to a
condition, but anyway, we have great progress, since we can eliminate
recomputing part of P[ i ]‘s.

Let us move on to a slightly more sophisticated example with more some
overlapping palindromes, where S = “babcbabcbaccba”.

[![](http://www.leetcode.com/wp-content/uploads/2011/11/palindrome_table10.png "palindrome_table10")](http://www.leetcode.com/wp-content/uploads/2011/11/palindrome_table10.png)  
 <span>Above image shows T transformed from S = “babcbabcbaccba”.
Assumed that you reached a state where table P is partially completed.
The solid vertical line indicates the center (C) of the palindrome
“abcbabcba”. The two dotted vertical line indicate its left (L) and
right (R) edges respectively. You are at index i and its mirrored index
around C is i’. How would you calculate P[ i ] efficiently? </span>

Assume that we have arrived at index i = 13, and we need to calculate P[
13 ] (indicated by the question mark ?). We first look at its mirrored
index i’ around the palindrome’s center C, which is index i’ = 9.

[![](http://www.leetcode.com/wp-content/uploads/2011/11/palindrome_table11.png "palindrome_table11")](http://www.leetcode.com/wp-content/uploads/2011/11/palindrome_table11.png)  
 <span>The two green solid lines above indicate the covered region by
the two palindromes centered at i and i’. We look at the mirrored index
of i around C, which is index i’. P[ i' ] = P[ 9 ] = 1. It is clear that
P[ i ] must also be 1, due to the symmetric property of a palindrome
around its center. </span>

As you can see above, it is very obvious that P[ i ] = P[ i' ] = 1,
which must be true due to the symmetric property around a palindrome’s
center. In fact, all three elements after C follow the symmetric
property (that is, P[ 12 ] = P[ 10 ] = 0, P[ 13 ] = P[ 9 ] = 1, P[ 14 ]
= P[ 8 ] = 0).

[![](http://www.leetcode.com/wp-content/uploads/2011/11/palindrome_table4.png "palindrome_table4")](http://www.leetcode.com/wp-content/uploads/2011/11/palindrome_table4.png)  
 <span>Now we are at index i = 15, and its mirrored index around C is i’
= 7. Is P[ 15 ] = P[ 7 ] = 7? </span>

Now we are at index i = 15. What’s the value of P[ i ]? If we follow the
symmetric property, the value of P[ i ] should be the same as P[ i' ] =
7. But this is wrong. If we expand around the center at T<sub>15</sub>,
it forms the palindrome “a\#b\#c\#b\#a”, which is actually shorter than
what is indicated by its symmetric counterpart. Why?

[![](http://www.leetcode.com/wp-content/uploads/2011/11/palindrome_table5.png "palindrome_table5")](http://www.leetcode.com/wp-content/uploads/2011/11/palindrome_table5.png)  
 <span>Colored lines are overlaid around the center at index i and i’.
Solid green lines show the region that must match for both sides due to
symmetric property around C. Solid red lines show the region that might
not match for both sides. Dotted green lines show the region that
crosses over the center. </span>

It is clear that the two substrings in the region indicated by the two
solid green lines must match exactly. Areas across the center (indicated
by dotted green lines) must also be symmetric. Notice carefully that P[
i ' ] is 7 and it expands all the way across the left edge (L) of the
palindrome (indicated by the solid red lines), which does not fall under
the symmetric property of the palindrome anymore. All we know is P[ i ]
≥ 5, and to find the real value of P[ i ] we have to do character
matching by expanding past the right edge (R). In this case, since P[ 21
] ≠ P[ 1 ], we conclude that P[ i ] = 5.

Let’s summarize the key part of this algorithm as below:

**if** P[ i' ] ≤ R – i,  
 **then** P[ i ] ← P[ i' ]  
 **else** P[ i ] ≥ P[ i' ]. (Which we have to expand past the right edge
(R) to find P[ i ].

See how elegant it is? If you are able to grasp the above summary fully,
you already obtained the essence of this algorithm, which is also the
hardest part.

The final part is to determine when should we move the position of C
together with R to the right, which is easy:

If the palindrome centered at i does expand past R, we update C to i,
(the center of this new palindrome), and extend R to the new
palindrome’s right edge.

In each step, there are two possibilities. If P[ i ] ≤ R – i, we set P[
i ] to P[ i' ] which takes exactly one step. Otherwise we attempt to
change the palindrome’s center to i by expanding it starting at the
right edge, R. Extending R (the inner while loop) takes at most a total
of N steps, and positioning and testing each centers take a total of N
steps too. Therefore, this algorithm guarantees to finish in at most
2\*N steps, giving a linear time solution.

// Transform S into T. // For example, S = "abba", T =
"^\#a\#b\#b\#a\#$". // ^ and $ signs are sentinels appended to each end
to avoid bounds checking string preProcess(string s) { int n =
s.length(); if (n == 0) return "^$"; string ret = "^"; for (int i = 0; i
\< n; i++) ret += "\#" + s.substr(i, 1); ret += "\#$"; return ret; }
string longestPalindrome(string s) { string T = preProcess(s); int n =
T.length(); int \*P = new int[n]; int C = 0, R = 0; for (int i = 1; i \<
n-1; i++) { int i\_mirror = 2\*C-i; // equals to i' = C - (i-C) P[i] =
(R \> i) ? min(R-i, P[i\_mirror]) : 0; // Attempt to expand palindrome
centered at i while (T[i + 1 + P[i]] == T[i - 1 - P[i]]) P[i]++; // If
palindrome centered at i expand past R, // adjust center based on
expanded palindrome. if (i + P[i] \> R) { C = i; R = i + P[i]; } } //
Find the maximum element in P. int maxLen = 0; int centerIndex = 0; for
(int i = 1; i \< n-1; i++) { if (P[i] \> maxLen) { maxLen = P[i];
centerIndex = i; } } delete[] P; return s.substr((centerIndex - 1 -
maxLen)/2, maxLen); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
<p>47</p>
<p>48</p>
<p>49</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="c">// Transform S into T.</span></p>
<p><span class="c">// For example, S = &quot;abba&quot;, T = &quot;^#a#b#b#a#$&quot;.</span></p>
<p><span class="c">// ^ and $ signs are sentinels appended to each end to avoid bounds checking</span></p>
<p><span class="t">string</span><span class="h"> </span><span class="e">preProcess</span><span class="sy">(</span><span class="t">string</span><span class="h"> </span><span class="i">s</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">n</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">length</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">n</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="s">&quot;^$&quot;</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">string</span><span class="h"> </span><span class="v">ret</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="s">&quot;^&quot;</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="i">ret</span><span class="h"> </span><span class="o">+</span><span class="o">=</span><span class="h"> </span><span class="s">&quot;#&quot;</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">substr</span><span class="sy">(</span><span class="i">i</span><span class="sy">,</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="i">ret</span><span class="h"> </span><span class="o">+</span><span class="o">=</span><span class="h"> </span><span class="s">&quot;#$&quot;</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">ret</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">string</span><span class="h"> </span><span class="e">longestPalindrome</span><span class="sy">(</span><span class="t">string</span><span class="h"> </span><span class="i">s</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">string</span><span class="h"> </span><span class="v">T</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">preProcess</span><span class="sy">(</span><span class="i">s</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">n</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">T</span><span class="sy">.</span><span class="e">length</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="o">*</span><span class="v">P</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="r">new</span><span class="h"> </span><span class="t">int</span><span class="sy">[</span><span class="i">n</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">C</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="v">R</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">i_mirror</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">2</span><span class="o">*</span><span class="i">C</span><span class="o">-</span><span class="i">i</span><span class="sy">;</span><span class="h"> </span><span class="c">// equals to i' = C - (i-C)</span></p>
<p><span class="h">    </span></p>
<p><span class="h">    </span><span class="v">P</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="i">R</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">i</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="e">min</span><span class="sy">(</span><span class="i">R</span><span class="o">-</span><span class="i">i</span><span class="sy">,</span><span class="h"> </span><span class="v">P</span><span class="sy">[</span><span class="i">i_mirror</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">    </span></p>
<p><span class="h">    </span><span class="c">// Attempt to expand palindrome centered at i</span></p>
<p><span class="h">    </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="v">T</span><span class="sy">[</span><span class="i">i</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="v">P</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="v">T</span><span class="sy">[</span><span class="i">i</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="v">P</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">]</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">P</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="o">++</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">    </span><span class="c">// If palindrome centered at i expand past R,</span></p>
<p><span class="h">    </span><span class="c">// adjust center based on expanded palindrome.</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">i</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="v">P</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">R</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">C</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">i</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">R</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="v">P</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p> </p>
<p><span class="h">  </span><span class="c">// Find the maximum element in P.</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">maxLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">centerIndex</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">P</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">maxLen</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">maxLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">P</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">centerIndex</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">i</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="v">delete</span><span class="sy">[</span><span class="sy">]</span><span class="h"> </span><span class="i">P</span><span class="sy">;</span></p>
<p><span class="h">  </span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">substr</span><span class="sy">(</span><span class="sy">(</span><span class="i">centerIndex</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">maxLen</span><span class="sy">)</span><span class="o">/</span><span class="cn">2</span><span class="sy">,</span><span class="h"> </span><span class="i">maxLen</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**<span>Note:</span>**  
 This algorithm is definitely non-trivial and you won’t be expected to
come up with such algorithm during an interview setting. However, I do
hope that you enjoy reading this article and hopefully it helps you in
understanding this interesting algorithm. You deserve a pat if you have
gone this far!
![:)](http://leetcode.com/wp-includes/images/smilies/icon_smile.gif)

**<span>Further Thoughts:</span>**

-   In fact, there exists a sixth solution to this problem — Using
    suffix trees. However, it is not as efficient as this one (run time
    O(N log N) and more overhead for building suffix trees) and is more
    complicated to implement. If you are interested, read Wikipedia’s
    article about [Longest Palindromic
    Substring](http://en.wikipedia.org/wiki/Longest_palindromic_substring).
-   What if you are required to find the longest palindromic
    subsequence? (Do you know the difference between substring and
    subsequence?)

**<span>Useful Links:</span>**  
 » [Manacher’s Algorithm O(N)
时间求字符串的最长回文子串](http://www.felix021.com/blog/read.php?2040)
(Best explanation if you can read Chinese)  
 » [A simple linear time algorithm for finding longest palindrome
sub-string](http://zhuhongcheng.wordpress.com/2009/08/02/a-simple-linear-time-algorithm-for-finding-longest-palindrome-sub-string/)  
 » [Finding
Palindromes](http://johanjeuring.blogspot.com/2007/08/finding-palindromes.html)  
 » [Finding the Longest Palindromic Substring in Linear
Time](http://www.akalin.cx/longest-palindrome-linear-time)  
 » [Wikipedia: Longest Palindromic
Substring](http://en.wikipedia.org/wiki/Longest_palindromic_substring)

VN:F [1.9.22\_1171]

Rating: 4.8/**5** (121 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Longest Palindromic Substring Part II</span></span>, <span
class="rating"><span class="average">4.8</span> out of <span
class="best">5</span> based on <span class="votes">121</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2011/11/longest-palindromic-substring-part-ii.html>

### Leave a reply

### 24 trackbacks

-   *on November 20, 2011*
-   *on January 4, 2012*
-   *on August 16, 2012*
-   *on October 27, 2012*
-   *on February 25, 2013*
-   *on June 5, 2013*
-   *on October 28, 2013*
-   *on November 8, 2013*
-   *on November 9, 2013*
-   *on January 12, 2014*
-   *on February 5, 2014*
-   *on February 7, 2014*
-   *on April 21, 2014*
-   *on May 9, 2014*
-   *on May 9, 2014*
-   *on September 5, 2014*
-   *on September 18, 2014*
-   *on September 25, 2014*
-   *on November 10, 2014*
-   *on December 31, 2014*
-   *on January 8, 2015*
-   *on February 16, 2015*
-   *on February 18, 2015*
-   *on February 18, 2015*

> Given a string, find the length of the longest substring without
> repeating characters. For example, the longest substring without
> repeating letters for “abcabcbb” is “abc”, which the length is 3. For
> “bbbbb” the longest substring is “b”, with the length of 1.

<span id="more-753"></span>  
 **Hint:**  
 Is there a better way other than brute force? Consider the kind of data
structure that can improve the run time complexity. An ideal solution
requires only a one-time linear scan.

**<span>Online Judge</span>**  
 This problem is available at [Online
Judge](http://www.leetcode.com/onlinejudge). [Head over
there](http://www.leetcode.com/onlinejudge) and it will judge your
solution. Currently only able to compile C++ code. If you are using
other languages, you can still verify your solution by looking at the
judge’s test cases and its expected output.

**Solution:**  
 How can we can look up if a character had existed in the substring
instantaneously? The answer is using a simple table to store the
characters that have appeared. Make sure you communicate with your
interviewer if the string can have characters other than ‘a’-'z’. (ie,
Digits? Upper case letter? Does it contain ASCII characters only? Or
even unicode character sets?)

As you traverse through the string, update by using its ASCII value as
index to the table. If the string only contains ‘a’-'z’, you could save
space by using a table of size 26 only. Assuming c is the character,
then c-’a’ will give you a value of 0-25 which can be used to index the
table directly.

The next question is to ask yourself what happens when you found a
repeated character? For example, if the string is “abcdcedf”, what
happens when you reach the second appearance of ‘c’?

When you have found a repeated character (let’s say at index *j*), it
means that the current substring (excluding the repeated character of
course) is a potential maximum, so update the maximum if necessary. It
also means that the repeated character must have appeared before at an
index *i*, where *i* is less than *j*.

Since you know that all substrings that start before or at index *i*
would be less than your current maximum, you can safely start to look
for the next substring with head which starts exactly at index *i*+1.

Therefore, you would need two indices to record the head and the tail of
the current substring. Since i and j both traverse at most *n* steps,
the worst case would be 2*n* steps, which the run time complexity must
be O(*n*).

Below is the implementation in C++. Beware of the common mistake of not
updating the maximum after the main loop, which is easy to forget.

int lengthOfLongestSubstring(string s) { int n = s.length(); int i = 0,
j = 0; int maxLen = 0; bool exist[256] = { false }; while (j \< n) { if
(exist[s[j]]) { maxLen = max(maxLen, j-i); while (s[i] != s[j]) {
exist[s[i]] = false; i++; } i++; j++; } else { exist[s[j]] = true; j++;
} } maxLen = max(maxLen, n-i); return maxLen; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">lengthOfLongestSubstring</span><span class="sy">(</span><span class="t">string</span><span class="h"> </span><span class="i">s</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">n</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">length</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">maxLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">bool</span><span class="h"> </span><span class="v">exist</span><span class="sy">[</span><span class="cn">256</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">{</span><span class="h"> </span><span class="t">false</span><span class="h"> </span><span class="sy">}</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">j</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">exist</span><span class="sy">[</span><span class="v">s</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">maxLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">max</span><span class="sy">(</span><span class="i">maxLen</span><span class="sy">,</span><span class="h"> </span><span class="i">j</span><span class="o">-</span><span class="i">i</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="v">s</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="v">s</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">exist</span><span class="sy">[</span><span class="v">s</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="i">i</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span></p>
<p><span class="h">      </span><span class="i">i</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="i">j</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">exist</span><span class="sy">[</span><span class="v">s</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="i">j</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="v">maxLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">max</span><span class="sy">(</span><span class="i">maxLen</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="i">i</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">maxLen</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.5/**5** (73 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Longest Substring Without Repeating Characters</span></span>,
<span class="rating"><span class="average">4.5</span> out of <span
class="best">5</span> based on <span class="votes">73</span> ratings
<span class="summary"></span></span></span>

> Given a binary search tree (BST), find the lowest common ancestor of
> two given nodes in the BST.

<span id="more-782"></span>  

            _______6______
           /              \
        ___2__          ___8__
       /      \        /      \
       0      _4       7       9
             /  \
             3   5

Using the above tree as an example, the lowest common ancestor (LCA) of
nodes <span>2</span> and <span>8</span> is <span>6</span>. But how about
LCA of nodes <span>2</span> and <span>4</span>? Should it be
<span>6</span> or <span>2</span>?

According to the [definition of LCA on
Wikipedia](http://en.wikipedia.org/wiki/Least_common_ancestor): “The
lowest common ancestor is defined between two nodes *v* and *w* as the
lowest node in T that has both *v* and *w* as descendants (where we
allow a node to be a descendant of itself).” Since a node can be a
descendant of itself, the LCA of <span>2</span> and <span>4</span>
should be <span>2</span>, according to this definition.

**Hint:**  
 A top-down walk from the root of the tree is enough.

**Solution:**  
 There’s only three cases you need to consider.

1.  Both nodes are to the left of the tree.
2.  Both nodes are to the right of the tree.
3.  One node is on the left while the other is on the right.

For case 1), the LCA must be in its left subtree. Similar with case 2),
LCA must be in its right subtree. For case 3), the current node must be
the LCA.

Therefore, using a top-down approach, we traverse to the left/right
subtree depends on the case of 1) or 2), until we reach case 3), which
we concludes that we have found the LCA.

A careful reader might notice that we forgot to handle one extra case.
What if the node itself is equal to one of the two nodes? This is the
exact case from our earlier example! (The LCA of <span>2</span> and
<span>4</span> should be <span>2</span>). Therefore, we add case number
4):

4. When the current node equals to either of the two nodes, this node
must be the LCA too.

The run time complexity is O(*h*), where *h* is the height of the BST.
Translating this idea to code is straightforward (Note that we handle
case 3) and 4) in the else statement to save us some extra typing
![;)](http://leetcode.com/wp-includes/images/smilies/icon_wink.gif) ):

Node \*LCA(Node \*root, Node \*p, Node \*q) { if (!root || !p || !q)
return NULL; if (max(p-\>data, q-\>data) \< root-\>data) return
LCA(root-\>left, p, q); else if (min(p-\>data, q-\>data) \> root-\>data)
return LCA(root-\>right, p, q); else return root; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="e">Node *</span><span class="e">LCA</span><span class="sy">(</span><span class="e">Node *</span><span class="i">root</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="i">q</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">root</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="o">!</span><span class="i">p</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="o">!</span><span class="i">q</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="e">max</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">,</span><span class="h"> </span><span class="i">q</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">root</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">LCA</span><span class="sy">(</span><span class="i">root</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="e">min</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">,</span><span class="h"> </span><span class="i">q</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">)</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">root</span><span class="o">-&gt;</span><span class="i">data</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">LCA</span><span class="sy">(</span><span class="i">root</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">else</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="i">root</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

You should realize quickly that the above code contains tail recursion.
Converting the above function to an iterative one is left as an exercise
to the reader.

**<span>Further Thoughts</span>**:  
 What if you are required to find the LCA of a binary tree (not a BST)?
Check out my next post: [Lowest Common Ancestor of a Binary Tree Part
I](http://www.leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-tree-part-i.html)
to find out how.

VN:F [1.9.22\_1171]

Rating: 4.8/**5** (41 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Lowest Common Ancestor of a Binary Search Tree
(BST)</span></span>, <span class="rating"><span
class="average">4.8</span> out of <span class="best">5</span> based on
<span class="votes">41</span> ratings <span
class="summary"></span></span></span>

> Given a binary tree, find the lowest common ancestor of two given
> nodes in the tree.

<span id="more-790"></span>  

            _______3______
           /              \
        ___5__          ___1__
       /      \        /      \
       6      _2       0       8
             /  \
             7   4

If you are not so sure about the definition of lowest common ancestor
(LCA), please refer to my previous post: [Lowest Common Ancestor of a
Binary Search Tree
(BST)](http://www.leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-search-tree.html)
or the definition of LCA
[here](http://en.wikipedia.org/wiki/Lowest_common_ancestor). Using the
tree above as an example, the LCA of nodes **<span>5</span>** and
**<span>1</span>** is **<span>3</span>**. Please note that LCA for nodes
**<span>5</span>** and **<span>4</span>** is **<span>5</span>**.

**Hint:**  
 Top-down or bottom-up? Consider both approaches and see which one is
more efficient.

**A Top-Down Approach (Worst case O(n<sup>2</sup>) ):**  
 Let’s try the top-down approach where we traverse the nodes from the
top to the bottom. First, if the current node is one of the two nodes,
it must be the LCA of the two nodes. If not, we count the number of
nodes that matches either p or q in the left subtree (which we call
*totalMatches*). If *totalMatches* equals 1, then we know the right
subtree will contain the other node. Therefore, the current node must be
the LCA. If *totalMatches* equals 2, we know that both nodes are
contained in the left subtree, so we traverse to its left child. Similar
with the case where *totalMatches* equals 0 where we traverse to its
right child.

// Return \#nodes that matches P or Q in the subtree. int
countMatchesPQ(Node \*root, Node \*p, Node \*q) { if (!root) return 0;
int matches = countMatchesPQ(root-\>left, p, q) +
countMatchesPQ(root-\>right, p, q); if (root == p || root == q) return
1 + matches; else return matches; } Node \*LCA(Node \*root, Node \*p,
Node \*q) { if (!root || !p || !q) return NULL; if (root == p || root ==
q) return root; int totalMatches = countMatchesPQ(root-\>left, p, q); if
(totalMatches == 1) return root; else if (totalMatches == 2) return
LCA(root-\>left, p, q); else /\* totalMatches == 0 \*/ return
LCA(root-\>right, p, q); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="c">// Return #nodes that matches P or Q in the subtree.</span></p>
<p><span class="t">int</span><span class="h"> </span><span class="e">countMatchesPQ</span><span class="sy">(</span><span class="e">Node *</span><span class="i">root</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="i">q</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">matches</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">countMatchesPQ</span><span class="sy">(</span><span class="i">root</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="e">countMatchesPQ</span><span class="sy">(</span><span class="i">root</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">root</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">p</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="v">root</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="cn">1</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="i">matches</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">else</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="i">matches</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="e">Node *</span><span class="e">LCA</span><span class="sy">(</span><span class="e">Node *</span><span class="i">root</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="i">q</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">root</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="o">!</span><span class="i">p</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="o">!</span><span class="i">q</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">root</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">p</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="v">root</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="i">root</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">totalMatches</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">countMatchesPQ</span><span class="sy">(</span><span class="i">root</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">totalMatches</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="i">root</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">totalMatches</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">2</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">LCA</span><span class="sy">(</span><span class="i">root</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">else</span><span class="h"> </span><span class="c">/* totalMatches == 0 */</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">LCA</span><span class="sy">(</span><span class="i">root</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

What is the run time complexity of this top-down approach?

First, just for fun, we assume that the tree contains *n* nodes and is
balanced (with its height equals to log(*n*) ). In this case, the run
time complexity would be O(*n*). Most people would guess a higher
ordered complexity than O(*n*) due to the function *countMatchesPQ*()
traverses the same nodes over and over again. Notice that the tree is
balanced, you cut off half of the nodes you need to traverse in each
recursive call of *LCA*() function. The proof that the complexity is
indeed O(*n*) is left as an exercise to the reader.

What if the tree is not necessarily balanced? Then in the worst case the
complexity could go up to O(*n*<sup>2</sup>). Why? Could you come up
with such case? (Hint: The tree might be a degenerate tree).

**A Bottom-up Approach (Worst case O(*n*) ):  
** Using a bottom-up approach, we can improve over the top-down approach
by avoiding traversing the same nodes over and over again.

We traverse from the bottom, and once we reach a node which matches one
of the two nodes, we pass it up to its parent. The parent would then
test its left and right subtree if each contain one of the two nodes. If
yes, then the parent must be the LCA and we pass its parent up to the
root. If not, we pass the lower node which contains either one of the
two nodes (if the left or right subtree contains either p or q), or NULL
(if both the left and right subtree does not contain either p or q) up.

Sounds complicated? Surprisingly the code appears to be much simpler
than the top-down one.

Node \*LCA(Node \*root, Node \*p, Node \*q) { if (!root) return NULL; if
(root == p || root == q) return root; Node \*L = LCA(root-\>left, p, q);
Node \*R = LCA(root-\>right, p, q); if (L && R) return root; // if p and
q are on both sides return L ? L : R; // either one of p,q is on one
side OR p,q is not in L&R subtrees }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="e">Node *</span><span class="e">LCA</span><span class="sy">(</span><span class="e">Node *</span><span class="i">root</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="i">q</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">root</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">p</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="v">root</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="i">root</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Node *</span><span class="v">L</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">LCA</span><span class="sy">(</span><span class="i">root</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Node *</span><span class="v">R</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">LCA</span><span class="sy">(</span><span class="i">root</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">L</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">R</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="i">root</span><span class="sy">;</span><span class="h">  </span><span class="c">// if p and q are on both sides</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">L</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="i">L</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="i">R</span><span class="sy">;</span><span class="h">  </span><span class="c">// either one of p,q is on one side OR p,q is not in L&amp;R subtrees</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Notes:  
** The LCA problem had been studied extensively by many computer
scientists. There exists efficient algorithms for finding LCA in
constant time after initial processing of the tree in linear time. For
the adventurous reader, please read this article for more details:
[Range Minimum Query and Lowest Common Ancestor in
Topcoder](http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=lowestCommonAncestor).

**<span>Further Thoughts</span>**:  
 What if each node in the binary tree has a link to its parent? Could
you devise a non-recursive approach without using extra space?

**<span>» Continue reading</span> [Lowest Common Ancestor of a Binary
Tree Part
II.](http://www.leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-tree-part-ii.html)**

VN:F [1.9.22\_1171]

Rating: 4.6/**5** (77 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Lowest Common Ancestor of a Binary Tree Part I</span></span>,
<span class="rating"><span class="average">4.6</span> out of <span
class="best">5</span> based on <span class="votes">77</span> ratings
<span class="summary"></span></span></span>

> Given a binary tree, find the lowest common ancestor of two given
> nodes in the tree. Each node contains a parent pointer which links to
> its parent.

<span id="more-797"></span>  
 **<span>Note:</span>**  
 This is Part II of Lowest Common Ancestor of a Binary Tree. If you need
to find the lowest common ancestor without parent pointers, please read
[Lowest Common Ancestor of a Binary Tree Part
I](http://www.leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-tree-part-i.html).  

            _______3______
           /              \
        ___5__          ___1__
       /      \        /      \
       6      _2       0       8
             /  \
             7   4

If you are not so sure about the definition of lowest common ancestor
(LCA), please refer to my previous post: [Lowest Common Ancestor of a
Binary Search Tree
(BST)](http://www.leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-search-tree.html)
or the definition of LCA
[here](http://en.wikipedia.org/wiki/Lowest_common_ancestor). Using the
tree above as an example, the LCA of nodes <span>5</span> and
<span>1</span> is <span>3</span>. Please note that LCA for nodes
<span>5</span> and <span>4</span> is <span>5</span>.

In my last post: [Lowest Common Ancestor of a Binary Tree Part
I](http://www.leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-tree-part-i.html),
we have devised a recursive solution which finds the LCA in O(*n*) time.
If each node has a pointer that link to its parent, could we devise a
better solution?

**Hint:**  
 No recursion is needed. There is an easy solution which uses extra
space. Could you eliminate the need of extra space?

**An easy solution**:**  
 As we trace the two paths from both nodes up to the root, eventually it
will merge into one single path. The LCA is the exact first intersection
node where both paths merged into a single path. An easy solution is to
use a hash table which records visited nodes as we trace both paths up
to the root. Once we reached the first node which is already marked as
visited, we immediately return that node as the LCA.

Node \*LCA(Node \*root, Node \*p, Node \*q) { hash\_set\<Node \*\>
visited; while (p || q) { if (p) { if (!visited.insert(p).second) return
p; // insert p failed (p exists in the table) p = p-\>parent; } if (q) {
if (!visited.insert(q).second) return q; // insert q failed (q exists in
the table) q = q-\>parent; } } return NULL; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="e">Node *</span><span class="e">LCA</span><span class="sy">(</span><span class="e">Node *</span><span class="i">root</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="i">q</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="i">hash_set</span><span class="o">&lt;</span><span class="e">Node *</span><span class="o">&gt;</span><span class="h"> </span><span class="i">visited</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">p</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">visited</span><span class="sy">.</span><span class="e">insert</span><span class="sy">(</span><span class="i">p</span><span class="sy">)</span><span class="sy">.</span><span class="i">second</span><span class="sy">)</span></p>
<p><span class="h">        </span><span class="st">return</span><span class="h"> </span><span class="i">p</span><span class="sy">;</span><span class="h"> </span><span class="c">// insert p failed (p exists in the table)</span></p>
<p><span class="h">      </span><span class="v">p</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="r">parent</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">q</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">visited</span><span class="sy">.</span><span class="e">insert</span><span class="sy">(</span><span class="i">q</span><span class="sy">)</span><span class="sy">.</span><span class="i">second</span><span class="sy">)</span></p>
<p><span class="h">        </span><span class="st">return</span><span class="h"> </span><span class="i">q</span><span class="sy">;</span><span class="h"> </span><span class="c">// insert q failed (q exists in the table)</span></p>
<p><span class="h">      </span><span class="v">q</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">q</span><span class="o">-&gt;</span><span class="r">parent</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

The run time complexity of this approach is O(*h*), where *h* is the
tree’s height. The space complexity is also O(*h*), since it can mark at
most 2*h* nodes.

**The best solution:  
** A little creativity is needed here. Since we have the parent pointer,
we could easily get the distance (height) of both nodes from the root.
Once we knew both heights, we could subtract from one another and get
the height’s difference (*dh*). If you observe carefully from the
previous solution, the node which is closer to the root is always *dh*
steps ahead of the deeper node. We could eliminate the need of marking
visited nodes altogether. Why?

The reason is simple, if we advance the deeper node *dh* steps above,
both nodes would be at the same depth. Then, we advance both nodes one
level at a time. They would then eventually intersect at one node, which
is the LCA of both nodes. If not, one of the node would eventually reach
NULL (root’s parent), which we conclude that both nodes are not in the
same tree. However, that part of code shouldn’t be reached, since the
problem statement assumed that both nodes are in the same tree.

int getHeight(Node \*p) { int height = 0; while (p) { height++; p =
p-\>parent; } return height; } // As root-\>parent is NULL, we don't
need to pass root in. Node \*LCA(Node \*p, Node \*q) { int h1 =
getHeight(p); int h2 = getHeight(q); // swap both nodes in case p is
deeper than q. if (h1 \> h2) { swap(h1, h2); swap(p, q); } // invariant:
h1 \<= h2. int dh = h2 - h1; for (int h = 0; h \< dh; h++) q =
q-\>parent; while (p && q) { if (p == q) return p; p = p-\>parent; q =
q-\>parent; } return NULL; // p and q are not in the same tree }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">getHeight</span><span class="sy">(</span><span class="e">Node *</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">height</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">height</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">p</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="r">parent</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">height</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="c">// As root-&gt;parent is NULL, we don't need to pass root in.</span></p>
<p><span class="e">Node *</span><span class="e">LCA</span><span class="sy">(</span><span class="e">Node *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="i">q</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">h1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">getHeight</span><span class="sy">(</span><span class="i">p</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">h2</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">getHeight</span><span class="sy">(</span><span class="i">q</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="c">// swap both nodes in case p is deeper than q.</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">h1</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">h2</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="e">swap</span><span class="sy">(</span><span class="i">h1</span><span class="sy">,</span><span class="h"> </span><span class="i">h2</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="e">swap</span><span class="sy">(</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="c">// invariant: h1 &lt;= h2.</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">dh</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">h2</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">h1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">h</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">h</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">dh</span><span class="sy">;</span><span class="h"> </span><span class="i">h</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="v">q</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">q</span><span class="o">-&gt;</span><span class="r">parent</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">p</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">p</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">q</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="i">p</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">p</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="r">parent</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">q</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">q</span><span class="o">-&gt;</span><span class="r">parent</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span><span class="h">  </span><span class="c">// p and q are not in the same tree</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**<span>Further Thoughts</span>**:  
 Isn’t the solution above neat? It requires some creative thought and is
quite subtle.

A variation of this problem which seemed to be more popular is:

> Given two singly linked lists and they both intersect at one point
> (ie, forming a Y shaped list). Find where the two linked lists merge.

I am sure you know how to answer this question now
![:)](http://leetcode.com/wp-includes/images/smilies/icon_smile.gif)

VN:F [1.9.22\_1171]

Rating: 4.8/**5** (63 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Lowest Common Ancestor of a Binary Tree Part
II</span></span>, <span class="rating"><span class="average">4.8</span>
out of <span class="best">5</span> based on <span
class="votes">63</span> ratings <span
class="summary"></span></span></span>

> Given a binary tree, find its maximum height.

<span id="more-19"></span>  
The maximum height of a binary tree is defined as the number of nodes
along the path from the root node to the deepest leaf node. Note that
the maximum height of an empty tree is 0.

**Recursive Solution:**  
We can solve this easily using recursion. Why? Because each of the
leftChild and rightChild of a node is a sub-tree itself. We first
compute the max height of left sub-tree, then compute the max height of
right sub-tree. Therefore, the max height of the current node is the
greater of the two max heights + 1. For the base case, the current node
is NULL, we return zero. NULL signifies there is no tree, therefore its
max height is zero.

int maxHeight(BinaryTree \*p) { if (!p) return 0; int left\_height =
maxHeight(p-\>left); int right\_height = maxHeight(p-\>right); return
(left\_height \> right\_height) ? left\_height + 1 : right\_height + 1;
}
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">maxHeight</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">left_height</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">maxHeight</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">right_height</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">maxHeight</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="i">left_height</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">right_height</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="i">left_height</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="i">right_height</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Further Thoughts:**  
The recursive solution is pretty neat, right? Here’s a challenge: How
about finding an iterative solution for maxHeight()? How would you
approach this problem?

[![](http://4.bp.blogspot.com/_UElib2WLeDE/TK0MjC3-MKI/AAAAAAAACWc/u_JaQ0YhoU4/s400/yahoo_small.png)](http://4.bp.blogspot.com/_UElib2WLeDE/TK0MjC3-MKI/AAAAAAAACWc/u_JaQ0YhoU4/s1600/yahoo_small.png)

Binary-tree visualization of the Yahoo search engine bot crawling the
experimental website. The total number of nodes grow with an exponential
rate as the tree deepens. The animated version showing the tree growing
over the year can be found
[here](http://drunkmenworkhere.org/219.php?a=yahoo)
(<span>Warning</span>: large file size, <span>13MB</span>).

**Hint:**  
Read my post: [Binary Search Tree In-Order Traversal Iterative
Solution](http://www.leetcode.com/2010/04/binary-search-tree-in-order-traversal.html).
This should give you enough hints to get started.

**Iterative Solution:**  
We could apply the same [in-order
traversal](http://www.leetcode.com/2010/04/binary-search-tree-in-order-traversal.html)
of a BST in the binary tree. By saying “in-order” traversal I mean
traversing the tree such that it reaches the leaf first (deepest). In
other words, we are doing a [Depth-first
Search](http://en.wikipedia.org/wiki/Depth-first_search) (DFS). In fact,
all three kinds of tree traversal (pre-order, in-order, and post-order)
are doing DFS. Therefore, we could modify any existing iterative
solution of tree traversals to solve this problem.

As pre-order and in-order iterative traversals are easier to implement,
your best bet is to code either one of them during an interview session.
As we traverse the tree, we would keep track of the current depth and
record each node’s depth, so that we know which depth we are in when we
return to the node at a later time. (In pre-order or in-order
traversals, it might return several levels above the current level when
a node is popped off the stack).

On the other hand, [post-order
traversal](http://www.leetcode.com/2010/10/binary-tree-post-order-traversal.html)
guarantees to return exactly one level above a node that is popped off
the stack. Therefore, we could devise a solution utilizing post-order
traversal without modifying the existing tree structure. We keep track
of the current depth and update the maximum depth as we traverse the
tree.

Another solution is to utilize [Breadth-first
Search](http://en.wikipedia.org/wiki/Breadth-first_search) (BFS). Unlike
DFS, we traverse the tree level by level, thus we are able to obtain the
max depth in a direct manner. Read my post: [Printing a Binary Tree in
Level
Order](http://www.leetcode.com/2010/09/printing-binary-tree-in-level-order.html)
for more information.

Below is the code for finding the maximum depth of a binary tree using
[post-order
traversal](http://www.leetcode.com/2010/10/binary-tree-post-order-traversal.html),
without recursion.

int maxDepthIterative(BinaryTree \*root) { if (!root) return 0;
stack\<BinaryTree\*\> s; s.push(root); int maxDepth = 0;
BinaryTree \*prev = NULL; while (!s.empty()) { BinaryTree \*curr =
s.top(); if (!prev || prev-\>left == curr || prev-\>right == curr) { if
(curr-\>left) s.push(curr-\>left); else if (curr-\>right)
s.push(curr-\>right); } else if (curr-\>left == prev) { if
(curr-\>right) s.push(curr-\>right); } else { s.pop(); } prev = curr; if
(s.size() \> maxDepth) maxDepth = s.size(); } return maxDepth; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">maxDepthIterative</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">stack</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="h"> </span><span class="i">s</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">root</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">maxDepth</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">BinaryTree *</span><span class="v">prev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">s</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="e">BinaryTree *</span><span class="v">curr</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">prev</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">prev</span><span class="o">-&gt;</span><span class="v">left</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">curr</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">prev</span><span class="o">-&gt;</span><span class="v">right</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">curr</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="v">left</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">prev</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span></p>
<p><span class="h">        </span><span class="v">s</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">s</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="v">prev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">curr</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">s</span><span class="sy">.</span><span class="e">size</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">maxDepth</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">maxDepth</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">s</span><span class="sy">.</span><span class="e">size</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">maxDepth</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 3.9/**5** (47 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Maximum Height (Depth) of a Binary Tree</span></span>, <span
class="rating"><span class="average">3.9</span> out of <span
class="best">5</span> based on <span class="votes">47</span> ratings
<span class="summary"></span></span></span>

> There are two sorted arrays A and B of size *m* and *n* respectively.
> Find the median of the two sorted arrays. The overall run time
> complexity should be *O*(log (*m*+*n*)).

<span id="more-463"></span>  
 **<span>Note:</span>**  
 Please head over to this [MIT
handout](http://www2.myoops.org/course_material/mit/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/30C68118-E436-4FE3-8C79-6BAFBB07D935/0/ps9sol.pdf)
for a much better solution, although their solution does not deal with
some special cases, which is easy to fix. Please consult [Sophie’s
solution](http://www.leetcode.com/2011/03/median-of-two-sorted-arrays.html#comment-1053)
which fixes these special cases easily. Although my solution below
works, it is too complicated.

**<span>Online Judge</span>**  
 This problem is available at [Online
Judge](http://www.leetcode.com/onlinejudge). [Head over
there](http://www.leetcode.com/onlinejudge) and it will judge your
solution. Currently only able to compile C++ code. If you are using
other languages, you can still verify your solution by looking at the
judge’s test cases and its expected output.

**Solution:**  
 If you search this problem on
[Google](http://www.google.com/search?q=median+of+two+sorted+arrays&ie=utf-8&oe=utf-8&aq=t&rls=org.mozilla:en-US:official&client=firefox-a),
you will find tons of hits. However, most of them deal with the special
case where m == n, and even so their code are [filled with
bugs](http://geeksforgeeks.org/?p=2105). The
[CLRS](http://www.amazon.com/Introduction-Algorithms-CD-Rom-Thomas-Cormen/dp/0072970545/ref=sr_1_1?ie=UTF8&qid=1301046297&sr=8-1)
book has this problem as exercise in section 9.3-8, however it also
assumes the case where *m* == *n*. [The only reliable
solution](http://www2.myoops.org/course_material/mit/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/30C68118-E436-4FE3-8C79-6BAFBB07D935/0/ps9sol.pdf)
I found on the web which deals with the generic case also seemed
incorrect, as their definition of the median is the single middle
element (although their approach of using binary search is pretty neat).
According to the definition of the
[median](http://en.wikipedia.org/wiki/Median), if (*m* + *n*) is even,
then the median should be the mean of the two middle numbers.

If you read my previous post: [Find the k-th Smallest Element in the
Union of Two Sorted
Arrays](http://www.leetcode.com/2011/01/find-k-th-smallest-element-in-union-of.html),
you know that this problem is somewhat similar. In fact, the problem of
finding the median of two sorted arrays when (*m* + *n*) is odd can be
thought of solving the special case where k=(*m*+*n*)/2. Although we can
still apply the finding k-th smallest algorithm twice to find the two
middle numbers when (*m* + *n*) is even, it is no more a desirable
solution due to inefficiency.

You might ask: Why not adapt the previous solution to this problem?
After all, the previous algorithm solves a more general case. Well, I’ve
tried that and I didn’t consider the previous solution is easily
adaptable to this problem. The main reason is because when (*m* + *n*)
is even, the two middle elements might be located in the same array.
This complicates the algorithm and many special cases have to be dealt
in a case by case basis.

Similar to finding the k-th smallest, the divide and conquer method is a
natural approach to this problem. First, we choose A<sub>i</sub> and
B<sub>j</sub> (the middle elements of A and B) where i and j are defined
as m/2 and n/2. We made an observation that if A<sub>i</sub> j, then the
median must be somewhere between A<sub>i</sub> and B<sub>j</sub>
(inclusive). Therefore, we could dispose a total of *i* elements from
left of Ai and a total of n-j-1 elements to the right of B<sub>j</sub>.
Please take extra caution not to dispose A<sub>i</sub> or B<sub>j</sub>,
as we might need two middle values to calculate the median (it might
also be possible that the two middle values are both in the same array).
The case where A<sub>i</sub> \> B<sub>j</sub> is similar.

[![](http://www.leetcode.com/wp-content/uploads/2011/03/twoarrays.gif)](http://www.leetcode.com/wp-content/uploads/2011/03/twoarrays.gif)<span>Two
sorted arrays A and B. i is chosen as m/2 and j is chosen as n/2.
A<sub>i</sub> and B<sub>j</sub> are middle elements of A and B. If
A<sub>i</sub> j, then the median must be between A<sub>i</sub> and
B<sub>j</sub> (inclusive). Similarly with the opposite.</span>

The main idea illustrated above is mostly right, however there is one
more important invariant we have to maintain. It is entirely possible
that the number of elements being disposed from each array is different.
Look at the example above: If A<sub>i</sub> j, two elements to the left
of A<sub>i</sub> and three elements to the right of B<sub>j</sub> are
being disposed. Notice that this is no longer a valid sub-problem, as
both sub-array’s median is no longer the original median.

Therefore, an important invariant we have to maintain is:

    The number of elements being disposed from each array must be the same.

This could be easily achieved by choosing the number of elements to
dispose from each array to be (**<span>Warning</span>**: The below
condition fails to handle an edge case, for more details see the
**<span>EDIT</span>** section below):

    k = min(i, n-j-1) when Ai j.                   1(a)
    k = min(m-i-1, j) when Ai > Bj.                    1(b)

Figuring out how to subdivide the problem is actually the easy part. The
hard part is figuring out the base case. (ie, when should we stop
subdividing?)

It is obvious that when *m*=1 or *n*=1, you must treat it as a special
base case, or else it would end up in an infinite loop. The hard part is
reasoning why *m*=2 or *n*=2 requires special case handling as well.
(Hint: The two middle elements might be in the same array.)

Finally, implementing the above idea turns out to be an extremely tricky
coding exercise. Before looking at the solution below, try to challenge
yourself by coding the algorithm.

If you have a more elegant code to this problem, I would love to hear
from you!

**<span><span>EDIT:</span></span>**  
 Thanks to
[Algorist](http://www.leetcode.com/2011/03/median-of-two-sorted-arrays.html#comment-674)
for being the first person who points out a bug. (For more details, read
[his
comment](http://www.leetcode.com/2011/03/median-of-two-sorted-arrays.html#comment-674)).
The bug is caused by some edge cases that are not handled in the base
case.

Shortly after I fixed that bug, I discovered another edge case myself
which my previous code failed to handle.

An example of one of the edge cases is:

    A = { 1, 2, 4, 8, 9, 10 }
    B = { 3, 5, 6, 7 }

The above conditions ( **1(a)**, **1(b)** ) fails to handle the above
edge case, which returns **5** as the median while the correct answer
should be **5.5**.

The reason is because the number 5 is discarded in the first iteration,
while it should be considered in the final evaluation step of the
median. To resolve this edge case, we have to be careful not to discard
the neighbor element when its size is even. Here are the corrected
condition**s ( **2(a)**, **2(b)**, **2(c)**, **2(d)** ) for *k* which
resolves this edge case.

    k = min(i-1, n-j-1) when Ai j and m is even.   2(a)
    k = min(i, n-j-1)   when Ai j and m is odd.    2(b)
    k = min(m-i-1, j-1) when Ai > Bj  and n is even.   2(c)
    k = min(m-i-1, j)   when Ai > Bj  and n is odd.    2(d)

Below is the bug-free code after going through a lengthy rigorous
testing of all possible edge cases. (Not for the faint of heart!)

double findMedianBaseCase(int med, int C[], int n) { if (n == 1) return
(med+C[0])/2.0; if (n % 2 == 0) { int a = C[n/2 - 1], b = C[n/2]; if
(med \<= a) return a; else if (med \<= b) return med; else /\* med \>
b \*/ return b; } else { int a = C[n/2 - 1], b = C[n/2], c = C[n/2 + 1];
if (med \<= a) return (a+b) / 2.0; else if (med \<= c) return (med+b) /
2.0; else /\* med \> c \*/ return (b+c) / 2.0; } } double
findMedianBaseCase2(int med1, int med2, int C[], int n) { if (n % 2 ==
0) { int a = (((n/2-2) \>= 0) ? C[n/2 - 2] : INT\_MIN); int b = C[n/2 -
1], c = C[n/2]; int d = (((n/2 + 1) \<= n-1) ? C[n/2 + 1] : INT\_MAX);
if (med2 \<= b) return (b+max(med2,a)) / 2.0; else if (med1 \<= b)
return (b+min(med2,c)) / 2.0; else if (med1 \>= c) return
(c+min(med1,d)) / 2.0; else if (med2 \>= c) return (c+max(med1,b)) /
2.0; else /\* a \< med1 \<= med2 \< b \*/ return (med1+med2) / 2.0; }
else { int a = C[n/2 - 1], b = C[n/2], c = C[n/2 + 1]; if (med1 \>= b)
return min(med1, c); else if (med2 \<= b) return max(med2, a); else /\*
med1 \< b \< med2 \*/ return b; } } double findMedianSingleArray(int
A[], int n) { assert(n \> 0); return ((n%2 == 1) ? A[n/2] :
(A[n/2-1]+A[n/2])/2.0); } double findMedianSortedArrays(int A[], int m,
int B[], int n) { assert(m+n \>= 1); if (m == 0) return
findMedianSingleArray(B, n); else if (n == 0) return
findMedianSingleArray(A, m); else if (m == 1) return
findMedianBaseCase(A[0], B, n); else if (n == 1) return
findMedianBaseCase(B[0], A, m); else if (m == 2) return
findMedianBaseCase2(A[0], A[1], B, n); else if (n == 2) return
findMedianBaseCase2(B[0], B[1], A, m); int i = m/2, j = n/2, k; if (A[i]
\<= B[j]) { k = ((m%2 == 0) ? min(i-1, n-j-1) : min(i, n-j-1));
assert(k \> 0); return findMedianSortedArrays(A+k, m-k, B, n-k); } else
{ k = ((n%2 == 0) ? min(m-i-1, j-1) : min(m-i-1, j)); assert(k \> 0);
return findMedianSortedArrays(A, m-k, B+k, n-k); } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
<p>47</p>
<p>48</p>
<p>49</p>
<p>50</p>
<p>51</p>
<p>52</p>
<p>53</p>
<p>54</p>
<p>55</p>
<p>56</p>
<p>57</p>
<p>58</p>
<p>59</p>
<p>60</p>
<p>61</p>
<p>62</p>
<p>63</p>
<p>64</p>
<p>65</p>
<p>66</p>
<p>67</p>
<p>68</p>
<p>69</p>
<p>70</p>
<p>71</p>
<p>72</p>
<p>73</p>
<p>74</p>
<p>75</p>
<p>76</p>
<p>77</p>
<p>78</p>
<p>79</p>
<p>80</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">double</span><span class="h"> </span><span class="e">findMedianBaseCase</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">med</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">C</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">n</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="i">med</span><span class="o">+</span><span class="v">C</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="sy">)</span><span class="o">/</span><span class="cn">2.0</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">%</span><span class="h"> </span><span class="cn">2</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">a</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">C</span><span class="sy">[</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="v">b</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">C</span><span class="sy">[</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">med</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">a</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="i">a</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">med</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">b</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="i">med</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h"> </span><span class="c">/* med &gt; b */</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="i">b</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">a</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">C</span><span class="sy">[</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="v">b</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">C</span><span class="sy">[</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="v">c</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">C</span><span class="sy">[</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">med</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">a</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="i">a</span><span class="o">+</span><span class="i">b</span><span class="sy">)</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">2.0</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">med</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">c</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="i">med</span><span class="o">+</span><span class="i">b</span><span class="sy">)</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">2.0</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h"> </span><span class="c">/* med &gt; c */</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="i">b</span><span class="o">+</span><span class="i">c</span><span class="sy">)</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">2.0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">double</span><span class="h"> </span><span class="e">findMedianBaseCase2</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">med1</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">med2</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">C</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">%</span><span class="h"> </span><span class="cn">2</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">a</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="sy">(</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="o">-</span><span class="cn">2</span><span class="sy">)</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="v">C</span><span class="sy">[</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">2</span><span class="sy">]</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="i">INT_MIN</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">b</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">C</span><span class="sy">[</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="v">c</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">C</span><span class="sy">[</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">d</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="sy">(</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="v">C</span><span class="sy">[</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="i">INT_MAX</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">med2</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">b</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="i">b</span><span class="o">+</span><span class="e">max</span><span class="sy">(</span><span class="i">med2</span><span class="sy">,</span><span class="i">a</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">2.0</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">med1</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">b</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="i">b</span><span class="o">+</span><span class="e">min</span><span class="sy">(</span><span class="i">med2</span><span class="sy">,</span><span class="i">c</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">2.0</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">med1</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="i">c</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="i">c</span><span class="o">+</span><span class="e">min</span><span class="sy">(</span><span class="i">med1</span><span class="sy">,</span><span class="i">d</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">2.0</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">med2</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="i">c</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="i">c</span><span class="o">+</span><span class="e">max</span><span class="sy">(</span><span class="i">med1</span><span class="sy">,</span><span class="i">b</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">2.0</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h">  </span><span class="c">/* a &lt; med1 &lt;= med2 &lt; b */</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="i">med1</span><span class="o">+</span><span class="i">med2</span><span class="sy">)</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">2.0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">a</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">C</span><span class="sy">[</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="v">b</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">C</span><span class="sy">[</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="v">c</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">C</span><span class="sy">[</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">med1</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="i">b</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="e">min</span><span class="sy">(</span><span class="i">med1</span><span class="sy">,</span><span class="h"> </span><span class="i">c</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">med2</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">b</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="e">max</span><span class="sy">(</span><span class="i">med2</span><span class="sy">,</span><span class="h"> </span><span class="i">a</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h">  </span><span class="c">/* med1 &lt; b &lt; med2 */</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="i">b</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">double</span><span class="h"> </span><span class="e">findMedianSingleArray</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">assert</span><span class="sy">(</span><span class="i">n</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">n</span><span class="o">%</span><span class="cn">2</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="sy">]</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="o">+</span><span class="v">A</span><span class="sy">[</span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="sy">]</span><span class="sy">)</span><span class="o">/</span><span class="cn">2.0</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">double</span><span class="h"> </span><span class="e">findMedianSortedArrays</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">m</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">B</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">assert</span><span class="sy">(</span><span class="i">m</span><span class="o">+</span><span class="i">n</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">m</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">findMedianSingleArray</span><span class="sy">(</span><span class="i">B</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">n</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">findMedianSingleArray</span><span class="sy">(</span><span class="i">A</span><span class="sy">,</span><span class="h"> </span><span class="i">m</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">m</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">findMedianBaseCase</span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="i">B</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">n</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">findMedianBaseCase</span><span class="sy">(</span><span class="v">B</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="i">A</span><span class="sy">,</span><span class="h"> </span><span class="i">m</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">m</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">2</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">findMedianBaseCase2</span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="cn">1</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="i">B</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">n</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">2</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">findMedianBaseCase2</span><span class="sy">(</span><span class="v">B</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="v">B</span><span class="sy">[</span><span class="cn">1</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="i">A</span><span class="sy">,</span><span class="h"> </span><span class="i">m</span><span class="sy">)</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">m</span><span class="o">/</span><span class="cn">2</span><span class="sy">,</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="sy">,</span><span class="h"> </span><span class="i">k</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="v">B</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">k</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">m</span><span class="o">%</span><span class="cn">2</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="e">min</span><span class="sy">(</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="i">j</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="e">min</span><span class="sy">(</span><span class="i">i</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="i">j</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">assert</span><span class="sy">(</span><span class="i">k</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">findMedianSortedArrays</span><span class="sy">(</span><span class="i">A</span><span class="o">+</span><span class="i">k</span><span class="sy">,</span><span class="h"> </span><span class="i">m</span><span class="o">-</span><span class="i">k</span><span class="sy">,</span><span class="h"> </span><span class="i">B</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="i">k</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">k</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">n</span><span class="o">%</span><span class="cn">2</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="e">min</span><span class="sy">(</span><span class="i">m</span><span class="o">-</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">j</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="e">min</span><span class="sy">(</span><span class="i">m</span><span class="o">-</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">j</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">assert</span><span class="sy">(</span><span class="i">k</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">findMedianSortedArrays</span><span class="sy">(</span><span class="i">A</span><span class="sy">,</span><span class="h"> </span><span class="i">m</span><span class="o">-</span><span class="i">k</span><span class="sy">,</span><span class="h"> </span><span class="i">B</span><span class="o">+</span><span class="i">k</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="i">k</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**<span>EDIT2:</span>**  
 A reader
[buried.shopno](http://www.leetcode.com/2011/03/median-of-two-sorted-arrays.html#comment-771)
had managed to code the solution more elegantly! I especially like how
medianOfThree and medianOfFour were implemented. For more details, read
his comment
[below](http://www.leetcode.com/2011/03/median-of-two-sorted-arrays.html#comment-771).
Great job!

**<span>Further thoughts:</span>**  
 A reader
[nimin98](http://www.leetcode.com/2011/03/median-of-two-sorted-arrays.html#comment-687)
suggested that the base case can be handled by simply doing a direct
merge. In other words, we have to merge the short array (containing
either one or two elements) with the longer array (pick the four
elements near the middle. Deciding which four is another tricky business
because of multiple special cases). [nimin98′s
code](http://www.leetcode.com/2011/03/median-of-two-sorted-arrays.html#comment-687)
has few bugs in the handling of base case.

In general, The above approaches (including mine) to handle the base
case are not recommended due to tricky implementation. How about Binary
Search? We can use binary search to find the correct position to insert
elements from the shorter array into the longer array, thus completing
the merge (You don’t have to \**actually*\* insert it, recording its
index should be suffice).

VN:F [1.9.22\_1171]

Rating: 4.7/**5** (40 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Median of Two Sorted Arrays</span></span>, <span
class="rating"><span class="average">4.7</span> out of <span
class="best">5</span> based on <span class="votes">40</span> ratings
<span class="summary"></span></span></span>

A String Replacement Problem
============================

November 6, 2010 <span>in
[string](http://leetcode.com/category/string "View all posts in string")</span>
<span class="post-utility alignright"></span>

> Replace all occurrence of the given pattern to ‘X’.  
> For example, given that the pattern=”abc”, replace “abcdeffdfegabcabc”
> with “XdeffdfegX”. Note that multiple occurrences of abc’s that are
> contiguous will be replaced with only one ‘X’.

<span id="more-53"></span>  

First, it is not clear whether the problem mentions an in-place
replacement or not, so be sure to ask this question during an interview.
Many interview questions asked are purposely ambiguous. It is expected
that the candidate ask thought-provoking questions of the interviewer in
order to better answer the question. Here, we will assume that it is an
in-place replacement.

**Hint:**  
If the problem seemed overly complex to you, you are in the wrong path.
Try to break the problem into manageable pieces. Consider having a
helper function called

bool isMatch(char \*str, const char \*pattern)

which returns true if *pattern* matches *str* starting from its first
character.

**Solution:**  
We should take advantage that the replacement is only one character in
length. Assume that the pattern is at least one character in length,
then the replacement’s length will never exceed the pattern’s length.
This means that when we overwrite the existing string with replacement,
we would never overwrite characters that would be read next.

Two pointers are also used for an efficient in-place replacement, which
traverses the string once without any extra memory.

bool isMatch(char \*str, const char\* pattern) { while (\*pattern) if
(\*str++ != \*pattern++) return false; return true; } void replace(char
str[], const char \*pattern) { if (str == NULL || pattern == NULL)
return; char \*pSlow = str, \*pFast = str; int pLen = strlen(pattern);
while (\*pFast != '\\0') { bool matched = false; while (isMatch(pFast,
pattern)) { matched = true; pFast += pLen; } if (matched) \*pSlow++ =
'X'; // tricky case to handle here: // pFast might be pointing to '\\0',
// and you don't want to increment past it if (\*pFast !=
'\\0') \*pSlow++ = \*pFast++; // \*p++ = (\*p)++ } // don't forget to
add a null character at the end! \*pSlow = '\\0'; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">bool</span><span class="h"> </span><span class="e">isMatch</span><span class="sy">(</span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="i">str</span><span class="sy">,</span><span class="h"> </span><span class="m">const</span><span class="h"> </span><span class="t">char</span><span class="o">*</span><span class="h"> </span><span class="i">pattern</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="i">pattern</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="i">str</span><span class="o">++</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="o">*</span><span class="i">pattern</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">void</span><span class="h"> </span><span class="e">replace</span><span class="sy">(</span><span class="t">char</span><span class="h"> </span><span class="v">str</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="m">const</span><span class="h"> </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="i">pattern</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">str</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="t">NULL</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="v">pattern</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="t">NULL</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="v">pSlow</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">str</span><span class="sy">,</span><span class="h"> </span><span class="o">*</span><span class="v">pFast</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">str</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">pLen</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">strlen</span><span class="sy">(</span><span class="i">pattern</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="i">pFast</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="s">'\0'</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">bool</span><span class="h"> </span><span class="v">matched</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="e">isMatch</span><span class="sy">(</span><span class="i">pFast</span><span class="sy">,</span><span class="h"> </span><span class="i">pattern</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">matched</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="i">pFast</span><span class="h"> </span><span class="o">+</span><span class="o">=</span><span class="h"> </span><span class="i">pLen</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">matched</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="o">*</span><span class="i">pSlow</span><span class="o">++</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="s">'X'</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="c">// tricky case to handle here:</span></p>
<p><span class="h">    </span><span class="c">// pFast might be pointing to '\0',</span></p>
<p><span class="h">    </span><span class="c">// and you don't want to increment past it</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="i">pFast</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="s">'\0'</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="o">*</span><span class="i">pSlow</span><span class="o">++</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="o">*</span><span class="i">pFast</span><span class="o">++</span><span class="sy">;</span><span class="h">  </span><span class="c">// *p++ = (*p)++</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="c">// don't forget to add a null character at the end!</span></p>
<p><span class="h">  </span><span class="o">*</span><span class="v">pSlow</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="s">'\0'</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

  
**Test Cases:**
    Format is string, pattern = answer)
    -----------------------------------
    a, a = X
    aa, aa = X
    aa, a = X
    aa, aaa = aa
    abc, abc = X
    abcabc, abc = X
    abcabcabc, abc = X
    abcaabcaabc, abc = XaXaX
    abcaaabcaaabca, abc = XaaXaaXa
    abcabcabababcabc, abc = XababX
    abcabcabababcabcab, abc = XababXab
    aabbaabbaaabbbaabb, aabb = XaXbX
    aabbaabbaaabbbaabb, aaabb = aabbaabbXbaabb
    aabbaabbaaabbbaaabb, aaabb = aabbaabbXbX
    aabbaabbaaabbbaaabc, aaabb = aabbaabbXbaaabc
    abcdeffdfegabcabc, abc = XdeffdfegX
    abcdeffdfegabcabc, ab = XcdeffdfegXcXc
    abcdeffdfegabcabc, a = XbcdeffdfegXbcXbc
    abcdeffdfegabcab, abc = XdeffdfegXab
    abcdeffdfegabcabcab, abc = XdeffdfegXab
    abcdeffdfegabcaabcab, abc = XdeffdfegXaXab
    abcdeffdfegabcaaaabcab, abc = XdeffdfegXaaaXab
    aaaaaa, a = X
    aaaaaa, aa = X
    aaaaaa, aaaaaa = X
    aaaaaa, aaaaaaa = aaaaaa
    aabaababaaab, a = XbXbXbXb
    aabaababaaa, a = XbXbXbX
    aaaab, a = Xb
    baaa, a = bX
    aabaaabaab, aaa = aabXbaab
    aabaaabaab, aa = XbXabXb
    aabaaabaa, aa = XbXabX

VN:F [1.9.22\_1171]

Rating: 4.9/**5** (8 votes cast)

<span class="hreview-aggregate"><span class="item"><span class="fn">A
String Replacement Problem</span></span>, <span class="rating"><span
class="average">4.9</span> out of <span class="best">5</span> based on
<span class="votes">8</span> ratings <span
class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/11/microsoft-string-replacement-problem.html>

### Leave a reply

### 5 trackbacks

-   *on July 3, 2011*
-   *on July 22, 2011*
-   *on September 3, 2013*
-   *on September 3, 2013*
-   *on August 8, 2014*

Multiplication of numbers
=========================

April 16, 2010 <span>in [dynamic
programming](http://leetcode.com/category/dynamic-programming "View all posts in dynamic programming")</span>
<span class="post-utility alignright"></span>

> There is an array A[N] of N numbers. You have to compose an array
> Output[N] such that Output[i] will be equal to multiplication of all
> the elements of A[N] except A[i]. Solve it without division operator
> and in O(n).<span id="more-17"></span>
>
> For example Output[0] will be multiplication of A[1] to A[N-1] and
> Output[1] will be multiplication of A[0] and from A[2] to A[N-1].
>
> Example:  
> A: {4, 3, 2, 1, 2}  
> OUTPUT: {12, 16, 24, 48, 24}

Since the complexity required is O(n), the obvious O(n^2) brute force
solution is not good enough here. Since the brute force solution
recompute the multiplication each time again and again, we can avoid
this by storing the results temporarily in an array.

Let’s define array B where element B[i] = multiplication of numbers from
A[0] to A[i]. For example, if A = {4, 3, 2, 1, 2}, then B = {4, 12, 24,
24, 48}. Then, we scan the array A from right to left, and have a
temporary variable called product which stores the multiplication from
right to left so far. Calculating OUTPUT[i] is straight forward, as
OUTPUT[i] = B[i-1] \* product.

The above method requires only O(n) time but uses O(n) space. We have to
trade memory for speed. Is there a better way? (i.e., runs in O(n) time
but without extra space?)

Yes, actually the temporary table is not required. We can have two
variables called left and right, each keeping track of the product of
numbers multiplied from left-\>right and right-\>left. Could you see why
this works without extra space?

void array\_multiplication(int A[], int OUTPUT[], int n) { int left = 1;
int right = 1; for (int i = 0; i \< n; i++) OUTPUT[i] = 1; for (int i =
0; i \< n; i++) { OUTPUT[i] \*= left; OUTPUT[n - 1 - i] \*= right;
left \*= A[i]; right \*= A[n - 1 - i]; } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">array_multiplication</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">OUTPUT</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">left</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">right</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">  </span><span class="v">OUTPUT</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">OUTPUT</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">*=</span><span class="h"> </span><span class="i">left</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">OUTPUT</span><span class="sy">[</span><span class="i">n</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">*=</span><span class="h"> </span><span class="i">right</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="e">left *</span><span class="o">=</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="e">right *</span><span class="o">=</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">n</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">i</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.5/**5** (34 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Multiplication of numbers</span></span>, <span
class="rating"><span class="average">4.5</span> out of <span
class="best">5</span> based on <span class="votes">34</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/04/multiplication-of-numbers.html>

Number of 1 bits
================

September 9, 2010 <span>in [bit
operations](http://leetcode.com/category/bit-operations "View all posts in bit operations")</span>
<span class="post-utility alignright"></span>

> Write a function that takes an unsigned integer and returns the number
> of ’1′ bits it has. <span id="more-30"></span>For example, the 32-bit
> integer ’11′ has binary representation
> 00000000000000000000000000001011, so the function should return 3.

**Brute force solution:**  
Iterate 32 times, each time determining if the ith bit is a ’1′ or not.
This is probably the easiest solution, and the interviewer would
probably not be too happy about it. This solution is also machine
dependent (You need to be sure that an unsigned integer is 32-bit). In
addition, this solution is not very efficient too, as you need to
iterate 32 times no matter what.

**Lookup table solution:**  
If you need maximum speed, lookup table is the way to go. Keep in mind
that you need a huge memory for this. Depending on the maximum bits an
integer has, you might need up to 4GB of memory to store the table!

**Best solution:**  
Hint: Remember my last post about making use x & (x-1) to determine if
an integer is a power of two? Well, there are even better uses for that!
Remember every time you perform the operation x & (x-1), a single 1 bit
is erased?

The following solution is machine independent, and is quite efficient.
It runs in the order of the number of 1s. In the worst case, it needs to
iterate 32 times (for a 32-bit integer), but a case such as the number
’8′ would only need to iterate 1 time.

int number\_of\_ones(unsigned int x) { int total\_ones = 0; while (x !=
0) { x = x & (x-1); total\_ones++; } return total\_ones; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">number_of_ones</span><span class="sy">(</span><span class="t">unsigned</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">x</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">total_ones</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">x</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">x</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="sy">(</span><span class="i">x</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">total_ones</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">total_ones</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**More Bit Hacking Fun:**  
 If you would like to explore more about bit hacking, I recommend these
resources to get you started:

» [Low Level Bit Hacks You Absolutely Must
Know](http://www.catonmat.net/blog/low-level-bit-hacks-you-absolutely-must-know/)  
» [Bit Twiddling
Hacks](http://graphics.stanford.edu/%7Eseander/bithacks.html)

The first one is beginner-friendly, and teaches you the basic but useful
bit hacks you encounter often. The latter one is more difficult and has
quite some clever bit hacks. Some of the bit hacks contain just one line
of code, which is amazing.

**EDIT: (More Bit Twiddling Fun)**

Try this question from Google CodeJam 2010 for more bit twiddling fun.  
» [Google CodeJam 2010 Qualification Round Problem A: Snapper
Chain](http://www.leetcode.com/2010/05/problem-snapper-chain-gcj-qualification.html)

VN:F [1.9.22\_1171]

Rating: 4.8/**5** (5 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Number of 1 bits</span></span>, <span class="rating"><span
class="average">4.8</span> out of <span class="best">5</span> based on
<span class="votes">5</span> ratings <span
class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/09/number-of-1-bits.html>

### Leave a reply

> A pile of nuts is in an oasis, across a desert from a town. The pile
> contains ‘N’ kg of nuts, and the town is ‘D’ kilometers away from the
> pile.
>
> The goal of this problem is to write a program that will compute ‘X’,
> the maximum amount of nuts that can be transported to the town.
>
> The nuts are transported by a horse drawn cart that is initially next
> to the pile of nuts. The cart can carry at most ‘C’ kilograms of nuts
> at any one time. The horse uses the nuts that it is carrying as fuel.
> It consumes ‘F’ kilograms of nuts per kilometer traveled regardless of
> how much weight it is carrying in the cart. The horse can load and
> unload the cart without using up any nuts.
>
> Your program should have a function that takes as input 4 real numbers
> D,N,F,C and returns one real number: ‘X’

<span id="more-74"></span>

[](http://1.bp.blogspot.com/_UElib2WLeDE/TTgUzam3d-I/AAAAAAAACcg/G0eUEO98J-s/s1600/desert-oasis-photos21.jpg)

[![](http://1.bp.blogspot.com/_UElib2WLeDE/TTgVVmGJYPI/AAAAAAAACck/5PFVfpPJkAM/s400/desert-oasis-photos.jpg)](http://1.bp.blogspot.com/_UElib2WLeDE/TTgVVmGJYPI/AAAAAAAACck/5PFVfpPJkAM/s1600/desert-oasis-photos.jpg)

<span>A desert oasis. Simply breathtaking.</span>

Our first natural approach to this problem is to use a greedy approach.
Since you have a cart with a maximum capacity of *C*, it would be rather
stupid to not fit in as many nuts as possible into the cart. And there
you have it, how about this simple approach: “If *N* = *C*, we could
just fit all nuts into the cart and transport all of them in one trip;
otherwise if *N* \> *C*, fit in *C* kg nuts into the cart, travel to the
destination, go back and fetch more nuts back, until there is no more
nuts left. This yields the following equation:

[![](http://4.bp.blogspot.com/_UElib2WLeDE/TTgH8pvqzQI/AAAAAAAACcY/JD9J3mQsbkE/s1600/sumX.JPG)](http://4.bp.blogspot.com/_UElib2WLeDE/TTgH8pvqzQI/AAAAAAAACcY/JD9J3mQsbkE/s1600/sumX.JPG)

<span>The sum of *X* is the sum of two terms. The math symbol with the
upper square bracket is the [ceiling
function](http://en.wikipedia.org/wiki/Floor_and_ceiling_functions).</span>

\* Note that the last trip (the right term) must be handled specially as
it requires only one single trip!

[![](http://3.bp.blogspot.com/_UElib2WLeDE/TTgVs9LKNyI/AAAAAAAACco/JRcTgfEO1Wg/s400/DSC6382.jpg)](http://3.bp.blogspot.com/_UElib2WLeDE/TTgVs9LKNyI/AAAAAAAACco/JRcTgfEO1Wg/s1600/DSC6382.jpg)

<span>Our poor horse (or donkey) has to pull the cart over the desert,
could this be possible? Or die of hunger if there is no nuts in the
cart.</span>

Sharp readers might spot a flaw in the reasoning above. We might not
want to go back to transport the last round of nuts, since it might
consume more than the nuts transported. Besides, what happens when *C*
FD? Then, halfway down the trip our poor horse would have died of
hunger!

Well, does that mean if *C* FD, there’s no solution? How can you prove
so? If there is a solution, how would your algorithm handle such cases?
Worst still, even if *C* \> *FD*, the above method does not necessarily
yield the maximum *X* (Try to find a counter example!).

For such cases where *C* FD, we definitely need to somehow subdivide the
total distance (ie, choose a point somewhere in between as a transit),
but the question remains:

How and where should we subdivide?

Here is where things might get a little hairy. Most people might be
wondering if [Dynamic Programming
(DP)](http://www.leetcode.com/search/label/dynamic%20programming) is
really needed to find the division point that yields the maximum. It
turns out this problem is highly recursive in nature and with one
important observation, the derivation of the recursive formula is
actually not that difficult (No DP involved though).

-   The most important observation is the rate of consumption remain
    **constant** no matter how you subdivide the distance, as long as
    the number of trips required is the same.
-   Since we are consuming the nuts at a constant rate, eventually we
    will reach one such transit point where just enough nuts are
    consumed such that transporting nuts to the next transit point
    requires **one less round trip**.

Let’s use a concrete example to illustrate the observation above. Assume
*N* = 100, *D* = 20, *C* = 50, *F* = 1. Since *N*/*C* = 100/50 = 2, it
requires 1 round trip + 1 last trip = a total of **3 trips** to
transport from point **A** to point **B**. Assume point **B** is our
transit point, and the total consumption cost is **50 kg** nuts. Point
**B** could be derived mathematically, which is approximately **16.67
km** (from point **A**). Point **B** must be the first transit point in
order to maximize *X*, since from the next transit onwards you save
yourself one full round trip!

Although we have found point **B**, we are still not quite done yet. We
still need to find point **C**, point **D**, … until it reaches the
destination. Since finding point **C** is just the exact same problem as
the original problem (of course, with values of *N* and *D* changed),
the rest could be solved in a recursive manner.

Continuing from the above example, we found that point **B** is **16.67
km** from point **A**, which means there is about **3.33 km** left to
the destination, and right at point B we have a total of **50 kg** of
nuts to transport. Since we have to transport the remaining nuts
directly to the destination (we could not subdivide again, since there
are only **50 kg** nuts remaining), the maximum *X* for the above
example is: 50 – 3.33 \* 1 = **46.67 kg**.

Remember, every time you state a solution as a recursive formula, you
must also provide the base case! Without the base case the recursion
would never end. The base case is trivial to prove, as illustrated in
the code below.

Please take note that the above example uses a case where *N* is
divisible by *C*. You would have to figure out the case where *N* is not
divisible by *C*, too (which should be straight forward once you
understand the key observation). This would be left as an exercise to
the reader.
![](http://4.bp.blogspot.com/_UElib2WLeDE/TK7aJSBFXSI/AAAAAAAACW8/5f8CRD5dJ8o/s1600/smiley.jpg)

Below is the full code for the solution. Deriving the mathematical
formula seemed to be more tricky than I initially thought and is error
prone if you’re not careful. I believe with slight modification: ie,
introducing additional variables to be passed in the recursive function,
the math derivation complexity could be reduced. Anyhow, my advice is to
start with easy examples (like the case where *N* is divisible by *C*,
and gradually apply to more complicated examples) as you visualize the
formula in your head.

**Edit:**

Updated code with better comments and added case to handle where it
might run out of fuel.

double getMaxNuts(double N, double D, double C, double F) { // base
case: // We have the capacity to carry all nuts, // so fetch all the
nuts in one trip if (N \<= C) { double nutsAtDestination = N - D\*F;
return (nutsAtDestination \>= 0.0) ? nutsAtDestination : 0.0; // out of
fuel! } // \# trips you would travel back and forth int numTrips =
2\*(ceil(N/C) - 1) + 1; // how many nuts you consume per km double
costPerKm = numTrips \* F; // remaining weight of nuts after consumption
double remainingNuts = C\*(ceil(N/C) - 1.0); // this is the distance you
are able to travel before you // reach ONE LESS round trip fetching nuts
// derived from eq: N - costPerKm \* traveled = remainingNuts double
traveled = (N - remainingNuts) / costPerKm; // we are able to travel
greater (or equal) than the remaining // distance, so fetch the nuts
right to the destination if (traveled \>= D) return N - D\*costPerKm; //
calculate recursively as we travel ONE less round trip now. return
getMaxNuts(remainingNuts, D-traveled, C, F); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">double</span><span class="h"> </span><span class="e">getMaxNuts</span><span class="sy">(</span><span class="t">double</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="t">double</span><span class="h"> </span><span class="i">D</span><span class="sy">,</span><span class="h"> </span><span class="t">double</span><span class="h"> </span><span class="i">C</span><span class="sy">,</span><span class="h"> </span><span class="t">double</span><span class="h"> </span><span class="i">F</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="c">// base case:</span></p>
<p><span class="h">  </span><span class="c">// We have the capacity to carry all nuts,</span></p>
<p><span class="h">  </span><span class="c">// so fetch all the nuts in one trip</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">N</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">C</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="t">double</span><span class="h"> </span><span class="v">nutsAtDestination</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">N</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="e">D*</span><span class="i">F</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="i">nutsAtDestination</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0.0</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span></p>
<p><span class="h">              </span><span class="i">nutsAtDestination</span><span class="h"> </span><span class="o">:</span></p>
<p><span class="h">              </span><span class="cn">0.0</span><span class="sy">;</span><span class="h">    </span><span class="c">// out of fuel!</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span></p>
<p><span class="h">  </span><span class="c">// # trips you would travel back and forth</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">numTrips</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">2</span><span class="o">*</span><span class="sy">(</span><span class="e">ceil</span><span class="sy">(</span><span class="i">N</span><span class="o">/</span><span class="i">C</span><span class="sy">)</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="c">// how many nuts you consume per km</span></p>
<p><span class="h">  </span><span class="t">double</span><span class="h"> </span><span class="v">costPerKm</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">numTrips *</span><span class="h"> </span><span class="i">F</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="c">// remaining weight of nuts after consumption</span></p>
<p><span class="h">  </span><span class="t">double</span><span class="h"> </span><span class="v">remainingNuts</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">C*</span><span class="sy">(</span><span class="e">ceil</span><span class="sy">(</span><span class="i">N</span><span class="o">/</span><span class="i">C</span><span class="sy">)</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1.0</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="c">// this is the distance you are able to travel before you</span></p>
<p><span class="h">  </span><span class="c">// reach ONE LESS round trip fetching nuts</span></p>
<p><span class="h">  </span><span class="c">// derived from eq: N - costPerKm * traveled = remainingNuts</span></p>
<p><span class="h">  </span><span class="t">double</span><span class="h"> </span><span class="v">traveled</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="i">N</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">remainingNuts</span><span class="sy">)</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="i">costPerKm</span><span class="sy">;</span></p>
<p><span class="h">  </span></p>
<p><span class="h">  </span><span class="c">// we are able to travel greater (or equal) than the remaining</span></p>
<p><span class="h">  </span><span class="c">// distance, so fetch the nuts right to the destination</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">traveled</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="i">D</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="i">N</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="e">D*</span><span class="i">costPerKm</span><span class="sy">;</span></p>
<p><span class="h">  </span></p>
<p><span class="h">  </span><span class="c">// calculate recursively as we travel ONE less round trip now.</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="e">getMaxNuts</span><span class="sy">(</span><span class="i">remainingNuts</span><span class="sy">,</span><span class="h"> </span><span class="i">D</span><span class="o">-</span><span class="i">traveled</span><span class="sy">,</span><span class="h"> </span><span class="i">C</span><span class="sy">,</span><span class="h"> </span><span class="i">F</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 2.9/**5** (16 votes cast)

<span class="hreview-aggregate"><span class="item"><span class="fn">Nuts
in an Oasis</span></span>, <span class="rating"><span
class="average">2.9</span> out of <span class="best">5</span> based on
<span class="votes">16</span> ratings <span
class="summary"></span></span></span>

> Determine whether an integer is a palindrome. Do this without extra
> space.

<span id="more-1224"></span>

**<span>Online Judge</span>**  
 This problem is available at [Online
Judge](http://www.leetcode.com/onlinejudge). [Head over
there](http://www.leetcode.com/onlinejudge) and it will judge your
solution. Currently only able to compile C++/Java code. If you are using
other languages, you can still verify your solution by looking at the
judge’s test cases and its expected output.

In previous posts ([Longest Palindromic Substring Part
I](http://www.leetcode.com/2011/11/longest-palindromic-substring-part-i.html),
[Part
II](http://www.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html))
we have discussed multiple approaches on finding the longest palindrome
in a string. In this post we discuss ways to determine whether an
integer is a palindrome. Sounds easy?

**Hint:**  
 Don’t be deceived by this problem which seemed easy to solve. Also note
the restriction of doing it without extra space. Think of a generic
solution that is not language/platform specific. Also, consider cases
where your solution might go wrong.

**Solution:**  
 First, the problem statement did not specify if negative integers
qualify as palindromes. Does negative integer such as -1 qualify as a
palindrome? Finding out the full requirements of a problem before coding
is what every programmer *must* do. For the purpose of discussion here,
we define negative integers as non-palindromes.

The most intuitive approach is to first represent the integer as a
string, since it is more convenient to manipulate. Although this
certainly does work, it violates the restriction of not using extra
space. (ie, you have to allocate *n* characters to store the reversed
integer as string, where *n* is the maximum number of digits). I know,
this sound like an unreasonable requirement (since it uses so little
space), but don’t most interview problems have such requirements?

Another approach is to first reverse the number. If the number is the
same as its reversed, then it must be a palindrome. You could reverse a
number by doing the following:

int reverse(int num) { assert(num \>= 0); // for non-negative integers
only. int rev = 0; while (num != 0) { rev = rev \* 10 + num % 10; num /=
10; } return rev; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">reverse</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">num</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">assert</span><span class="sy">(</span><span class="i">num</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span><span class="h">   </span><span class="c">// for non-negative integers only.</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">rev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">num</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">rev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">rev *</span><span class="h"> </span><span class="cn">10</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="i">num</span><span class="h"> </span><span class="o">%</span><span class="h"> </span><span class="cn">10</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">num</span><span class="h"> </span><span class="o">/=</span><span class="h"> </span><span class="cn">10</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">rev</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

This seemed to work too, but did you consider the possibility that the
reversed number might overflow? If it overflows, the behavior is
language specific (For Java the number wraps around on overflow, but in
C/C++ its behavior is undefined). Yuck.

Of course, we could avoid overflow by storing and returning a type that
has larger size than int (ie, long long). However, do note that this is
language specific, and the larger type might not always be available on
all languages.

We could construct a better and more generic solution. One pointer is
that, we must start comparing the digits somewhere. And you know there
could only be two ways, either expand from the middle or compare from
the two ends.

It turns out that comparing from the two ends is easier. First, compare
the first and last digit. If they are not the same, it must not be a
palindrome. If they are the same, chop off one digit from both ends and
continue until you have no digits left, which you conclude that it must
be a palindrome.

Now, getting and chopping the last digit is easy. However, getting and
chopping the first digit in a generic way requires some thought. I will
leave this to you as an exercise. Please think your solution out before
you peek on the solution below.

bool isPalindrome(int x) { if (x \< 0) return false; int div = 1; while
(x / div \>= 10) { div \*= 10; } while (x != 0) { int l = x / div; int r
= x % 10; if (l != r) return false; x = (x % div) / 10; div /= 100; }
return true; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">bool</span><span class="h"> </span><span class="e">isPalindrome</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">x</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">div</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="i">div</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">10</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="e">div *</span><span class="o">=</span><span class="h"> </span><span class="cn">10</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h">        </span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">l</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">x</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="i">div</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">r</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">x</span><span class="h"> </span><span class="o">%</span><span class="h"> </span><span class="cn">10</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">l</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="i">r</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">x</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">%</span><span class="h"> </span><span class="i">div</span><span class="sy">)</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">10</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">div</span><span class="h"> </span><span class="o">/=</span><span class="h"> </span><span class="cn">100</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Alternative Solution:**  
 Credits go to
**[Dev](http://www.leetcode.com/2012/01/palindrome-number.html#comment-11400)**
who suggested a recursive solution (if extra stack space does not count
as extra space), which is pretty neat too.

bool isPalindrome(int x, int &y) { if (x \< 0) return false; if (x == 0)
return true; if (isPalindrome(x/10, y) && (x%10 == y%10)) { y /= 10;
return true; } else { return false; } } bool isPalindrome(int x) {
return isPalindrome(x, x); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">bool</span><span class="h"> </span><span class="e">isPalindrome</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">x</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">y</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">x</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="e">isPalindrome</span><span class="sy">(</span><span class="i">x</span><span class="o">/</span><span class="cn">10</span><span class="sy">,</span><span class="h"> </span><span class="i">y</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="sy">(</span><span class="i">x</span><span class="o">%</span><span class="cn">10</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">y</span><span class="o">%</span><span class="cn">10</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">y</span><span class="h"> </span><span class="o">/=</span><span class="h"> </span><span class="cn">10</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
<p><span class="t">bool</span><span class="h"> </span><span class="e">isPalindrome</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">x</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="e">isPalindrome</span><span class="sy">(</span><span class="i">x</span><span class="sy">,</span><span class="h"> </span><span class="i">x</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.7/**5** (115 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Palindrome Number</span></span>, <span class="rating"><span
class="average">4.7</span> out of <span class="best">5</span> based on
<span class="votes">115</span> ratings <span
class="summary"></span></span></span>

Peg Game Problem Analysis
=========================

January 10, 2011 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> At the arcade, you can play a simple game where a ball is dropped into
> the top of the game, from a position of your choosing. There are a
> number of pegs that the ball will bounce off of as it drops through
> the game. Whenever the ball hits a peg, it will bounce to the left
> with probability 0.5 and to the right with probability 0.5. The one
> exception to this is when it hits a peg on the far left or right side,
> in which case it always bounces towards the middle.
>
> When the game was first made, the pegs where arranged in a regular
> grid. However, it’s an old game, and now some of the pegs are missing.
> Your goal in the game is to get the ball to fall out of the bottom of
> the game in a specific location. Your task is, given the arrangement
> of the game, to determine the optimal place to drop the ball, such
> that the probability of getting it to this specific location is
> maximized.
>
> The image below shows an example of a game with five rows of five
> columns. Notice that the top row has five pegs, the next row has four
> pegs, the next five, and so on. With five columns, there are four
> choices to drop the ball into (indexed from 0). Note that in this
> example, there are three pegs missing. The top row is row 0, and the
> leftmost peg is column 0, so the coordinates of the missing pegs are
> (1,1), (2,1) and (3,2). In this example, the best place to drop the
> ball is on the far left, in column 0, which gives a 50% chance that it
> will end in the goal.
>
>     x.x.x.x.x
>      x...x.x
>     x...x.x.x
>      x.x...x
>     x.x.x.x.x
>      G
>
> ‘x’ indicates a peg, ‘.’ indicates empty space.
>
> **Input**  
> You should first read an integer **N**, the number of test cases. Each
> of the next **N** lines will then contain a single test case. Each
> test case will start with integers **R** and **C**, the number of rows
> and columns (**R** will be odd). Next, an integer **K** will specify
> the target column. Finally, an integer **M** will be followed by **M**
> pairs of integer **r<sub>i</sub>** and **c<sub>i</sub>**, giving the
> locations of the missing pegs.
>
> **Constraints**  
> 1 = **N** = 100  
> 3 = **R**,**C** = 100
>
> The top and bottom rows will not have any missing pegs.  
> Other parameters will all be valid, given **R** and **C**
>
> **Output**  
> For each test case, you should output an integer, the location to drop
> the ball into, followed by the probability that the ball will end in
> columns **K**, formatted with exactly six digits after the decimal
> point (round the last digit, don’t truncate).
>
> **Notes**  
> The input will be designed such that minor rounding errors will not
> impact the output (i.e. there will be no ties or near — up to 1E-9 —
> ties, and the direction of rounding for the output will not be
> impacted by small errors).

Here is my problem analysis for Facebook Hacker Cup Qualification Round:
Peg Game.

**Peg Game Problem Analysis:**  
This is the most confusing problem of the three problems due to the
problem description being unnecessary long and ambiguous. You can see
how many people are asking clarifications for this problem in the wall
posts compared to the other problems (I really think Facebook should
create a clarification section to answer people’s questions). Besides,
the example they used to illustrate the problem is not included in the
sample input, which doesn’t help at all.

[![](http://2.bp.blogspot.com/_UElib2WLeDE/TSvQrmRgLqI/AAAAAAAACcQ/uCnM5VuUJTY/s400/Galton-board.jpg)](http://2.bp.blogspot.com/_UElib2WLeDE/TSvQrmRgLqI/AAAAAAAACcQ/uCnM5VuUJTY/s1600/Galton-board.jpg)<span>  
</span>

<span> A [Galton box](http://en.wikipedia.org/wiki/Galton_board) (also
known as the bean machine) is a machine consists of a vertical board
with interleaved rows of pins. Balls are dropped from the top, and
bounce left and right as they hit the pins. Eventually, they are
collected into one-ball-wide bins at the bottom. The height of ball
columns in the bins approximates a [bell
curve](http://en.wikipedia.org/wiki/Normal_distribution "Normal distribution").</span>

It definitely takes me more than few times re-reading the problem
description to finally “guess” what they really mean. Anyway, after
understanding the problem, it is not that difficult to code the solution
using a direct simulation.

However, there are a few places where you need to be careful, and I
found that most people fall into this fallacy below:

Count the total number of ways to reach the goal, then divide it by the
total number of ways to reach the bottom.

Why the above approach is incorrect? This is simply because one
necessary condition for the above statement to be true is that ways that
reaches the bottom must all be equally likely. Unfortunately, this is
not necessarily true.

The correct method is to multiply the probabilities as the ball falls in
a step-wise fashion. You would also need to determine if the ball is at
an edge peg. If it is at an edge peg, then the ball always fall toward
the opposite direction of the edge peg with 100% chance. On the other
hand, if it is not at an edge peg, then it will fall in either direction
with 50-50 chance.

Below is the coded solution for **Peg Game**.

char pegs[2000][2000]; void initPegs(int R, int C) { int c, CLim, k; for
(int r = 0; r \< R; r++) { if (r%2==0) {CLim = C-1; k = 0;} else {CLim =
C-2; k = 1; pegs[r][0] = '\#';} for (c = 0; c \< CLim; c++) {
pegs[r][2\*c+k] = 'x'; pegs[r][2\*c+1+k] = '.'; } pegs[r][2\*c+k] = 'x';
pegs[r][2\*c+1+k] = '\#'; } } void setMissingPeg(int r, int c) { if (r %
2 == 0) { pegs[r][2\*c] = '.'; } else { pegs[r][2\*c+1] = '.'; } }
double ways[2000][2000]; double putBall(int colK, int targetCol, int R,
int C) { for (int i = 0; i \< 2000; i++) for (int j = 0; j \< 2000; j++)
ways[i][j] = 0.0; ways[0][2\*colK+1] = 1.0; for (int i = 1; i \< R; i++)
{ for (int j = 0; j \< 2\*C-1; j++) { if (pegs[i][j] == '.') { if
(pegs[i][j-1] == 'x') { if (i%2 == 1 && j == 2) ways[i][j] +=
ways[i-1][j-1]; else ways[i][j] += .5 \* ways[i-1][j-1]; } if
(pegs[i][j+1] == 'x') { if (i%2 == 1 && j == 2\*C-4) ways[i][j] +=
ways[i-1][j+1]; else ways[i][j] += .5 \* ways[i-1][j+1]; } if
(pegs[i-1][j] == '.') { ways[i][j] += ways[i-1][j]; } } } } return
ways[R-1][1+2\*targetCol]; } int main() { int N, R, C, K, M, r, c;
cin \>\> N; for (int i = 0; i \< N; i++) { cin \>\> R \>\> C;
initPegs(R, C); cin \>\> K; cin \>\> M; for (int j = 0; j \< M; j++) {
cin \>\> r \>\> c; setMissingPeg(r, c); } int maxCol = 0; double maxP =
0.0; for (int j = 0; j \< C-1; j++) { double p = putBall(j, K, R, C); if
(p \> maxP) { maxP = p; maxCol = j; } } printf("%d %.6f\\n", maxCol,
maxP); } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
<p>42</p>
<p>43</p>
<p>44</p>
<p>45</p>
<p>46</p>
<p>47</p>
<p>48</p>
<p>49</p>
<p>50</p>
<p>51</p>
<p>52</p>
<p>53</p>
<p>54</p>
<p>55</p>
<p>56</p>
<p>57</p>
<p>58</p>
<p>59</p>
<p>60</p>
<p>61</p>
<p>62</p>
<p>63</p>
<p>64</p>
<p>65</p>
<p>66</p>
<p>67</p>
<p>68</p>
<p>69</p>
<p>70</p>
<p>71</p>
<p>72</p>
<p>73</p>
<p>74</p>
<p>75</p>
<p>76</p>
<p>77</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">char</span><span class="h"> </span><span class="v">pegs</span><span class="sy">[</span><span class="cn">2000</span><span class="sy">]</span><span class="sy">[</span><span class="cn">2000</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="t">void</span><span class="h"> </span><span class="e">initPegs</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">R</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">C</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="i">c</span><span class="sy">,</span><span class="h"> </span><span class="i">CLim</span><span class="sy">,</span><span class="h"> </span><span class="i">k</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">r</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">r</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">R</span><span class="sy">;</span><span class="h"> </span><span class="i">r</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">r</span><span class="o">%</span><span class="cn">2</span><span class="o">==</span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span><span class="v">CLim</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">C</span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="v">k</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span><span class="v">CLim</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">C</span><span class="o">-</span><span class="cn">2</span><span class="sy">;</span><span class="h"> </span><span class="v">k</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="v">pegs</span><span class="sy">[</span><span class="i">r</span><span class="sy">]</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="s">'#'</span><span class="sy">;</span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="v">c</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">c</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">CLim</span><span class="sy">;</span><span class="h"> </span><span class="i">c</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">pegs</span><span class="sy">[</span><span class="i">r</span><span class="sy">]</span><span class="sy">[</span><span class="cn">2</span><span class="o">*</span><span class="i">c</span><span class="o">+</span><span class="i">k</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="s">'x'</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">pegs</span><span class="sy">[</span><span class="i">r</span><span class="sy">]</span><span class="sy">[</span><span class="cn">2</span><span class="o">*</span><span class="i">c</span><span class="o">+</span><span class="cn">1</span><span class="o">+</span><span class="i">k</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="s">'.'</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="v">pegs</span><span class="sy">[</span><span class="i">r</span><span class="sy">]</span><span class="sy">[</span><span class="cn">2</span><span class="o">*</span><span class="i">c</span><span class="o">+</span><span class="i">k</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="s">'x'</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">pegs</span><span class="sy">[</span><span class="i">r</span><span class="sy">]</span><span class="sy">[</span><span class="cn">2</span><span class="o">*</span><span class="i">c</span><span class="o">+</span><span class="cn">1</span><span class="o">+</span><span class="i">k</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="s">'#'</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">void</span><span class="h"> </span><span class="e">setMissingPeg</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">r</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">c</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">r</span><span class="h"> </span><span class="o">%</span><span class="h"> </span><span class="cn">2</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">pegs</span><span class="sy">[</span><span class="i">r</span><span class="sy">]</span><span class="sy">[</span><span class="cn">2</span><span class="o">*</span><span class="i">c</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="s">'.'</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">pegs</span><span class="sy">[</span><span class="i">r</span><span class="sy">]</span><span class="sy">[</span><span class="cn">2</span><span class="o">*</span><span class="i">c</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="s">'.'</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">double</span><span class="h"> </span><span class="v">ways</span><span class="sy">[</span><span class="cn">2000</span><span class="sy">]</span><span class="sy">[</span><span class="cn">2000</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="t">double</span><span class="h"> </span><span class="e">putBall</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">colK</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">targetCol</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">R</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">C</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="cn">2000</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="cn">2000</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">ways</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0.0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">ways</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="sy">[</span><span class="cn">2</span><span class="o">*</span><span class="i">colK</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1.0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">R</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="cn">2</span><span class="o">*</span><span class="i">C</span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">pegs</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="s">'.'</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">pegs</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="s">'x'</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">          </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">i</span><span class="o">%</span><span class="cn">2</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">1</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">2</span><span class="sy">)</span></p>
<p><span class="h">            </span><span class="v">ways</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">+</span><span class="o">=</span><span class="h"> </span><span class="v">ways</span><span class="sy">[</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">          </span><span class="st">else</span></p>
<p><span class="h">            </span><span class="v">ways</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">+</span><span class="o">=</span><span class="h"> </span><span class="sy">.</span><span class="cn">5</span><span class="h"> </span><span class="o">*</span><span class="h"> </span><span class="v">ways</span><span class="sy">[</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="sy">}</span></p>
<p><span class="h">        </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">pegs</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="s">'x'</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">          </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">i</span><span class="o">%</span><span class="cn">2</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">1</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">2</span><span class="o">*</span><span class="i">C</span><span class="o">-</span><span class="cn">4</span><span class="sy">)</span></p>
<p><span class="h">            </span><span class="v">ways</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">+</span><span class="o">=</span><span class="h"> </span><span class="v">ways</span><span class="sy">[</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">          </span><span class="st">else</span></p>
<p><span class="h">            </span><span class="v">ways</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">+</span><span class="o">=</span><span class="h"> </span><span class="sy">.</span><span class="cn">5</span><span class="h"> </span><span class="o">*</span><span class="h"> </span><span class="v">ways</span><span class="sy">[</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="sy">}</span></p>
<p><span class="h">        </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">pegs</span><span class="sy">[</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="s">'.'</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">          </span><span class="v">ways</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">+</span><span class="o">=</span><span class="h"> </span><span class="v">ways</span><span class="sy">[</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="sy">}</span></p>
<p><span class="h">      </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="v">ways</span><span class="sy">[</span><span class="i">R</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="cn">1</span><span class="o">+</span><span class="cn">2</span><span class="o">*</span><span class="i">targetCol</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">int</span><span class="h"> </span><span class="e">main</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="i">R</span><span class="sy">,</span><span class="h"> </span><span class="i">C</span><span class="sy">,</span><span class="h"> </span><span class="i">K</span><span class="sy">,</span><span class="h"> </span><span class="i">M</span><span class="sy">,</span><span class="h"> </span><span class="i">r</span><span class="sy">,</span><span class="h"> </span><span class="i">c</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">N</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">N</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">R</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">C</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="e">initPegs</span><span class="sy">(</span><span class="i">R</span><span class="sy">,</span><span class="h"> </span><span class="i">C</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">K</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">M</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">M</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">r</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">c</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="e">setMissingPeg</span><span class="sy">(</span><span class="i">r</span><span class="sy">,</span><span class="h"> </span><span class="i">c</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">maxCol</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">double</span><span class="h"> </span><span class="v">maxP</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0.0</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">C</span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="t">double</span><span class="h"> </span><span class="v">p</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">putBall</span><span class="sy">(</span><span class="i">j</span><span class="sy">,</span><span class="h"> </span><span class="i">K</span><span class="sy">,</span><span class="h"> </span><span class="i">R</span><span class="sy">,</span><span class="h"> </span><span class="i">C</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">p</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">maxP</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">maxP</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">maxCol</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">j</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="e">printf</span><span class="sy">(</span><span class="s">&quot;%d %.6f\n&quot;</span><span class="sy">,</span><span class="h"> </span><span class="i">maxCol</span><span class="sy">,</span><span class="h"> </span><span class="i">maxP</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 2.3/**5** (3 votes cast)

<span class="hreview-aggregate"><span class="item"><span class="fn">Peg
Game Problem Analysis</span></span>, <span class="rating"><span
class="average">2.3</span> out of <span class="best">5</span> based on
<span class="votes">3</span> ratings <span
class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2011/01/peg-game-problem-analysis.html>

Print All Combinations of a Number as a Sum of Candidate Numbers
================================================================

September 30, 2010 <span>in
[backtracking](http://leetcode.com/category/backtracking "View all posts in backtracking")</span>
<span class="post-utility alignright"></span>

> Given a target number, and a series of candidate numbers, print out
> all combinations, so that the sum of candidate numbers equals to the
> target.  
>  <span id="more-44"></span>  
>  Here order is not important, so don’t print the duplicated
> combination.
>
> e.g. target is **7**, candidate is **2**,**3**,**6**,**7**  
>  output should be **7** and **3**+**2**+**2** (but not print
> **2**+**3**+**2**, **2**+**2**+**3**)

Please note that the same repeated number may be chosen from the
candidate set. We may also assume that the candidate set does not
contain duplicate numbers, as this will be redundant. We assume all
numbers will be positive integers, I will explain why this assumption is
important for obtaining a solution later.

**Hint:**  
 Think about how to avoid printing duplicates. Think about developing a
systematic method to search all possible solutions. How do you determine
the condition that ends the search? (**Note:** <span>Thanks to a kind
reader</span> who pointed out that *sorting the numbers* is not
necessary for removing duplicates, as indicated in my previous version
of this post.)

[![](http://1.bp.blogspot.com/_UElib2WLeDE/TKMGpoqmi3I/AAAAAAAACVw/zkiyFZ3yBOw/s320/wordlock.jpg)](http://1.bp.blogspot.com/_UElib2WLeDE/TKMGpoqmi3I/AAAAAAAACVw/zkiyFZ3yBOw/s1600/wordlock.jpg)  
 A wordlock combination lock

**Solution:**  
 To search for all combination, we use a backtracking algorithm. Here,
we use the above example of candidate=**{2,3,6,7}** and target=**7**.

First, we start with a sum of **0**. Then, we iterate over all
possibilities that can be added to sum, which yields the possible set of
sum=**{2,3,6,7}**. Assume now that sum=**2**, we continue adding all
possible candidate numbers **{2,3,6,7}** to sum=**2**, which yields
sum=**{4,5,8,9}**. Each step we have to use an array to keep track of
all the indices of candidate numbers that add to the current sum, so
that we can print the combination later. The next case would be
sum=**3**. We look at all possible candidate numbers **{3,6,7**} to be
added to sum=**3**, which yields sum=**{6,9,10}**. Note that there is no
need to look backward (ie, candidate numbers that are smaller than
**3**), as this would only yield duplicate results. We keep doing this
recursively, until we reach the conditions below, where we stop.

We stop when the sum is *greater* than the target sum. Why? Remember our
earlier assumption that candidate numbers must *all be positive*? Since
the candidate array contains only *positive numbers*, if we continue
searching, we would only add larger numbers to the sum, and this would
not help us achieving the target sum. The other case where we stop is
when the sum is *equal* to the target sum. Hooray! We have found a valid
combination.

If the candidate array contains both positive and negative numbers, is
there a condition to end the search? To answer this question, think of
this example where you could add up to a very large positive number
(with repeated sum of positive numbers) and then repeatedly subtract
down to a very small number. There would be infinitely number of
combinations that can be found, and yet searching could not be stopped
with an ending condition.

void printSum(int candidates[], int index[], int n) { for (int i = 1; i
\<= n; i++) cout \<\< candidates[index[i]] \<\< ((i == n) ? "" : "+");
cout \<\< endl; } void solve(int target, int sum, int candidates[], int
sz, int index[], int n) { if (sum \> target) return; if (sum == target)
printSum(candidates, index, n); for (int i = index[n]; i \< sz; i++) {
index[n+1] = i; solve(target, sum + candidates[i], candidates, sz,
index, n+1); } } void solve(int target, int candidates[], int sz) { int
index[10000]; index[0] = 0; solve(target, 0, candidates, sz, index, 0);
}
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">printSum</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">candidates</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">index</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="v">candidates</span><span class="sy">[</span><span class="v">index</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="v">i</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="s">&quot;&quot;</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="s">&quot;+&quot;</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">endl</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">void</span><span class="h"> </span><span class="e">solve</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">sum</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">candidates</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">sz</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">index</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">sum</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">target</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">sum</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">target</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="e">printSum</span><span class="sy">(</span><span class="i">candidates</span><span class="sy">,</span><span class="h"> </span><span class="i">index</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">index</span><span class="sy">[</span><span class="i">n</span><span class="sy">]</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">sz</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">index</span><span class="sy">[</span><span class="i">n</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">i</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="e">solve</span><span class="sy">(</span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="i">sum</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="v">candidates</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="i">candidates</span><span class="sy">,</span><span class="h"> </span><span class="i">sz</span><span class="sy">,</span><span class="h"> </span><span class="i">index</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">+</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">void</span><span class="h"> </span><span class="e">solve</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">candidates</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">sz</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">index</span><span class="sy">[</span><span class="cn">10000</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">index</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">solve</span><span class="sy">(</span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="i">candidates</span><span class="sy">,</span><span class="h"> </span><span class="i">sz</span><span class="sy">,</span><span class="h"> </span><span class="i">index</span><span class="sy">,</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Further Thoughts:**

Let’s change the question a little bit.

> Find all possible combination of numbers using a pre-defined candidate
> set.  
>  Each number from the candidate set may be used only once in the
> combination.
>
> For example,
>
> Candidate Set = **{10, 1, 2, 7, 6, 1, 5}**  
>  Target Number = **8**
>
> One possible output could be:  
>  **1+1+6  
>  1+2+5  
>  1+7  
>  2+6**

This question is left as an exercise. You should be able to solve this
problem with little modification to the previous algorithm.

The [UVa Online Judge website](http://uva.onlinejudge.org/) has this
same problem called [Problem 574 – Sum It
Up](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=7&page=show_problem&problem=515).
If you don’t know about the UVa Online Judge, it is a website I *highly
recommended*. It has tons of programming problems (ranging from easy to
difficult) to practice. You may also submit your code to their server,
which the machine will run your program against their secret input and
automatically judge if your solution is correct.

VN:F [1.9.22\_1171]

Rating: 2.8/**5** (12 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Print All Combinations of a Number as a Sum of Candidate
Numbers</span></span>, <span class="rating"><span
class="average">2.8</span> out of <span class="best">5</span> based on
<span class="votes">12</span> ratings <span
class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/09/print-all-combinations-of-number-as-sum.html>

Print Edge Nodes (Boundary) of a Binary Tree
============================================

October 20, 2010 <span>in [binary
tree](http://leetcode.com/category/binary-tree "View all posts in binary tree")</span>
<span class="post-utility alignright"></span>

> Print all edge nodes of a complete binary tree anti-clockwise.  
>  That is all the left most nodes starting at root, then the leaves
> left to right and finally all the rightmost nodes.  
>  In other words, print the boundary of the tree.
>
> Variant: Print the same for a tree that is not complete.

<span id="more-50"></span>  
 [<span>Thanks to one
reader</span>](http://www.leetcode.com/2010/09/serializationdeserialization-of-binary.html?showComment=1287501533764#comment-c9201470073217100945)
who contributed this interesting question.

**Some Examples:**  
 \*\* Please see **Further Thoughts** section below for an example which
points out an ambiguity found in the problem statement. \*\* ****

Assume we have a binary tree below:

        _30_
       /    \   
      10    20
     /     /  \
    50    45  35

The correct solution should print **<span>30</span>**,
**<span>10</span>**, **<span>50</span>**, **<span>45</span>**,
**<span>35</span>**, **<span>20</span>**.

Another binary tree:

            ______30______
           /              \
        __20__          __40__
       /      \        /      \
      10      25      35      50
     /  \       \            /
     5  15      28          41

The correct solution should print **<span>30</span>**,
**<span>20</span>**, **<span>10</span>**, **<span>5</span>**,
**<span>15</span>**, **<span>28</span>**,<span> **35**</span>,<span>
**41**</span>,<span> **50**</span>,<span> **40**</span>.

**Hint:**  
 To solve this problem, you first need to pay attention to these three
key areas:

-   Printing the leftmost edges from top to bottom. When a node is a
    leftmost edge, its left child must also be a leftmost edge.
-   Printing the leaves from left to right. Remember depth-first
    traversal?
-   Printing the rightmost edges. You would need to print from bottom to
    top. The key is printing in the opposite order. Easy if you know how
    to manipulate recursion into a stack-based solution. Remember
    post-order traversal?

**Solution:**  
 We could divide the tree into two subtrees. One is the left subtree,
and the other is the right subtree. For the left subtree, we print the
leftmost edges from top to bottom. Then we print its leaves from left to
right. For the right subtree, we print its leaves from left to right,
then its rightmost edges from bottom to top.

Printing the leaves from left to right order is a classic example of
depth-first traversal. If you are not familiar with depth-first
traversal, you should attempt other questions such as [Maximum Height of
a Binary
Tree](http://www.leetcode.com/2010/04/maximum-height-of-binary-tree.html),
[Populating Next Right Pointers in Each
Node](http://www.leetcode.com/2010/03/first-on-site-technical-interview.html).
How do you know if a node is a leaf? Easy, if the node does not have
both left and right children.

Printing the leftmost edges is just a trivial addition to the
depth-first traversal. When a node is a leftmost edge, then its left
child must also be a leftmost edge. We could use a variable to pass this
information down the tree. Please note that you must add the condition
to avoid printing the node twice (a node could be a leftmost edge as
well as a leaf node).

Printing the rightmost edges from bottom to top is easy if you realize
the trick of manipulating recursion as a stack. Try relate this with how
post-order traversal works. When calling recursive functions, function
calls are pushed onto a stack, and therefore you could use the implicit
stack to your advantage. This trick is especially handy when applied in
situation where you need to reverse the order of operations. See my
post: [Recursion to the
Rescue!](http://www.leetcode.com/2010/02/here-is-one-of-questions-from-microsoft.html)
and [Reversing Linked List Iteratively and
Recursively](http://www.leetcode.com/2010/04/reversing-linked-list-iteratively-and.html)
for more practice using this trick.

This solution works whether the tree itself is complete or not.

void printLeftEdges(BinaryTree \*p, bool print) { if (!p) return; if
(print || (!p-\>left && !p-\>right)) cout \<\< p-\>data \<\< " ";
printLeftEdges(p-\>left, print); printLeftEdges(p-\>right, false); }
void printRightEdges(BinaryTree \*p, bool print) { if (!p) return;
printRightEdges(p-\>left, false); printRightEdges(p-\>right, print); if
(print || (!p-\>left && !p-\>right)) cout \<\< p-\>data \<\< " "; } void
printOuterEdges(BinaryTree \*root) { if (!root) return; cout \<\<
root-\>data \<\< " "; printLeftEdges(root-\>left, true);
printRightEdges(root-\>right, true); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">printLeftEdges</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="t">bool</span><span class="h"> </span><span class="i">print</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">print</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="o">!</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">printLeftEdges</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">print</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">printLeftEdges</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="t">false</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">void</span><span class="h"> </span><span class="e">printRightEdges</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="t">bool</span><span class="h"> </span><span class="i">print</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">printRightEdges</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="t">false</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">printRightEdges</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">print</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">print</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="o">!</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">void</span><span class="h"> </span><span class="e">printOuterEdges</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">root</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">printLeftEdges</span><span class="sy">(</span><span class="i">root</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="t">true</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">printRightEdges</span><span class="sy">(</span><span class="i">root</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="t">true</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Further Thoughts:**

Please note that the above problem statement does not give a clear
definition of “left-most” node. Thanks to my dear readers who pointed
out this ambiguity, which I didn’t consider earlier in my above
solution.

For example, consider the binary tree below: Is node<span> </span>**8**
a left-most node?

       _______________28_______________
      /                                \
      4____                        ____69
           \                      /
          __8__                __56__
         /     \              /      \
       __7     12__        __34    __27__
      /            \      /       /      \
      5_          _13    _2      _3      39
        \        /      /       /
         6      11     10       9

The above code prints: **<span>28</span>**, **<span>4</span>**,
**<span>6</span>**, **<span>11</span>**, **<span>10</span>**,<span>
**9**</span>,<span> **39**</span>,<span> **69**</span>.

It seems that nodes **8**, **7**, and **5** should be left-most nodes as
well, but are not printed by the above code. This is because we made an
implicit assumption that all left-most nodes could only be reached by
following each node’s left branch (similar for right-most nodes).

To remedy this, we use a modified recursive definition for left-most
node (similar for right-most node):

-   If a node is a left-most node, then its left child must be a
    left-most node as well.
-   If its left child does not exist, then its right child will be a
    left-most node.

The below code prints the correct output of: **<span>28</span>**,
**<span>4</span>**, **<span>8</span>**, **<span>7</span>**,
**<span>5</span>**, **<span>6</span>**,**<span> 11</span>**,<span>
**10**</span>,<span> **9**</span>,<span> **39**</span>,<span>
**27**</span>,<span> **56**</span>,<span> **69**</span>.

All that are needed is just two lines of code changes.

    void printLeftEdges(BinaryTree *p, bool print) {
      if (!p) return;
      if (print || (!p->left && !p->right))
        cout data left, print);
      printLeftEdges(p->right, (print && !p->left ? true : false));
    }

    void printRightEdges(BinaryTree *p, bool print) {
      if (!p) return;
      printRightEdges(p->left, (print && !p->right ? true : false));
      printRightEdges(p->right, print);
      if (print || (!p->left && !p->right))
        cout data data left, true);
      printRightEdges(root->right, true);
    }

<span>**Note:**</span>  
 Some readers claimed that the above algorithm does not always print all
edge nodes. For example, by moving node **<span>5</span>** to be the
left child of node **<span>12</span>**, we get the binary tree below:

       _______________28_______________
      /                                \
      4___                         ____69
          \                       /
        ___8__                 __56__
       /      \               /      \
       7    __12___        __34    __27__
           /       \      /       /      \
          5_      _13    _2      _3      39
            \    /      /       /
             6  11     10       9

And the algorithm in the <span>Further Thoughts</span> section prints
the following:  
 **<span>28</span>**, **<span>4</span>**, **<span>8</span>**,
**<span>7</span>**, **<span>6</span>**,**<span> 11</span>**,<span>
**10**</span>,<span> **9**</span>,<span> **39**</span>,<span>
**27**</span>,<span> **56**</span>,<span> **69**</span>.

Some readers argued that node **<span>5</span>** should be printed too.
However, if you read the definition of “left-most node” carefully in the
above section, you would agree with me that node **<span>5</span>** is
not a left-most node. This is because node **<span>8</span>** (which is
a left-most node) has a left child, node **<span>7</span>**. Therefore,
node **<span>7</span>** is a left-most node but not node
**<span>12</span>**. As a result, all descendants of node
**<span>12</span>** must not be left-most nodes.

You could use your own definition of left-most node as you pleased, but
keep in mind that the problem statement is ambiguous to start with, so
communicating this with your interviewer will be your best bet.

VN:F [1.9.22\_1171]

Rating: 5.0/**5** (20 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Print Edge Nodes (Boundary) of a Binary Tree</span></span>,
<span class="rating"><span class="average">5.0</span> out of <span
class="best">5</span> based on <span class="votes">20</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/10/print-edge-nodes-boundary-of-binary.html>

Printing a Binary Tree in Level Order
=====================================

September 16, 2010 <span>in [binary
tree](http://leetcode.com/category/binary-tree "View all posts in binary tree")</span>
<span class="post-utility alignright"></span>

> Given a binary tree, print out the tree in level order (ie, from left
> to right, level by level). Output a newline after the end of each
> level.<span id="more-38"></span>
>
>          3
>        /  \
>       9   20    
>          /  \
>         15    7
>
> For example, the level order output of the tree above is:
>
>     3 
>     9 20 
>     15 7

By now, you should be able to do pre-order, in-order, and post-order
tree traversal off the top of your head. These are called [Depth First
Search](http://en.wikipedia.org/wiki/Depth-first_search) (DFS), since
they visit the tree by proceeding deeper and deeper until it reaches the
leaf nodes.

DFS uses a data structure called
[Stack](http://en.wikipedia.org/wiki/Stack_%28data_structure%29) and is
commonly implemented using recursion (since function calls are pushed
and popped off the memory stack). If recursion is not allowed, we can
simulate the recursion by using iterative method with the help of stack.
See my older post: [Binary Search Tree In-Order Traversal Iterative
Solution](http://www.leetcode.com/2010/04/binary-search-tree-in-order-traversal.html)
on how to do a DFS iteratively using a stack.

The most natural solution for level-order traversal is [Breadth First
Search](http://en.wikipedia.org/wiki/Breadth-first_search) (BFS), since
it visits the nodes level by level. BFS requires the use of a data
structure called
[Queue](http://en.wikipedia.org/wiki/Queue_%28data_structure%29), which
is a First In First Out (FIFO) structure. If you are curious,
level-order traversal can be implemented using DFS too. See my next
post: [Binary Tree Level-Order Traversal Using Depth First Search
(DFS)](http://www.leetcode.com/2010/09/binary-tree-level-order-traversal-using_17.html)
for the challenge.

In order to print the binary tree in level order with newline in the end
of each level, we can utilize two queues. The first queue stores the
current level’s nodes, while the second queue stores the next level’s
nodes (the current level nodes’ children).

When the first queue is emptied, we know that it must have reached the
end of the current level, therefore we print a newline. Then, we switch
the emptied first queue with the second queue (which is populated with
the next level’s nodes). Then we repeat the process over again.

void printLevelOrder(BinaryTree \*root) { if (!root) return;
queue\<BinaryTree\*\> currentLevel, nextLevel; currentLevel.push(root);
while (!currentLevel.empty()) { BinaryTree \*currNode =
currentLevel.front(); currentLevel.pop(); if (currNode) { cout \<\<
currNode-\>data \<\< " "; nextLevel.push(currNode-\>left);
nextLevel.push(currNode-\>right); } if (currentLevel.empty()) { cout
\<\< endl; swap(currentLevel, nextLevel); } } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">printLevelOrder</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">queue</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="h"> </span><span class="i">currentLevel</span><span class="sy">,</span><span class="h"> </span><span class="i">nextLevel</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">currentLevel</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">root</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">currentLevel</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="e">BinaryTree *</span><span class="v">currNode</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">currentLevel</span><span class="sy">.</span><span class="e">front</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">currentLevel</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">currNode</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">currNode</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">nextLevel</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">currNode</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">nextLevel</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">currNode</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">currentLevel</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">endl</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="e">swap</span><span class="sy">(</span><span class="i">currentLevel</span><span class="sy">,</span><span class="h"> </span><span class="i">nextLevel</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

Is it possible that a solution exists using only one single queue? Yes,
you bet. The single queue solution requires two extra counting variables
which keep tracks of the number of nodes in the current level
(***nodesInCurrentLevel***) and the next level (***nodesInNextLevel***).
When we pop a node off the queue, we decrement ***nodesInCurrentLevel***
by *one*. When we push its child nodes to the queue, we increment
***nodesInNextLevel*** by *two*. When ***nodesInCurrentLevel*** reaches
*0*, we know that the current level has ended, therefore we print an
endline here.

void printLevelOrder(BinaryTree \*root) { if (!root) return;
queue\<BinaryTree\*\> nodesQueue; int nodesInCurrentLevel = 1; int
nodesInNextLevel = 0; nodesQueue.push(root); while (!nodesQueue.empty())
{ BinaryTree \*currNode = nodesQueue.front(); nodesQueue.pop();
nodesInCurrentLevel--; if (currNode) { cout \<\< currNode-\>data \<\< "
"; nodesQueue.push(currNode-\>left); nodesQueue.push(currNode-\>right);
nodesInNextLevel += 2; } if (nodesInCurrentLevel == 0) { cout \<\< endl;
nodesInCurrentLevel = nodesInNextLevel; nodesInNextLevel = 0; } } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">printLevelOrder</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">queue</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="h"> </span><span class="i">nodesQueue</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">nodesInCurrentLevel</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">nodesInNextLevel</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">root</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="e">BinaryTree *</span><span class="v">currNode</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">front</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">nodesInCurrentLevel</span><span class="o">--</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">currNode</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">currNode</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">currNode</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">nodesQueue</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">currNode</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="i">nodesInNextLevel</span><span class="h"> </span><span class="o">+</span><span class="o">=</span><span class="h"> </span><span class="cn">2</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">nodesInCurrentLevel</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">endl</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">nodesInCurrentLevel</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">nodesInNextLevel</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">nodesInNextLevel</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.7/**5** (62 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Printing a Binary Tree in Level Order</span></span>, <span
class="rating"><span class="average">4.7</span> out of <span
class="best">5</span> based on <span class="votes">62</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/09/printing-binary-tree-in-level-order.html>

### Leave a reply

### 7 trackbacks

-   *on October 13, 2012*
-   *on October 20, 2012*
-   *on December 25, 2012*
-   *on October 14, 2013*
-   *on November 19, 2013*
-   *on August 11, 2014*
-   *on January 5, 2015*

Printing a Binary Tree in Zig Zag Level-Order
=============================================

September 18, 2010 <span>in [binary
tree](http://leetcode.com/category/binary-tree "View all posts in binary tree")</span>
<span class="post-utility alignright"></span>

> Given a binary tree, print out the tree in zig zag level order (ie,
> from left to right, then right to left for the next level and
> alternate between). Output a newline after the end of each level.<span
> id="more-40"></span>
>
>          3
>        /  \
>       9   20    
>          /  \
>         15    7
>
> For example, the zig zag level order output of the tree above is:
>
>     3 
>     20 9
>     15 7

This question is a variation of the question [Printing a Binary Tree in
Level
Order](http://www.leetcode.com/2010/09/printing-binary-tree-in-level-order.html).

**Hint:**  
[Queue](http://en.wikipedia.org/wiki/Queue_%28data_structure%29) is not
helpful here. You might want to consider using
[Stack](http://en.wikipedia.org/wiki/Stack_%28data_structure%29)
instead.

**Solution:**  
This problem can be solved easily using two stacks (one called
*currentLevel* and the other one called *nextLevel*). You would also
need a variable to keep track of the current level’s order (whether it
is left-\>right or right-\>left).

You pop from stack *currentLevel* and print the node’s value. Whenever
the current level’s order is from left-\>right, you push the node’s left
child, then its right child to stack *nextLevel*. Remember a Stack is a
Last In First OUT (LIFO) structure, so the next time when nodes are
popped off *nextLevel*, it will be in the reverse order.

On the other hand, when the current level’s order is from right-\>left,
you would push the node’s right child first, then its left child.
Finally, don’t forget to swap those two stacks at the end of each level
(ie, when *currentLevel* is empty).

void printLevelOrderZigZag(BinaryTree \*root) { stack\<BinaryTree\*\>
currentLevel, nextLevel; bool leftToRight = true;
currentLevel.push(root); while (!currentLevel.empty()) {
BinaryTree \*currNode = currentLevel.top(); currentLevel.pop(); if
(currNode) { cout \<\< currNode-\>data \<\< " "; if (leftToRight) {
nextLevel.push(currNode-\>left); nextLevel.push(currNode-\>right); }
else { nextLevel.push(currNode-\>right);
nextLevel.push(currNode-\>left); } } if (currentLevel.empty()) { cout
\<\< endl; leftToRight = !leftToRight; swap(currentLevel, nextLevel); }
} }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">printLevelOrderZigZag</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">root</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="i">stack</span><span class="o">&lt;</span><span class="e">BinaryTree*</span><span class="o">&gt;</span><span class="h"> </span><span class="i">currentLevel</span><span class="sy">,</span><span class="h"> </span><span class="i">nextLevel</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">bool</span><span class="h"> </span><span class="v">leftToRight</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">currentLevel</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">root</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">currentLevel</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="e">BinaryTree *</span><span class="v">currNode</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">currentLevel</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">currentLevel</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">currNode</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">currNode</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">leftToRight</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">nextLevel</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">currNode</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">nextLevel</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">currNode</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">nextLevel</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">currNode</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">nextLevel</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">currNode</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">currentLevel</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">endl</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">leftToRight</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="o">!</span><span class="i">leftToRight</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="e">swap</span><span class="sy">(</span><span class="i">currentLevel</span><span class="sy">,</span><span class="h"> </span><span class="i">nextLevel</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.8/**5** (34 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Printing a Binary Tree in Zig Zag Level-Order</span></span>,
<span class="rating"><span class="average">4.8</span> out of <span
class="best">5</span> based on <span class="votes">34</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/09/printing-binary-tree-in-zig-zag-level_18.html>

### Leave a reply

### 4 trackbacks

-   *on October 20, 2012*
-   *on October 20, 2012*
-   *on December 25, 2012*
-   *on October 8, 2014*

Printing Matrix (2D array) in Spiral Order
==========================================

May 1, 2010 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> Given a matrix (2D array) of m x n elements (m rows, n columns), write
> a function that prints the elements in the array in a spiral manner.

<span id="more-21"></span>

If you have done enough training by now, you would have immediately
recognized the sub-problems within this problem. When you recognize this
property, then you know that this problem is easily solvable with
recursion!

Imagine that you are peeling an onion (I know your eye hurts!). First,
you peel off the outer-layer skin. After the first layer is peeled off,
there’s another layer to peel. So you peel off the remaining onion again
until there is no more to peel, which is where you stop.

It’s the same with printing the matrix spirally! Print the outer layer
of the matrix, then print the remaining sub-matrix recursively. Please
do not forget to handle the base case! (Hint: Check when m == 1 or n ==
1).

void print\_spiral(int mat[][N\_MAX], int m, int n, int k) { if (m \<= 0
|| n \<= 0) return; if (m == 1) { for (int j = 0; j \< n; j++) cout \<\<
mat[k][k+j] \<\< " "; return; } if (n == 1) { for (int i = 0; i \< m;
i++) cout \<\< mat[k+i][k] \<\< " "; return; } // print from top left
for (int j = 0; j \< n - 1; j++) cout \<\< mat[k][k+j] \<\< " "; //
print from top right for (int i = 0; i \< m - 1; i++) cout \<\<
mat[k+i][k+n-1] \<\< " "; // print from bottom right for (int j = 0; j
\< n - 1; j++) cout \<\< mat[k+m-1][k+n-1-j] \<\< " "; // print from
bottom left for (int i = 0; i \< m - 1; i++) cout \<\< mat[k+m-1-i][k]
\<\< " "; print\_spiral(mat, m-2, n-2, k+1); } void
print\_spiral\_helper(int mat[][N\_MAX], int m, int n) {
print\_spiral(mat, m, n, 0); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">print_spiral</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="sy">]</span><span class="sy">[</span><span class="i">N_MAX</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">m</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">k</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">m</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="cn">0</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">n</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">m</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">k</span><span class="sy">]</span><span class="sy">[</span><span class="i">k</span><span class="o">+</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">n</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">m</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">k</span><span class="o">+</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">k</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="c">// print from top left</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">k</span><span class="sy">]</span><span class="sy">[</span><span class="i">k</span><span class="o">+</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="c">// print from top right</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">m</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">k</span><span class="o">+</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">k</span><span class="o">+</span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="c">// print from bottom right</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">k</span><span class="o">+</span><span class="i">m</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">k</span><span class="o">+</span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="o">-</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="c">// print from bottom left</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">m</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">k</span><span class="o">+</span><span class="i">m</span><span class="o">-</span><span class="cn">1</span><span class="o">-</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">k</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="e">print_spiral</span><span class="sy">(</span><span class="i">mat</span><span class="sy">,</span><span class="h"> </span><span class="i">m</span><span class="o">-</span><span class="cn">2</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="cn">2</span><span class="sy">,</span><span class="h"> </span><span class="i">k</span><span class="o">+</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">void</span><span class="h"> </span><span class="e">print_spiral_helper</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="sy">]</span><span class="sy">[</span><span class="i">N_MAX</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">m</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="e">print_spiral</span><span class="sy">(</span><span class="i">mat</span><span class="sy">,</span><span class="h"> </span><span class="i">m</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

<span>**EDIT: (Added test data)**</span>  
Below are the input and output data set I created for testing purposes.
In the input file, the first line signifies the total number of cases.
Then all cases are listed where the the number of row and column are
specified first, then followed by elements of all rows and columns.

**Attachment:**  
» [Download Input Data
Set](https://sites.google.com/site/ihas1337code/matrix_spiral_input.txt)  
» [Download Output Data
Set](https://sites.google.com/site/ihas1337code/matrix_spiral_output.txt)

VN:F [1.9.22\_1171]

Rating: 4.5/**5** (11 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Printing Matrix (2D array) in Spiral Order</span></span>,
<span class="rating"><span class="average">4.5</span> out of <span
class="best">5</span> based on <span class="votes">11</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/05/printing-matrix-in-spiral-order.html>

> Read the question here from GCJ Qualification Round 2010:  
> » [Problem B: Fair
> Warning](http://code.google.com/codejam/contest/dashboard?c=433101#s=p1)

<span id="more-26"></span>

This problem is cryptic in description, but it can be summarize as a
Math problem below:

> Given a list of positive integers: t<sub>1</sub>, t<sub>2</sub>, …,
> t<sub>n</sub>, and t<sub>i</sub> ? t<sub>j</sub> for some i, j. Find
> the smallest integer y \>= 0 such that each t<sub>i</sub> + y is
> divisible by an integer T. T must be the largest of all possible
> divisors.

First, this problem is named “Fair Warning” for a reason. It is a fair
warning to you that a problem using Big Integer library is possible
(which the large input requires), and you should prepare for that in
future rounds.

I guess many would agree that this is the hardest problem for most
people. If you know basic number theory, you would probably breeze
through this problem. If you don’t (like me), it is still possible to
find your way to the solution, but it is a bit harder.

Before we go for the general solution, let’s consider the easier case
where n=2, and assume t<sub>1</sub> is greater than t<sub>2</sub>.

Therefore,  
t<sub>1</sub> + y = k<sub>1</sub> \* T —– (1)  
t<sub>2</sub> + y = k<sub>2</sub> \* T —– (2)

t<sub>i</sub>, y, k<sub>i</sub>, and T are all integers.

Eq. (1) – (2) gives  
t<sub>1</sub> – t<sub>2</sub> = (k<sub>1</sub> – k<sub>2</sub>) \* T

Therefore, we can conclude that t<sub>1</sub> – t<sub>2</sub> is also
divisible by T. Since T must be the largest among all possible divisors,
k<sub>1</sub> – k<sub>2</sub> must equal 1. Why? Consider when
k<sub>1</sub> – k<sub>2</sub> = 2, then the value of T would be halved.
We have just found the value of T, which is equal to t<sub>1</sub> –
t<sub>2</sub>.

After we have found the value of T, we can obtain value of y. From the
previous information that k<sub>1</sub> – k<sub>2</sub> = 1, we can
deduce from Eq. (1) and (2) that k<sub>2</sub> = 1 and k<sub>1</sub> =
2. Why not k<sub>2</sub> = 2 and k<sub>1</sub> = 3? Recall that y is the
smallest value that fulfill the requirement.

Substituting in Eq. (2), we get  
y = k<sub>2</sub> \* T – t<sub>2</sub>  
 = 1 \* (t<sub>1</sub> – t<sub>2</sub>) – t<sub>2</sub>  
 = t<sub>1</sub> – 2 \* t<sub>2</sub>

We have solved the easy case. Now generalize for all cases. You can
probably see that for n \>= 3, the value of T is equal to the Greatest
Common Divisor (GCD) of all possible t<sub>i</sub> – t<sub>j</sub>, i ?
j, t<sub>i</sub> \> t<sub>j</sub>. Note that finding all such possible
pairs of i and j takes O(n^2) time.

Once we found the value of T, we can then solve for y.

For large input, you have to use a Big Integer library and there is one
possible optimization. When a = b = c, then gcd(b – a, c – a) = gcd(b –
a, c – a, c – b). Taking advantage of this property, we are able to
reduce the GCD step from O(n^2) to O(n).

The below solution only works for the small input (without the
optimization mentioned above). Unfortunately, it timeouts for the large
input. (I am using my own Big Integer library). I suspect that my Big
Integer library is not efficient enough. I would love to know if you
have tested my solution using a Big Integer library and if it finishes
within the time limit. Anyway, the below solution gives a general idea
on how to approach this problem.

long long gcd(long long a, long long b) { if (b == 0) return a; return
gcd(b, a % b); } long long gcd(long long arr[], int n) { long long temp
= arr[0]; for (int i = 1; i \< n; i++) { temp = gcd(temp, arr[i]); }
return temp; } int n, m; long long arr[1400], arr2[100000]; cin \>\> n;
for (int i = 0; i \< n; i++) { cin \>\> m; for (int j = 0; j \< m; j++)
cin \>\> arr[j]; sort(arr, arr+m); int sz = 0; for (int j = m-1; j \>=0;
j--) { for (int k = j-1; k \>= 0; k--) { arr2[sz++] = arr[j]-arr[k]; } }
long long T = gcd(arr2, sz); long long ans = (ceil((double)arr[0] /
T))\*T - arr[0]; cout \<\< "Case \#" \<\< i+1 \<\< ": " \<\< ans \<\<
endl; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">long</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="e">gcd</span><span class="sy">(</span><span class="t">long</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="i">a</span><span class="sy">,</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="i">b</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">b</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="i">a</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="e">gcd</span><span class="sy">(</span><span class="i">b</span><span class="sy">,</span><span class="h"> </span><span class="i">a</span><span class="h"> </span><span class="o">%</span><span class="h"> </span><span class="i">b</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">long</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="e">gcd</span><span class="sy">(</span><span class="t">long</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">long</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="v">temp</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">temp</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">gcd</span><span class="sy">(</span><span class="i">temp</span><span class="sy">,</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">temp</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="i">m</span><span class="sy">;</span></p>
<p><span class="t">long</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="cn">1400</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="v">arr2</span><span class="sy">[</span><span class="cn">100000</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span></p>
<p><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">m</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">m</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span></p>
<p><span class="h">    </span><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="e">sort</span><span class="sy">(</span><span class="i">arr</span><span class="sy">,</span><span class="h"> </span><span class="i">arr</span><span class="o">+</span><span class="i">m</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">sz</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">m</span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&gt;=</span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="o">--</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">k</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">j</span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">k</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">k</span><span class="o">--</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">arr2</span><span class="sy">[</span><span class="i">sz</span><span class="o">++</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="o">-</span><span class="v">arr</span><span class="sy">[</span><span class="i">k</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="t">long</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="v">T</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">gcd</span><span class="sy">(</span><span class="i">arr2</span><span class="sy">,</span><span class="h"> </span><span class="i">sz</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">long</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="v">ans</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="e">ceil</span><span class="sy">(</span><span class="sy">(</span><span class="t">double</span><span class="sy">)</span><span class="v">arr</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="i">T</span><span class="sy">)</span><span class="sy">)</span><span class="o">*</span><span class="i">T</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="v">arr</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;Case #&quot;</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">i</span><span class="o">+</span><span class="cn">1</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;: &quot;</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">ans</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">endl</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.3/**5** (4 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Problem B: Fair Warning Solution (Google Code Jam
Qualification Round 2010)</span></span>, <span class="rating"><span
class="average">4.3</span> out of <span class="best">5</span> based on
<span class="votes">4</span> ratings <span
class="summary"></span></span></span>

> Read the question here from GCJ Qualification Round 2010:  
> » [Problem C: Theme
> Park](http://code.google.com/codejam/contest/dashboard?c=433101#s=p2)

<span id="more-27"></span>

This question is the easiest to understand, and is also the easiest to
solve (for the small input). It’s tricky for the large input though, as
you can see from the statistics — Only **40%** of the submitted attempts
are correct. First, I’ll explain the easy way to solve this question
which works for the small input. Then, I’ll explain why the large input
is tricky to solve.

The first thing that might come to your mind is, what is a good data
structure to represent the groups of people? A natural and appropriate
choice is to use a queue.

To fill people into the roller coaster, you pop the first group from the
front. Then the second, and third… Eventually you stop when the roller
coaster is unable to fill the next group, or when the queue has been
emptied.

For the next ride, push all previous groups to the back of the queue,
and repeat the same steps again for a total of **R** times. (**R** is
the total \# of rides).

Alright, easy enough. You’ve passed the small input, and now you’re
going for the large input.

Wait! We haven’t looked at the complexity of this solution. Since you
are repeating **R** times, and each time there are at most **N** groups
to fit in the roller coaster, the worst case is in the order of
O(**R**\***N**). For the large input, the biggest **R** is 10^8 and the
biggest N is 1000. Besides, there are at most 50 input set, which means
the complexity is in the order of 10^12. Do you think this will run
within minutes? (Hint: A solution that runs in minutes must be in the
order of less than 10^9.)

Therefore, we need a different strategy! There are multiple
optimizations given in Google’s [contest
analysis](http://code.google.com/codejam/contest/dashboard?c=433101#s=a),
but here are two of my observations:

1) We can use an array as the data structure. We do not have to move the
contents of the array, as we can use an index which tells us where does
the queue start. The index wraps around, which makes the array a
circular array. This is much more efficient than using a queue.

2) We can exchange space for speed. Pre-processing comes to mind. At any
index of the queue, we can know exactly where the next queue starts at.
We can also be definite how many people will fit in the roller coaster
for any starting index of queue. We store these two information in two
tables. The pre-processing step has a complexity of O(**N**^2).

Using optimization 2) above, the complexity decreases to either
O(**N**^2) or O(**R**), depend on which is bigger – **N**^2 or **R**.

We are almost done, however there is another trap. Note that each
group’s number, **g<sub>i</sub>** could be as large as 10^7. There might
be a case where you might add all **g<sub>i</sub>**, from i=1 to i=N,
therefore the sum could be as large as 10^10, which is more than what a
32 bit integer could store. In short, just use 64 bit integer for the
sum.

int n; cin \>\> n; for (int m = 0; m \< n; m++) { long long R, k, N;
cin \>\> R \>\> k \>\> N; long long li[2000]; for (int i = 0; i \< N;
i++) cin \>\> li[i]; long long result\_money[2000] = {0}; int
result\_st[2000] = {0}; for (int h = 0; h \< N; h++) { long long sum =
0; int st = h; bool done = false; for (int b = 0; b \< N; b++) { if
(sum + li[(h+b)%N] \<= k) { sum += li[(h+b)%N]; st = (st+1)%N; } else {
result\_money[h] = sum; result\_st[h] = st; done = true; break; } } if
(!done) { result\_money[h] = sum; result\_st[h] = st; } } long long
money = 0; int st = 0; for (long long i = 0; i \< R; i++) { money +=
result\_money[st]; st = result\_st[st]; } cout \<\< "Case \#" \<\< m + 1
\<\< ": " \<\< money \<\< endl; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span></p>
<p><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span></p>
<p><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">m</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">m</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">m</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">long</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="i">R</span><span class="sy">,</span><span class="h"> </span><span class="i">k</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">R</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">k</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">N</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">long</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="v">li</span><span class="sy">[</span><span class="cn">2000</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">N</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span></p>
<p><span class="h">    </span><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="v">li</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="t">long</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="v">result_money</span><span class="sy">[</span><span class="cn">2000</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">{</span><span class="cn">0</span><span class="sy">}</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">result_st</span><span class="sy">[</span><span class="cn">2000</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">{</span><span class="cn">0</span><span class="sy">}</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">h</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">h</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">N</span><span class="sy">;</span><span class="h"> </span><span class="i">h</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">long</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="v">sum</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">st</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">h</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">bool</span><span class="h"> </span><span class="v">done</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">b</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">b</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">N</span><span class="sy">;</span><span class="h"> </span><span class="i">b</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">sum</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="v">li</span><span class="sy">[</span><span class="sy">(</span><span class="i">h</span><span class="o">+</span><span class="i">b</span><span class="sy">)</span><span class="o">%</span><span class="i">N</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">k</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="i">sum</span><span class="h"> </span><span class="o">+</span><span class="o">=</span><span class="h"> </span><span class="v">li</span><span class="sy">[</span><span class="sy">(</span><span class="i">h</span><span class="o">+</span><span class="i">b</span><span class="sy">)</span><span class="o">%</span><span class="i">N</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">st</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="i">st</span><span class="o">+</span><span class="cn">1</span><span class="sy">)</span><span class="o">%</span><span class="i">N</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">result_money</span><span class="sy">[</span><span class="i">h</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">sum</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">result_st</span><span class="sy">[</span><span class="i">h</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">st</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="v">done</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">        </span><span class="st">break</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">done</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">result_money</span><span class="sy">[</span><span class="i">h</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">sum</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">result_st</span><span class="sy">[</span><span class="i">h</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">st</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="t">long</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="v">money</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">st</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">long</span><span class="h"> </span><span class="t">long</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">R</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">money</span><span class="h"> </span><span class="o">+</span><span class="o">=</span><span class="h"> </span><span class="v">result_money</span><span class="sy">[</span><span class="i">st</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">st</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">result_st</span><span class="sy">[</span><span class="i">st</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;Case #&quot;</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">m</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;: &quot;</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">money</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">endl</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 5.0/**5** (1 vote cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Problem C: Theme Park Solution (Google Code Jam Qualification
Round 2010)</span></span>, <span class="rating"><span
class="average">5.0</span> out of <span class="best">5</span> based on
<span class="votes">1</span> rating <span
class="summary"></span></span></span>

Problem A: Snapper Chain Solution (Google Code Jam Qualification Round 2010)
============================================================================

May 8, 2010 <span>in [bit
operations](http://leetcode.com/category/bit-operations "View all posts in bit operations")</span>
<span class="post-utility alignright"></span>

> Read the question here from GCJ Qualification Round 2010:  
> » [Problem A: Snapper
> Chain](http://code.google.com/codejam/contest/dashboard?c=433101#s=p0)

<span id="more-25"></span>

Once you understand how the snapper works, it is easy. This problem can
be solved in various ways, but the main observations are:

Let *k* be the number of times you snap your finger, *n* be the light’s
position, and assume 0 = OFF and 1 = ON.

The configuration of the first five snappers (with the first snapper on
the far left side) as *k* increases are:  
**00000** *k* = 0  
**10000** *k* = 1  
**01000** *k* = 2  
**11000** *k* = 3  
**00100** *k* = 4  
**10100** *k* = 5  
**01100** *k* = 6  
**11100** *k* = 7  
**00010** *k* = 8

See the pattern? The configuration of the snapper for any *k* is the
binary representation of *k* itself!

For example, when *k*=3 and *n*=3, we know that the light is OFF because
the snapper is in the OFF position (because the 3rd bit of *k*=3 is 0).
When *k*=3 and *n*=2, the light is ON. However, when *k*=5 and *n*=3,
the light is OFF even though the 3rd bit is 1. As the 2nd bit is 0, the
electric couldn’t “flow” to the light bulb.

Therefore, in order for a bulb to light, it requires all of the bits
from 1 to *n* to be all 1s.

The problem can still be solved using arrays representing the bits and
iterate through them to check, but it is more efficient using bit
manipulation. If you are familiar with bit manipulation, you can check
if the bits from 1 to *n* are all 1s using the XOR operation and some
bit shifting. My solution is shown below. This is just one sample
solution. If you have a more elegant solution, you are welcome to add to
that in the comments section.

int T, n, k; cin \>\> T; for (int i = 0; i \< T; i++) { cin \>\> n \>\>
k; cout \<\< "Case \#" \<\< i + 1 \<\< ": "; if (((1 \<\< (n-1)) ^ (k &
((1 \<\< n)-1))) == ((1 \<\< (n-1))-1)) { cout \<\< "ON\\n"; } else {
cout \<\< "OFF\\n"; } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="i">T</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="i">k</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">T</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">T</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">n</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">k</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;Case #&quot;</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;: &quot;</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="sy">(</span><span class="cn">1</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="o">^</span><span class="h"> </span><span class="sy">(</span><span class="i">k</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="cn">1</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="cn">1</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="sy">(</span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">)</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;ON\n&quot;</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;OFF\n&quot;</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 2.7/**5** (3 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Problem A: Snapper Chain Solution (Google Code Jam
Qualification Round 2010)</span></span>, <span class="rating"><span
class="average">2.7</span> out of <span class="best">5</span> based on
<span class="votes">3</span> ratings <span
class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/05/problem-snapper-chain-gcj-qualification.html>

> Implement regular expression matching with support for ‘.’ and ‘\*’.

<span id="more-877"></span>

‘.’ Matches any single character.  
 ‘\*’ Matches zero or more of the preceding element.
The matching should cover the **entire** input string (not partial).

The function prototype should be:  
 bool isMatch(const char \*s, const char \*p)

Some examples:  
 isMatch(“aa”,”a”) → false  
 isMatch(“aa”,”aa”) → true  
 isMatch(“aaa”,”aa”) → false  
 isMatch(“aa”, “a\*”) → true  
 isMatch(“aa”, “.\*”) → true  
 isMatch(“ab”, “.\*”) → true  
 isMatch(“aab”, “c\*a\*b”) → true

**<span>Online Judge</span>**  
 This problem is available at [Online
Judge](http://www.leetcode.com/onlinejudge). [Head over
there](http://www.leetcode.com/onlinejudge) and it will judge your
solution. Currently only able to compile C++/Java code. If you are using
other languages, you can still verify your solution by looking at the
judge’s test cases and its expected output.

**Background:**  
 It might seem deceptively easy even you know the general idea, but
programming it correctly with all the details require careful thought.

**<span>Edit:</span>**  
 It seems that some readers are confused about why the regex pattern
“.\*” matches the string “ab”. “.\*” means repeat the *preceding*
element 0 or more times. Here, the *“preceding”* element is the **dot**
character in the *pattern*, which can match any characters. Therefore,
the regex pattern “.\*” allows the dot to be repeated any number of
times, which matches any string (even an empty string).

**Hints:**  
 Think carefully how you would do matching of ‘\*’. Please note that
‘\*’ in regular expression is *different* from wildcard matching, as we
match the previous character 0 or more times. But, how many times? If
you are stuck, recursion is your friend.

This problem is a tricky one. Due to the huge number of edge cases, many
people would write lengthy code and have numerous bugs on their first
try. Try your best getting your code correct first, then refactor
mercilessly to as clean and concise as possible!

[![](http://www.leetcode.com/wp-content/uploads/2011/08/DFAsmall.png "DFAsmall")](http://www.leetcode.com/wp-content/uploads/2011/08/DFAsmall.png)  
 A sample diagram of a deterministic finite state automata (DFA). DFAs
are useful for doing lexical analysis and pattern matching. An example
is UNIX’s grep tool. Please note that this post does not attempt to
descibe a solution using DFA.

**Solution:**  
 This looks just like a straight forward string matching, isn’t it?
Couldn’t we just match the pattern and the input string character by
character? The question is, how to match a ‘\*’?

A natural way is to use a greedy approach; that is, we attempt to match
the previous character as many as we can. Does this work? Let us look at
some examples.

*s* = “abbbc”, *p* = “ab\*c”  
 Assume we have matched the first ‘a’ on both *s* and *p*. When we see
“b\*” in *p*, we skip all b’s in *s*. Since the last ‘c’ matches on both
side, they both match.

*s* = “ac”, *p* = “ab\*c”  
 After the first ‘a’, we see that there is no b’s to skip for “b\*”. We
match the last ‘c’ on both side and conclude that they both match.

It seems that being greedy is good. But how about this case?

*s* = “abbc”, *p* = “ab\*bbc”  
 When we see “b\*” in *p*, we would have skip all b’s in s. They both
should match, but we have no more b’s to match. Therefore, the greedy
approach fails in the above case.

One might be tempted to think of a quick workaround. How about counting
the number of consecutive b’s in *s*? If it is smaller or equal to the
number of consecutive b’s after “b\*” in *p*, we conclude they both
match and continue from there. For the opposite, we conclude there is
not a match.

This seem to solve the above problem, but how about this case:  
 *s* = “abcbcd”, *p* = “a.\*c.\*d”

Here, “.\*” in *p* means repeat ‘.’ 0 or more times. Since ‘.’ can match
any character, it is not clear how many times ‘.’ should be repeated.
Should the ‘c’ in *p* matches the first or second ‘c’ in *s*?
Unfortunately, there is no way to tell without using some kind of
exhaustive search.

We need some kind of backtracking mechanism such that when a matching
fails, we return to the last successful matching state and attempt to
match more characters in *s* with ‘\*’. This approach leads naturally to
recursion.

The recursion mainly breaks down elegantly to the following two cases:

1.  If the next character of *p* is **NOT** ‘\*’, then it must match the
    current character of *s*. Continue pattern matching with the next
    character of both *s* and *p*.
2.  If the next character of *p* is ‘\*’, then we do a brute force
    exhaustive matching of 0, 1, or more repeats of current character of
    *p*… Until we could not match any more characters.

You would need to consider the base case carefully too. That would be
left as an exercise to the reader.
![:)](http://leetcode.com/wp-includes/images/smilies/icon_smile.gif)

Below is the extremely concise code (Excluding comments and asserts,
it’s about 10 lines of code).

bool isMatch(const char \*s, const char \*p) { assert(s && p); if (\*p
== '\\0') return \*s == '\\0'; // next char is not '\*': must match
current character if (\*(p+1) != '\*') { assert(\*p != '\*'); return
((\*p == \*s) || (\*p == '.' && \*s != '\\0')) && isMatch(s+1, p+1); }
// next char is '\*' while ((\*p == \*s) || (\*p == '.' && \*s !=
'\\0')) { if (isMatch(s, p+2)) return true; s++; } return isMatch(s,
p+2); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">bool</span><span class="h"> </span><span class="e">isMatch</span><span class="sy">(</span><span class="m">const</span><span class="h"> </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="i">s</span><span class="sy">,</span><span class="h"> </span><span class="m">const</span><span class="h"> </span><span class="t">char</span><span class="h"> </span><span class="o">*</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">assert</span><span class="sy">(</span><span class="i">s</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">p</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="v">p</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="s">'\0'</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="o">*</span><span class="v">s</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="s">'\0'</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="c">// next char is not '*': must match current character</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="sy">(</span><span class="i">p</span><span class="o">+</span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="s">'*'</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">assert</span><span class="sy">(</span><span class="o">*</span><span class="i">p</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="s">'*'</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="o">*</span><span class="v">p</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="o">*</span><span class="i">s</span><span class="sy">)</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="v">p</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="s">'.'</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="o">*</span><span class="i">s</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="s">'\0'</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="e">isMatch</span><span class="sy">(</span><span class="i">s</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="o">+</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="c">// next char is '*'</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="o">*</span><span class="v">p</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="o">*</span><span class="i">s</span><span class="sy">)</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="sy">(</span><span class="o">*</span><span class="v">p</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="s">'.'</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="o">*</span><span class="i">s</span><span class="h"> </span><span class="o">!=</span><span class="h"> </span><span class="s">'\0'</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="e">isMatch</span><span class="sy">(</span><span class="i">s</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="o">+</span><span class="cn">2</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">s</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="e">isMatch</span><span class="sy">(</span><span class="i">s</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="o">+</span><span class="cn">2</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**<span>Further Thoughts:</span>**  
 Some extra exercises to this problem:

1.  If you think carefully, you can exploit some cases that the above
    code runs in exponential complexity. Could you think of some
    examples? How would you make the above code more efficient?
2.  Try to implement partial matching instead of full matching. In
    addition, add ‘^’ and ‘$’ to the rule. ‘^’ matches the starting
    position within the string, while ‘$’ matches the ending position of
    the string.
3.  Try to implement wildcard matching where ‘\*’ means any sequence of
    zero or more characters.

For the interested reader, real world regular expression matching (such
as the grep tool) are usually implemented by applying formal language
theory. To understand more about it, you may read [this
article](http://swtch.com/~rsc/regexp/regexp1.html).

VN:F [1.9.22\_1171]

Rating: 4.8/**5** (67 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Regular Expression Matching</span></span>, <span
class="rating"><span class="average">4.8</span> out of <span
class="best">5</span> based on <span class="votes">67</span> ratings
<span class="summary"></span></span></span>

> Given a function which generates a random integer in the range 1 to 7,
> write a function which generates a random integer in the range 1 to 10
> uniformly.

<span id="more-54"></span>  

This appear to be one of those probabilistic analysis questions. You
should be familiar with the concept of [expected
value](http://en.wikipedia.org/wiki/Expected_value), as it could be
extremely helpful in probabilistic analysis.

**Hint:**  
Assume you could generate a random integer in the range **1** to **49**.
How would you generate a random integer in the range of **1** to **10**?
What would you do if the generated number is in the desired range? What
if it’s not?

**Solution:**  
This solution is based upon [Rejection
Sampling](http://en.wikipedia.org/wiki/Rejection_sampling). The main
idea is when you generate a number in the desired range, output that
number immediately. If the number is out of the desired range, reject it
and re-sample again. As each number in the desired range has the same
probability of being chosen, a uniform distribution is produced.

Obviously, we have to run *rand7()* function at least twice, as there
are not enough numbers in the range of **1** to **10**. By running
*rand7()* twice, we can get integers from **1** to **49** uniformly.
Why?  

       1  2  3  4  5  6  7
    1  1  2  3  4  5  6  7
    2  8  9 10  1  2  3  4
    3  5  6  7  8  9 10  1
    4  2  3  4  5  6  7  8
    5  9 10  1  2  3  4  5
    6  6  7  8  9 10  *  *
    7  *  *  *  *  *  *  *

<span>A table is used to illustrate the concept of rejection sampling.
Calling *rand7()* twice will get us row and column index that
corresponds to a unique position in the table above.
</span><span>Imagine that you are choosing a number randomly from the
table above. If you hit a number, you return that number immediately. If
you hit a \*, you repeat the process again until you hit a
number.</span>

Since **49** is not a multiple of tens, we have to use rejection
sampling. Our desired range is integers from **1** to **40**, which we
can return the answer immediately. If not (the integer falls between
**41** to **49**), we reject it and repeat the whole process again.

int rand10() { int row, col, idx; do { row = rand7(); col = rand7(); idx
= col + (row-1)\*7; } while (idx \> 40); return 1 + (idx-1)%10; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">rand10</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="i">row</span><span class="sy">,</span><span class="h"> </span><span class="i">col</span><span class="sy">,</span><span class="h"> </span><span class="i">idx</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">do</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">row</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">rand7</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">col</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">rand7</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">idx</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">col</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="i">row</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="o">*</span><span class="cn">7</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h"> </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">idx</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="cn">40</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="cn">1</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="i">idx</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="o">%</span><span class="cn">10</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

Now let’s get our hands dirty to calculate the [expected
value](http://en.wikipedia.org/wiki/Expected_value) for the number of
calls to *rand7()* function.

    E(# calls to rand7) = 2 * (40/49) + 
                          4 * (9/49) * (40/49) + 
                          6 * (9/49)2 * (40/49) + 
                          ...

                          ∞
                        = ∑ 2k * (9/49)k-1 * (40/49)
                          k=1

                        = (80/49) / (1 - 9/49)2
                        = 2.45

**Optimization:**  
There are a total of **2.45** calls to *rand7()* on average using the
above method. Can we do better? Glad that you asked. In fact, we are
able to improved the above method by **10%** faster.

It seems wasteful to throw away the integers in the range **41** to
**49**. In fact, we could reuse them in the hope of minimizing the
number of calls to *rand7()*. In the event that we could not generate a
number in the desired range (**1** to **40**), it is equally likely that
each number of **41** to **49** would be chosen. In other words, we are
able to obtain integers in the range of **1** to **9** uniformly. Now,
run *rand7()* again and we obtain integers in the range of **1** to
**63** uniformly. Apply rejection sampling where the desired range is
**1** to **60**. If the generated number is in the desired range (**1**
to **60**), we return the number. If it is not (**61** to **63**), we at
least obtain integers of **1** to **3** uniformly. Run *rand7()* again
and we obtain integers in the range of **1** to **21** uniformly. The
desired range is **1** to **20**, and in the unlikely event we get a
**21**, we reject it and repeat the entire process again.

Below is the code for this optimized method. Note that there are code
sections that are repeated, but I leave it as it is for code clarity.
(Take it as a challenge to refactor the code below!)

int rand10Imp() { int a, b, idx; while (true) { a = rand7(); b =
rand7(); idx = b + (a-1)\*7; if (idx \<= 40) return 1 + (idx-1)%10; a =
idx-40; b = rand7(); // get uniform dist from 1 - 63 idx = b + (a-1)\*7;
if (idx \<= 60) return 1 + (idx-1)%10; a = idx-60; b = rand7(); // get
uniform dist from 1-21 idx = b + (a-1)\*7; if (idx \<= 20) return 1 +
(idx-1)%10; } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">rand10Imp</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="i">a</span><span class="sy">,</span><span class="h"> </span><span class="i">b</span><span class="sy">,</span><span class="h"> </span><span class="i">idx</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="t">true</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">a</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">rand7</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">b</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">rand7</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">idx</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">b</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="i">a</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="o">*</span><span class="cn">7</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">idx</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="cn">40</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="cn">1</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="i">idx</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="o">%</span><span class="cn">10</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">a</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">idx</span><span class="o">-</span><span class="cn">40</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">b</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">rand7</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="c">// get uniform dist from 1 - 63</span></p>
<p><span class="h">    </span><span class="v">idx</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">b</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="i">a</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="o">*</span><span class="cn">7</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">idx</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="cn">60</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="cn">1</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="i">idx</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="o">%</span><span class="cn">10</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">a</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">idx</span><span class="o">-</span><span class="cn">60</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">b</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">rand7</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="c">// get uniform dist from 1-21</span></p>
<p><span class="h">    </span><span class="v">idx</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">b</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="i">a</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="o">*</span><span class="cn">7</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">idx</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="cn">20</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="cn">1</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="i">idx</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="o">%</span><span class="cn">10</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

The expected value for the number of calls to *rand7()* function using
this optimization is:

    E(# calls to rand7) = 2 * (40/49) + 
                          3 * (9/49) * (60/63) + 
                          4 * (9/49) * (3/63) * (20/21) + 

                          (9/49) * (3/63) * (1/21) * 
                          [ 6 * (40/49) + 
                            7 * (9/49) * (60/63) +
                            8 * (9/49) * (3/63) * (20/21) ] +

                          ((9/49) * (3/63) * (1/21))2 * 
                          [ 10 * (40/49) + 
                            11 * (9/49) * (60/63) +
                            12 * (9/49) * (3/63) * (20/21) ] +
                          ...

                        = 2.2123

I omitted some steps above because it involves some tedious math.
Anyway, using this optimization, we are able to achieve **2.2123** calls
to *rand7()* on average, which is **10%** less calls than the
unoptimized method.

VN:F [1.9.22\_1171]

Rating: 4.8/**5** (21 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Rejection Sampling</span></span>, <span class="rating"><span
class="average">4.8</span> out of <span class="best">5</span> based on
<span class="votes">21</span> ratings <span
class="summary"></span></span></span>

> Reverse bits of an unsigned integer.

<span id="more-813"></span>  
 There are several methods of reversing the bits of an unsigned integer.
Here, we devise an algorithm using the XOR swap trick, and then optimize
it using a divide and conquer methodology.

**Hint:**  
 How do you swap the i<sup>th</sup> bit with the j<sup>th</sup> bit? Try
to figure out if you could use the XOR operation to do it.

**The XOR swap trick:**  
 Reversing bits could be done by swapping the n/2 least significant bits
with its most significant bits. The trick is to implement a function
called swapBits(i, j), which swaps the i<sup>th</sup> bit with the
j<sup>th</sup> bit. If you still remember how XOR operation works: 0 ^ 0
== 0, 1 ^ 1 == 0, 0 ^ 1 == 1, and 1 ^ 0 == 1.

We only need to perform the swap when the i<sup>th</sup> bit and the
j<sup>th</sup> bit are different. To test if two bits are different, we
could use the XOR operation. Then, we need to toggle both i<sup>th</sup>
and j<sup>th</sup> bits. We could apply the XOR operation again. By
XOR-ing the i<sup>th</sup> and j<sup>th</sup> bit with 1, both bits are
toggled.

typedef unsigned int uint; uint swapBits(uint x, uint i, uint j) { uint
lo = ((x \>\> i) & 1); uint hi = ((x \>\> j) & 1); if (lo ^ hi) { x ^=
((1U \<\< i) | (1U \<\< j)); } return x; } uint reverseXor(uint x) {
uint n = sizeof(x) \* 8; for (uint i = 0; i \< n/2; i++) { x =
swapBits(x, i, n-i-1); } return x; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="r">typedef</span><span class="h"> </span><span class="t">unsigned</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">uint</span><span class="sy">;</span></p>
<p><span class="e">uint </span><span class="e">swapBits</span><span class="sy">(</span><span class="i">uint</span><span class="h"> </span><span class="i">x</span><span class="sy">,</span><span class="h"> </span><span class="i">uint</span><span class="h"> </span><span class="i">i</span><span class="sy">,</span><span class="h"> </span><span class="i">uint</span><span class="h"> </span><span class="i">j</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="e">uint </span><span class="v">lo</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">i</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">uint </span><span class="v">hi</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">j</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">lo</span><span class="h"> </span><span class="o">^</span><span class="h"> </span><span class="i">hi</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">x</span><span class="h"> </span><span class="o">^=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="cn">1U</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">i</span><span class="sy">)</span><span class="h"> </span><span class="o">|</span><span class="h"> </span><span class="sy">(</span><span class="cn">1U</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">j</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">x</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="e">uint </span><span class="e">reverseXor</span><span class="sy">(</span><span class="i">uint</span><span class="h"> </span><span class="i">x</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="i">uint</span><span class="h"> </span><span class="v">n</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">sizeof</span><span class="sy">(</span><span class="i">x</span><span class="sy">)</span><span class="h"> </span><span class="o">*</span><span class="h"> </span><span class="cn">8</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="i">uint</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="o">/</span><span class="cn">2</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">x</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">swapBits</span><span class="sy">(</span><span class="i">x</span><span class="sy">,</span><span class="h"> </span><span class="i">i</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">x</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

The run time complexity using the XOR trick to reverse bits is O(*n*),
where *n* is the total number of bits in an unsigned integer.

**The divide and conquer approach:  
** Remember how merge sort works? Let us use an example of *n* == 8 (one
byte) to see how this works:

          01101001
        /         \
       0110      1001
      /   \     /   \
     01   10   10   01
     /\   /\   /\   /\
    0 1  1 0  1 0  0 1

The first step is to swap all odd and even bits. After that swap
consecutive pairs of bits, and so on…

Therefore, only a total of log(n) operations are necessary.

The below code shows a specific case where *n* == 32, but it could be
easily adapted to larger *n*‘s as well.

uint reverseMask(uint x) { assert(sizeof(x) == 4); // special case: only
works for 4 bytes (32 bits). x = ((x & 0x55555555) \<\< 1) | ((x &
0xAAAAAAAA) \>\> 1); x = ((x & 0x33333333) \<\< 2) | ((x &
0xCCCCCCCC) \>\> 2); x = ((x & 0x0F0F0F0F) \<\< 4) | ((x &
0xF0F0F0F0) \>\> 4); x = ((x & 0x00FF00FF) \<\< 8) | ((x &
0xFF00FF00) \>\> 8); x = ((x & 0x0000FFFF) \<\< 16) | ((x &
0xFFFF0000) \>\> 16); return x; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="e">uint </span><span class="e">reverseMask</span><span class="sy">(</span><span class="i">uint</span><span class="h"> </span><span class="i">x</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">assert</span><span class="sy">(</span><span class="e">sizeof</span><span class="sy">(</span><span class="i">x</span><span class="sy">)</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">4</span><span class="sy">)</span><span class="sy">;</span><span class="h"> </span><span class="c">// special case: only works for 4 bytes (32 bits).</span></p>
<p><span class="h">  </span><span class="v">x</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="cn">0x55555555</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span><span class="h"> </span><span class="o">|</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="cn">0xAAAAAAAA</span><span class="sy">)</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">x</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="cn">0x33333333</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="cn">2</span><span class="sy">)</span><span class="h"> </span><span class="o">|</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="cn">0xCCCCCCCC</span><span class="sy">)</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="cn">2</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">x</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="cn">0x0F0F0F0F</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="cn">4</span><span class="sy">)</span><span class="h"> </span><span class="o">|</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="cn">0xF0F0F0F0</span><span class="sy">)</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="cn">4</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">x</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="cn">0x00FF00FF</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="cn">8</span><span class="sy">)</span><span class="h"> </span><span class="o">|</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="cn">0xFF00FF00</span><span class="sy">)</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="cn">8</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">x</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="cn">0x0000FFFF</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="cn">16</span><span class="sy">)</span><span class="h"> </span><span class="o">|</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">x</span><span class="h"> </span><span class="o">&amp;</span><span class="h"> </span><span class="cn">0xFFFF0000</span><span class="sy">)</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="cn">16</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">x</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Note:**  
 These are not the only methods for reversing bits, and not necessarily
the fastest way. For more ideas/algorithms to reverse bits, please visit
[Bit Twiddling
Hacks](http://graphics.stanford.edu/~seander/bithacks.html#BitReverseObvious).

VN:F [1.9.22\_1171]

Rating: 4.6/**5** (38 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Reverse Bits</span></span>, <span class="rating"><span
class="average">4.6</span> out of <span class="best">5</span> based on
<span class="votes">38</span> ratings <span
class="summary"></span></span></span>

Reversing linked list iteratively and recursively
=================================================

April 12, 2010 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> Implement the reversal of a singly linked list iteratively and
> recursively.

<span id="more-10"></span>  
 Reversing linked list can be done both iteratively and recursively. In
my opinion, the iterative solution should be more efficient and less
memory overhead than its recursive counterpart (Imagine reversing a link
list that has one million elements recursively! It would quickly run out
of stack space).

The recursive solution can be coded in fewer lines of code, but is
harder to code correctly. On the other hand, the iterative solution
requires more code but is easier to verify.

1) The iterative way:

void reverse(Node\*& head) { if (!head) return; Node\* prev = NULL;
Node\* curr = head; while (curr) { Node\* next = curr-\>next;
curr-\>next = prev; prev = curr; curr = next; } head = prev; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">reverse</span><span class="sy">(</span><span class="e">Node*</span><span class="o">&amp;</span><span class="h"> </span><span class="i">head</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">head</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Node*</span><span class="h"> </span><span class="v">prev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Node*</span><span class="h"> </span><span class="v">curr</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">head</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">curr</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="e">Node*</span><span class="h"> </span><span class="v">next</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">curr</span><span class="o">-&gt;</span><span class="i">next</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">curr</span><span class="o">-&gt;</span><span class="v">next</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">prev</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">prev</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">curr</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">curr</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">next</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="v">head</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">prev</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

Please do note that the head pointer is passed in by reference. If you
have trouble understanding the syntax, think the pointer as a type, and
an & sign followed by a type signifies the variable is passed by
reference. The head pointer must be passed in by reference whenever
there might be a change to the head pointer itself!

2) The recursive way:

void reverse(Node\*& p) { if (!p) return; Node\* rest = p-\>next; if
(!rest) return; reverse(rest); p-\>next-\>next = p; p-\>next = NULL; p =
rest; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">reverse</span><span class="sy">(</span><span class="e">Node*</span><span class="o">&amp;</span><span class="h"> </span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Node*</span><span class="h"> </span><span class="v">rest</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">next</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">rest</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">reverse</span><span class="sy">(</span><span class="i">rest</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">next</span><span class="o">-&gt;</span><span class="v">next</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">p</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">p</span><span class="o">-&gt;</span><span class="v">next</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">p</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">rest</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

Can you see why the head pointer is eventually updated to point to the
last element of the list? Try to draw a diagram and see how the rest
pointer changes when the recursion exits. (Hint: the rest pointer points
to the last element and does not change).

VN:F [1.9.22\_1171]

Rating: 4.5/**5** (63 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Reversing linked list iteratively and
recursively</span></span>, <span class="rating"><span
class="average">4.5</span> out of <span class="best">5</span> based on
<span class="votes">63</span> ratings <span
class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/04/reversing-linked-list-iteratively-and.html>

### Leave a reply

### 4 trackbacks

-   *on June 21, 2014*
-   *on June 21, 2014*
-   *on June 21, 2014*
-   *on October 8, 2014*

Rotating an array in place
==========================

April 13, 2010 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> Rotate a one-dimensional array of n elements to the right by k
> steps.  
> For instance, with n=7 and k=3, the array {a, b, c, d, e, f, g} is
> rotated to {e, f, g, a, b, c, d}.

<span id="more-14"></span>

In my previous post we discussed about finding an element in a rotated
array. You might ask, how do we rotate an array?

The straight forward way is to allocate a temporary array of size n, and
then copy elements starting from index k to the new array, and copy it
back to the old array. This is highly inefficient because:

1.  It needs extra space to store a temporary array (O(n) space).
2.  It involves back-and-forth copying, a total of 2\*n copy operations.

So, the question is, can we do this more efficiently, preferably an
in-place rotation method.

The answer is of course, yes. This is a trick so important that it
becomes one of the frequently asked interview questions. An in-depth
discussion is in [Programming
Pearls](http://www.cs.bell-labs.com/cm/cs/pearls/), one of the must-read
book in Computer Science.

The trick is to do three reverse operation. One for the entire string,
one from index 0 to k-1, and lastly index k to n-1. Magically, this will
yield the correct rotated array, without any extra space! (Of course,
you need a temporary variable for swapping).

void reverse\_string(char\* str, int left, int right) { char\* p1 =
str + left; char\* p2 = str + right; while (p1 \< p2) { char temp
= \*p1; \*p1 = \*p2; \*p2 = temp; p1++; p2--; } } void rotate(char\*
str, int k) { int n = strlen(str); reverse\_string(str, 0, n-1);
reverse\_string(str, 0, k-1); reverse\_string(str, k, n-1); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">reverse_string</span><span class="sy">(</span><span class="t">char</span><span class="o">*</span><span class="h"> </span><span class="i">str</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">right</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">char</span><span class="o">*</span><span class="h"> </span><span class="v">p1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">str</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="i">left</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">char</span><span class="o">*</span><span class="h"> </span><span class="v">p2</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">str</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="i">right</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">p1</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">p2</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">char</span><span class="h"> </span><span class="v">temp</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="o">*</span><span class="i">p1</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="o">*</span><span class="v">p1</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="o">*</span><span class="i">p2</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="o">*</span><span class="v">p2</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">temp</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">p1</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">p2</span><span class="o">--</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">void</span><span class="h"> </span><span class="e">rotate</span><span class="sy">(</span><span class="t">char</span><span class="o">*</span><span class="h"> </span><span class="i">str</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">k</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">n</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">strlen</span><span class="sy">(</span><span class="i">str</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">reverse_string</span><span class="sy">(</span><span class="i">str</span><span class="sy">,</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">reverse_string</span><span class="sy">(</span><span class="i">str</span><span class="sy">,</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="i">k</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">reverse_string</span><span class="sy">(</span><span class="i">str</span><span class="sy">,</span><span class="h"> </span><span class="i">k</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.4/**5** (20 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Rotating an array in place</span></span>, <span
class="rating"><span class="average">4.4</span> out of <span
class="best">5</span> based on <span class="votes">20</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/04/rotating-array-in-place.html>

> Describe an algorithm to save a Binary Search Tree (BST) to a file in
> terms of run-time and disk space complexity. You must be able to
> restore to the exact original BST using the saved format.

<span id="more-42"></span>  

**Hint:**  
Remember the **big three** tree traversal algorithm? Yes, it’s
**pre-order**, **in-order**, and **post-order** traversal. Only one of
them is useful for storing a BST.

Assume we have the following BST:

        _30_ 
       /    \    
      20    40
     /     /  \
    10    35  50

**In-order traversal**  
If we do an in-order traversal, we will output <span>10</span>
<span>20</span><span> 30</span> <span>35</span> <span>40</span>
<span>50</span>. There is no way of telling how the original BST
structure looks like, as the following unbalanced BST is one of the
possible BST sets from the output <span>10</span> <span>20</span><span>
30</span> <span>35</span> <span>40</span> <span>50</span>.

              _50 
             /       
            40 
           /    
          35
         /
        30
       /
      20
     /
    10

**Post-order traversal:**  
If we do a post-order traversal, we will output the leaf nodes before
its parent node. Specifically, we will output <span>10</span>
<span>20</span><span> </span><span>35</span> <span>50</span>
<span>40</span> <span>30</span> using post-order traversal. Imagine
we’re reading the nodes to construct the tree back. See the problem that
we are reading the leaf nodes before its parent? There’s too much
trouble to create the child nodes before its parent. Remember that the
BST insertion algorithm works by traversing the tree from the root to
the correct leaf to insert.

**Pre-order traversal:**  
Pre-order traversal is the *perfect* algorithm for making a copy of a
BST. The output of a pre-order traversal of the BST above is
<span>30</span> <span>20</span><span> 10</span> <span>40</span>
<span>35</span> <span>50</span>. Please note the following important
observation:

A node’s parent is always output before itself.

Therefore, when we read the BST back from the file, we are always able
to create the parent node before creating its child nodes. The code for
writing a BST to a file is exactly the same as pre-order traversal.

![](http://3.bp.blogspot.com/_UElib2WLeDE/TKG-JD1BdzI/AAAAAAAACVs/0TVEf9SRcYU/s1600/phonebook.jpg)

A Binary Search Tree (BST) is useful for storing phone book records in a
memory limited device, such as a cell phone. The records are always
maintained in sorted order, inserting and deleting a record takes *O*(lg
*n*) time (slower than linked list, but much better than array).

**Reading a BST from a file:**  
The question now is, how would you reconstruct a BST back from the file?
Assume that we have the following pre-order traversal output of the BST
earlier: <span>30</span> <span>20</span><span> 10</span> <span>40</span>
<span>35</span> <span>50</span>.

**Hint:**  
When we encounter a new node to insert, we should always place it into
the first empty space which it will fit using a pre-order traversal. How
do we determine the first empty space which a node will fit in? We can
use the ordinary BST insertion algorithm, but the run-time complexity
will be *O*(*n* lg *n*), since inserting a node takes *O*(lg *n*) time.
Not efficient enough!

**Solution:**  
Remember my post: [Determine if a Binary Tree is a Binary Search Tree
(BST)?](http://www.leetcode.com/2010/09/determine-if-binary-tree-is-binary.html)

We use the same idea here. We pass the valid range of the values from
the parent node to its child nodes. When we are about to insert a node,
we will check if the insert value is in the valid range. If it is, this
is the right space to insert. If it is not, we will try the next empty
space. Reconstructing the whole BST from a file will take only *O*(*n*)
time.

void readBSTHelper(int min, int max, int &insertVal, BinaryTree \*&p,
ifstream &fin) { if (insertVal \> min && insertVal \< max) { int val =
insertVal; p = new BinaryTree(val); if (fin \>\> insertVal) {
readBSTHelper(min, val, insertVal, p-\>left, fin); readBSTHelper(val,
max, insertVal, p-\>right, fin); } } } void readBST(BinaryTree \*&root,
ifstream &fin) { int val; fin \>\> val; readBSTHelper(INT\_MIN,
INT\_MAX, val, root, fin); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">readBSTHelper</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">min</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">max</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">insertVal</span><span class="sy">,</span></p>
<p><span class="h">                   </span><span class="e">BinaryTree *</span><span class="o">&amp;</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="i">ifstream</span><span class="h"> </span><span class="o">&amp;</span><span class="i">fin</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">insertVal</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">min</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">insertVal</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">max</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">val</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">insertVal</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">p</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="r">new</span><span class="h"> </span><span class="e">BinaryTree</span><span class="sy">(</span><span class="i">val</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">fin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">insertVal</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="e">readBSTHelper</span><span class="sy">(</span><span class="i">min</span><span class="sy">,</span><span class="h"> </span><span class="i">val</span><span class="sy">,</span><span class="h"> </span><span class="i">insertVal</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">fin</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="e">readBSTHelper</span><span class="sy">(</span><span class="i">val</span><span class="sy">,</span><span class="h"> </span><span class="i">max</span><span class="sy">,</span><span class="h"> </span><span class="i">insertVal</span><span class="sy">,</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">fin</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">void</span><span class="h"> </span><span class="e">readBST</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="o">&amp;</span><span class="i">root</span><span class="sy">,</span><span class="h"> </span><span class="i">ifstream</span><span class="h"> </span><span class="o">&amp;</span><span class="i">fin</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="i">val</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">fin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">val</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">readBSTHelper</span><span class="sy">(</span><span class="i">INT_MIN</span><span class="sy">,</span><span class="h"> </span><span class="i">INT_MAX</span><span class="sy">,</span><span class="h"> </span><span class="i">val</span><span class="sy">,</span><span class="h"> </span><span class="i">root</span><span class="sy">,</span><span class="h"> </span><span class="i">fin</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Further thoughts:**  
How about storing a binary tree (not BST) to a file? Does the algorithm
above works? Why and why not?

VN:F [1.9.22\_1171]

Rating: 4.9/**5** (41 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Saving a Binary Search Tree to a File</span></span>, <span
class="rating"><span class="average">4.9</span> out of <span
class="best">5</span> based on <span class="votes">41</span> ratings
<span class="summary"></span></span></span>

> Write an efficient algorithm that searches for a value in an *n* x *m*
> table (two-dimensional array). This table is sorted along the rows and
> columns — that is,
>
> Table[i][j] ≤ Table[i][j + 1],  
> Table[i][j] ≤ Table[i + 1][j]

<span id="more-47"></span>  

**<span>Note:</span>**  
This is Part II of the article: [Searching a 2D Sorted
Matrix](http://www.leetcode.com/2010/10/searching-2d-sorted-matrix.html).
Please read [Part
I](http://www.leetcode.com/2010/10/searching-2d-sorted-matrix.html) for
more background information.

**Step-wise Linear Search:**  
We call this the *Step-wise Linear Search* method. Similar to *Diagonal
Binary Search*, we begin with the upper right corner (or the bottom left
corner). Instead of traversing diagonally each step, we traverse one
step to the left or bottom. For example, the picture below shows the
traversed path (the red line) when we search for **13**.

Essentially, each step we are able to eliminate either a row or a
column. The worst case scenario is where it ended up in the opposite
corner of the matrix, which takes at most 2*n* steps. Therefore, this
algorithm runs in O(*n*) time, which is better than previous approaches.

[![](http://4.bp.blogspot.com/_UElib2WLeDE/TK6IxlaUjRI/AAAAAAAACWk/xQkntM5OeC8/s1600/matrix_hi5.png)](http://4.bp.blogspot.com/_UElib2WLeDE/TK6IxlaUjRI/AAAAAAAACWk/xQkntM5OeC8/s1600/matrix_hi5.png)

An example showing the traversed path using step-wise linear search
(colored in red) when the target element is **13**.

Below is the code and it is simple and straight to the point. You should
not make any careless mistake during the interview.

bool stepWise(int mat[][N\_MAX], int N, int target, int &row, int &col)
{ if (target \< mat[0][0] || target \> mat[N-1][N-1]) return false; row
= 0; col = N-1; while (row \<= N-1 && col \>= 0) { if (mat[row][col] \<
target) row++; else if (mat[row][col] \> target) col--; else return
true; } return false; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">bool</span><span class="h"> </span><span class="e">stepWise</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="sy">]</span><span class="sy">[</span><span class="i">N_MAX</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span></p>
<p><span class="h">              </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">row</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">col</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">target</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">target</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">N</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">N</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">row</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">col</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">N</span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">row</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">N</span><span class="o">-</span><span class="cn">1</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">col</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">0</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">mat</span><span class="sy">[</span><span class="i">row</span><span class="sy">]</span><span class="sy">[</span><span class="i">col</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">target</span><span class="sy">)</span><span class="h"> </span></p>
<p><span class="h">      </span><span class="i">row</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">mat</span><span class="sy">[</span><span class="i">row</span><span class="sy">]</span><span class="sy">[</span><span class="i">col</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">target</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="i">col</span><span class="o">--</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">else</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

This is probably the answer that most interviewers would be looking for.
But we will not stop here. Let us continue exploring some more
interesting solutions.

**<span><span>Quad Partition:</span></span>**  
<span><span>Did you realize that this problem is actually solvable using
a [divide and
conquer](http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm)
approach? I bet you did!</span></span>

<span><span> </span></span><span><span>First, we make an observation
that the center element always partition the matrix into four smaller
matrices. </span></span>For example, the center element **9** partitions
the matrix into four matrices as shown in the picture below.
<span><span>Since the four smaller matrices are also sorted both row and
column-wise, the problem can naturally be divided into four
sub-problems.</span></span>

If you notice carefully, we are always able to eliminate one of the four
sub-problems in each step. Assume our target is **21**, which is greater
than the center element **9**. We can eliminate the upper left quadrant
instantly, because all elements in that quadrant are always less than or
equal to **9**. Now assume our target is **6**, which is less than
**9**.

Similarly, we eliminate the bottom right quadrant from consideration,
because elements in that quadrant must all be greater than **9**. Please
note however, we still need to search the upper right and bottom left
quadrant, even though the example below seems to show all elements in
the two mentioned quadrants are greater than **9**.

Of course, if the center element is our target element, we have found
the target and stop searching. If not, we proceed by searching the rest
of three quadrants.

[![](http://1.bp.blogspot.com/_UElib2WLeDE/TK6PT3SwHJI/AAAAAAAACWo/aatX4kZ8HPE/s1600/matrix_hi6.png)](http://1.bp.blogspot.com/_UElib2WLeDE/TK6PT3SwHJI/AAAAAAAACWo/aatX4kZ8HPE/s1600/matrix_hi6.png)

The center element **9** partitions the matrix into four smaller
quadrants (shown as four different colors).

<span>What’s the complexity of the *Quad Partition*
method?</span>**<span><span> </span></span>**<span><span>As it turns
out, the run time complexity could be written directly as a recurrence
relation:</span></span>

     T(n) = 3T(n/2) + c,

     where n is the dimension of the matrix.

<span>We add a constant *c* because each step we do a comparison between
the target element and the center element, which takes some constant
time.</span>

<span><span>We need to solve the above equation to obtain the
complexity. This is where most confusion comes in. If you have taken
advanced algorithm course, you could solve it using the [Master’s
theorem](http://en.wikipedia.org/wiki/Master_theorem), but you *don’t
really need to*. You could just expand the recurrence relation directly
to solve it.</span></span>

     T(n) = 3T(n/2) + c, 
          = 3 [ 3T(n/4) + c ] + c 
          = 3 [ 3 [ 3T(n/8)  + c ] + c ] + c 
          = 3k T(n/2k) + c (3k - 1)/2   
          = 3k ( T(n/2k) + c ) - c/2


     Setting k = lg n,  
     T(n)  = 3lg n ( T(1) + c ) - c/2 
           = O(3lg n) 
           = O(nlg 3)           lg n = nlg 3 
           = O(n1.58)  

Below is the code for the *Quad Partition* method. *l* and ** *u*
represents the upper left corner, while *r* and *d* represents the
bottom right corner of the matrix. Be very careful of corner cases.
Please note that the code below checks for when *l* equals *r* (left =
right) and *u* equals *d* (up = down) (ie, the matrix has only one
element). If this only element differs from the target, the function
must return false. If you omit this condition, then the code below never
terminates, which in other word translates to: *You never double check
your code*, and it is [Hasta la vista,
baby](http://en.wikipedia.org/wiki/Hasta_la_vista,_baby) from your
interviewer.

bool quadPart(int mat[][N\_MAX], int M, int N, int target, int l, int u,
int r, int d, int &targetRow, int &targetCol) { if (l \> r || u \> d)
return false; if (target \< mat[u][l] || target \> mat[d][r]) return
false; int col = l + (r-l)/2; int row = u + (d-u)/2; if (mat[row][col]
== target) { targetRow = row; targetCol = col; return true; } else if (l
== r && u == d) { return false; } if (mat[row][col] \> target) { return
quadPart(mat, M, N, target, col+1, u, r, row, targetRow, targetCol) ||
quadPart(mat, M, N, target, l, row+1, col, d, targetRow, targetCol) ||
quadPart(mat, M, N, target, l, u, col, row, targetRow, targetCol); }
else { return quadPart(mat, M, N, target, col+1, u, r, row, targetRow,
targetCol) || quadPart(mat, M, N, target, l, row+1, col, d, targetRow,
targetCol) || quadPart(mat, M, N, target, col+1, row+1, r, d, targetRow,
targetCol); } } bool quadPart(int mat[][N\_MAX], int N, int target, int
&row, int &col) { return quadPart(mat, N, N, target, 0, 0, N-1, N-1,
row, col); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">bool</span><span class="h"> </span><span class="e">quadPart</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="sy">]</span><span class="sy">[</span><span class="i">N_MAX</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">M</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">l</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">u</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">r</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">d</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">targetRow</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">targetCol</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">l</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">r</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">u</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">d</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">target</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">u</span><span class="sy">]</span><span class="sy">[</span><span class="i">l</span><span class="sy">]</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">target</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">d</span><span class="sy">]</span><span class="sy">[</span><span class="i">r</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">col</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">l</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="i">r</span><span class="o">-</span><span class="i">l</span><span class="sy">)</span><span class="o">/</span><span class="cn">2</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">row</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">u</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="i">d</span><span class="o">-</span><span class="i">u</span><span class="sy">)</span><span class="o">/</span><span class="cn">2</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">mat</span><span class="sy">[</span><span class="i">row</span><span class="sy">]</span><span class="sy">[</span><span class="i">col</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">target</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">targetRow</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">row</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">targetCol</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">col</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">l</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">r</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">u</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">d</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">mat</span><span class="sy">[</span><span class="i">row</span><span class="sy">]</span><span class="sy">[</span><span class="i">col</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">target</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">quadPart</span><span class="sy">(</span><span class="i">mat</span><span class="sy">,</span><span class="h"> </span><span class="i">M</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="i">col</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">u</span><span class="sy">,</span><span class="h"> </span><span class="i">r</span><span class="sy">,</span><span class="h"> </span><span class="i">row</span><span class="sy">,</span><span class="h"> </span><span class="i">targetRow</span><span class="sy">,</span><span class="h"> </span><span class="i">targetCol</span><span class="sy">)</span><span class="h"> </span><span class="o">||</span><span class="h"> </span></p>
<p><span class="h">           </span><span class="e">quadPart</span><span class="sy">(</span><span class="i">mat</span><span class="sy">,</span><span class="h"> </span><span class="i">M</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="i">l</span><span class="sy">,</span><span class="h"> </span><span class="i">row</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">col</span><span class="sy">,</span><span class="h"> </span><span class="i">d</span><span class="sy">,</span><span class="h"> </span><span class="i">targetRow</span><span class="sy">,</span><span class="h"> </span><span class="i">targetCol</span><span class="sy">)</span><span class="h"> </span><span class="o">||</span></p>
<p><span class="h">           </span><span class="e">quadPart</span><span class="sy">(</span><span class="i">mat</span><span class="sy">,</span><span class="h"> </span><span class="i">M</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="i">l</span><span class="sy">,</span><span class="h"> </span><span class="i">u</span><span class="sy">,</span><span class="h"> </span><span class="i">col</span><span class="sy">,</span><span class="h"> </span><span class="i">row</span><span class="sy">,</span><span class="h"> </span><span class="i">targetRow</span><span class="sy">,</span><span class="h"> </span><span class="i">targetCol</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">quadPart</span><span class="sy">(</span><span class="i">mat</span><span class="sy">,</span><span class="h"> </span><span class="i">M</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="i">col</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">u</span><span class="sy">,</span><span class="h"> </span><span class="i">r</span><span class="sy">,</span><span class="h"> </span><span class="i">row</span><span class="sy">,</span><span class="h"> </span><span class="i">targetRow</span><span class="sy">,</span><span class="h"> </span><span class="i">targetCol</span><span class="sy">)</span><span class="h"> </span><span class="o">||</span><span class="h"> </span></p>
<p><span class="h">           </span><span class="e">quadPart</span><span class="sy">(</span><span class="i">mat</span><span class="sy">,</span><span class="h"> </span><span class="i">M</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="i">l</span><span class="sy">,</span><span class="h"> </span><span class="i">row</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">col</span><span class="sy">,</span><span class="h"> </span><span class="i">d</span><span class="sy">,</span><span class="h"> </span><span class="i">targetRow</span><span class="sy">,</span><span class="h"> </span><span class="i">targetCol</span><span class="sy">)</span><span class="h"> </span><span class="o">||</span></p>
<p><span class="h">           </span><span class="e">quadPart</span><span class="sy">(</span><span class="i">mat</span><span class="sy">,</span><span class="h"> </span><span class="i">M</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="i">col</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">row</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">r</span><span class="sy">,</span><span class="h"> </span><span class="i">d</span><span class="sy">,</span><span class="h"> </span><span class="i">targetRow</span><span class="sy">,</span><span class="h"> </span><span class="i">targetCol</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">bool</span><span class="h"> </span><span class="e">quadPart</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="sy">]</span><span class="sy">[</span><span class="i">N_MAX</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">row</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">col</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="e">quadPart</span><span class="sy">(</span><span class="i">mat</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="o">-</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="o">-</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">row</span><span class="sy">,</span><span class="h"> </span><span class="i">col</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**<span><span>Binary</span></span><span><span>
Partition:</span></span>**  
We can even reduce the number of sub-problems from three to only two
using a method we called *Binary Partition*. This time we traverse along
either the middle row, middle column, or diagonally (as shown in
highlighted gray cells in images *a*), *b*), and *c*) below). As we
traverse, we find the point such that the target element *s* satisfies
the following condition:

     ai s ai+1 ,  

     where ai is the ith traversed cell.

[![](http://3.bp.blogspot.com/_UElib2WLeDE/TK6nPzke1xI/AAAAAAAACW4/ZDCFvqyvq3M/s1600/matrix_hi9.png)](http://3.bp.blogspot.com/_UElib2WLeDE/TK6nPzke1xI/AAAAAAAACW4/ZDCFvqyvq3M/s1600/matrix_hi9.png)

*a*) Row-wise binary partition. The highlighted gray cells represents
the traversed row (the middle row). The target **10** is found between
**9** and **16**.  
  

[![](http://4.bp.blogspot.com/_UElib2WLeDE/TK6lmlteMMI/AAAAAAAACW0/_Muq6wSeSXg/s1600/matrix_hi7.png)](http://4.bp.blogspot.com/_UElib2WLeDE/TK6lmlteMMI/AAAAAAAACW0/_Muq6wSeSXg/s1600/matrix_hi7.png)

*b*) Column-wise binary partition. The highlighted gray cells represents
the traversed column (the middle column). The target **10** is found
between **9** and **14**.

[![](http://2.bp.blogspot.com/_UElib2WLeDE/TK6lVHFdKsI/AAAAAAAACWw/953Uuf_DC8c/s1600/matrix_hi8.png)](http://2.bp.blogspot.com/_UElib2WLeDE/TK6lVHFdKsI/AAAAAAAACWw/953Uuf_DC8c/s1600/matrix_hi8.png)

*c*) Diagonal-based binary partition. The highlighted gray cells
represents the traversed diagonal. The target **10** is found between
**9** and **17**. Please note that diagonal-based binary partition would
fail in a non-square matrix (for the above example, it will not work in
the two sub-matrices because they are non-square matrices).

If the target element equals one of the traversed cells, we immediately
return the element as found. Otherwise we partition the matrix into two
sub-matrices following the partition point we found. As it turns out, we
need *cn* time (linear time) to find such partition point, since we are
essentially performing a linear search. Therefore, the complexity could
be written as the following recurrence relation: (Note: I omitted the
proof, as it is left as an exercise to the reader.
![](http://4.bp.blogspot.com/_UElib2WLeDE/TK7aJSBFXSI/AAAAAAAACW8/5f8CRD5dJ8o/s1600/smiley.jpg)
)

     T(n) = 2T(n/2) + cn
          = O(n lg n)             

The *Binary Partition* algorithm runs in *O*(*n* lg *n*) time. You might
expect its complexity to be lower than *Quad Partition*, since it has
only two sub-problems (instead of three) to solve. The reason of the
higher order complexity is due to the extra *O*(*n*) time doing a linear
search for the partition point where *a<sub>i</sub>* s
a<sub>*i*+1</sub>.

Please note that the matrix is not necessarily divided into two
equal-sized sub-matrices. One of the matrix could be bigger than the
other one, or in the extreme case, the other matrix could be of size
zero. Here, we have made an assumption that each partition step divides
the matrix into two equal-sized sub-matrices, just for the sake of
complexity analysis.

Below is the code for the *Binary Partition* method. The code below
chooses the middle column as the place to search for the partition
point.

bool binPart(int mat[][N\_MAX], int M, int N, int target, int l, int u,
int r, int d, int &targetRow, int &targetCol) { if (l \> r || u \> d)
return false; if (target \< mat[u][l] || target \> mat[d][r]) return
false; int mid = l + (r-l)/2; int row = u; while (row \<= d &&
mat[row][mid] \<= target) { if (mat[row][mid] == target) { targetRow =
row; targetCol = mid; return true; } row++; } return binPart(mat, M, N,
target, mid+1, u, r, row-1, targetRow, targetCol) || binPart(mat, M, N,
target, l, row, mid-1, d, targetRow, targetCol); } bool binPart(int
mat[][N\_MAX], int N, int target, int &row, int &col) { return
binPart(mat, N, N, target, 0, 0, N-1, N-1, row, col); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">bool</span><span class="h"> </span><span class="e">binPart</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="sy">]</span><span class="sy">[</span><span class="i">N_MAX</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">M</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">l</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">u</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">r</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">d</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">targetRow</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">targetCol</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">l</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">r</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">u</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">d</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">target</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">u</span><span class="sy">]</span><span class="sy">[</span><span class="i">l</span><span class="sy">]</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">target</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">d</span><span class="sy">]</span><span class="sy">[</span><span class="i">r</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">mid</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">l</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="i">r</span><span class="o">-</span><span class="i">l</span><span class="sy">)</span><span class="o">/</span><span class="cn">2</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">row</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">u</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">row</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">d</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">row</span><span class="sy">]</span><span class="sy">[</span><span class="i">mid</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">target</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">mat</span><span class="sy">[</span><span class="i">row</span><span class="sy">]</span><span class="sy">[</span><span class="i">mid</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">target</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">targetRow</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">row</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">targetCol</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">mid</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="i">row</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="e">binPart</span><span class="sy">(</span><span class="i">mat</span><span class="sy">,</span><span class="h"> </span><span class="i">M</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="i">mid</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">u</span><span class="sy">,</span><span class="h"> </span><span class="i">r</span><span class="sy">,</span><span class="h"> </span><span class="i">row</span><span class="o">-</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">targetRow</span><span class="sy">,</span><span class="h"> </span><span class="i">targetCol</span><span class="sy">)</span><span class="h"> </span><span class="o">||</span></p>
<p><span class="h">         </span><span class="e">binPart</span><span class="sy">(</span><span class="i">mat</span><span class="sy">,</span><span class="h"> </span><span class="i">M</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="i">l</span><span class="sy">,</span><span class="h"> </span><span class="i">row</span><span class="sy">,</span><span class="h"> </span><span class="i">mid</span><span class="o">-</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">d</span><span class="sy">,</span><span class="h"> </span><span class="i">targetRow</span><span class="sy">,</span><span class="h"> </span><span class="i">targetCol</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">bool</span><span class="h"> </span><span class="e">binPart</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="sy">]</span><span class="sy">[</span><span class="i">N_MAX</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">row</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">col</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="e">binPart</span><span class="sy">(</span><span class="i">mat</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="i">target</span><span class="sy">,</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="o">-</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">N</span><span class="o">-</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">row</span><span class="sy">,</span><span class="h"> </span><span class="i">col</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Improved Binary Partition:**  
Since the partition column (or row, or diagonal) is sorted, not
utilizing the sorted configuration is a waste. In fact, we are able to
modify binary search to search for the partition point in lg *n* time.
Then, the complexity can be expressed as the following recurrence
relation: (Note: I’ve omitted some steps, try to work out the math by
yourself)

     T(n) = 2T(n/2) + c lg n
                           lg n
          = 2 lg n T(1) + c ∑ ( 2 lg (n/2k) ) 
                           k=1
          = O(n) + c (2n - lg n - 2)
          = O(n)

By incorporating binary search, we are able to reduce the complexity to
*O*(*n*). However, we have made an assumption, that is: *Each
subdivision of matrices must be of equal size* *(or, each partition
point is exactly at the center of the partition column)*. This leads to
the following question:

It is entirely possible that the subdivided matrices are of different
sizes. Would the complexity change by an order in this case?

This turns out to be a difficult question to answer, but I could provide
further insight to you by deriving the complexity of the other extreme,
that is:

Each subdivision results in only one sub-matrix (ie, one matrix has the
original matrix being halved, while the other matrix is empty.)

For an example of the above case, try searching for **–1** in the above
sample matrix shown in image (*a*). Since each subdivision results in
the original matrix being halved, the total number of subdivisions can
be at most lg *n* times. Assuming each binary search performed before a
subdivision takes *c* lg *n* time, the complexity can be expressed as
follow:

    T(n) = c lg n + ... + c lg n    (a total of lg n times)   
         = c lg n * lg n
         = O(lg n)2

As you can see, the run time complexity of this extreme case is *O*(lg
*n*)<sup>2</sup>, which turns out to be even less than *O*(*n*). We
conclude that this is not the worst case scenario, as some people might
believe.

Please note that the worst case for the *Improved Binary Partition*
method had not been proven here. We had merely proven that one case of
the *Improved Binary Partition* could run in *O*(*n*). If you know the
proof of the worst case, I would be interested to hear from you.

**<span>» Continue reading</span> [Part III: Searching a 2D Sorted
Matrix](http://www.leetcode.com/2010/10/searching-2d-sorted-matrix-part-iii.html).**

VN:F [1.9.22\_1171]

Rating: 4.9/**5** (33 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Searching a 2D Sorted Matrix Part II</span></span>, <span
class="rating"><span class="average">4.9</span> out of <span
class="best">5</span> based on <span class="votes">33</span> ratings
<span class="summary"></span></span></span>

Searching a 2D Sorted Matrix Part III
=====================================

October 13, 2010 <span>in [divide and
conquer](http://leetcode.com/category/divide-and-conquer "View all posts in divide and conquer")</span>
<span class="post-utility alignright"></span>

> Write an efficient algorithm that searches for a value in an *n* x *m*
> table (two-dimensional array). This table is sorted along the rows and
> columns — that is,
>
> Table[i][j] ≤ Table[i][j + 1],  
> Table[i][j] ≤ Table[i + 1][j]

<span id="more-48"></span>  

**<span>Note:</span>**  
This is Part III of the article: [Searching a 2D Sorted
Matrix](http://www.leetcode.com/2010/10/searching-2d-sorted-matrix.html).
Please read [Part
I](http://www.leetcode.com/2010/10/searching-2d-sorted-matrix.html) and
[Part
II](http://www.leetcode.com/2010/10/searching-2d-sorted-matrix-part-ii.html)
for more background information.

**Test Data Sets:**  
I created three test input files (Download all of them below) by myself
for testing and studying purposes. Each file contains multiple test
cases. The easy input contains 15 test cases, with **M** and **N** = 10,
**K** = 50. The hard input contains 23 test cases, but with **M** and
**N** = 100, **K** = 100,000. The performance input has **M** and **N**
= 1000, and **K** = 1,000,000.

Here are the run times of the five different algorithms using the
performance input data set.

    Binary Search:             31.62s
    Diagonal Binary Search:    32.46s
    Step-wise Linear Search:   10.71s 
    Quad Partition:            17.33s
    Binary Partition:          10.93s
    Improved Binary Partition:  6.56s

As you can see from the results above, the *Improved Binary Partition*
method is clearly the winner here.

**Input:**  
Each test case starts with two integers, **M** and **N**. **M** is the
number of rows and **N** is the number of columns of the matrix. The
subsequent **M** lines would be the contents of the matrix in row-order.
Each line would contain **N** integers separated by a single space.
Following that is a blank line, with an integer, **K**, the total number
of targets to be searched in the matrix. The next line contains **K**
integers in one line, each of them separated by a single space. After
that is a blank line. Then followed by the next case. **M**=0 and
**N**=0 and **K**=0 indicates that there are no more inputs.

**Output:**  
For each test case, output “Test case \#*x*“, where *x* is the test case
number starting from 1. After that you should have **K** lines, each
line telling if the target is found in the matrix or not. If the target
is found in the matrix, output “Target *y* found at (*i*,*j*)”, where
*y* is the searched element, while *i* and *j* are the row and column
number of the found element respectively. If the target could not be
found, then output “Target *y* not found”. The next test case should be
separated by a blank line from the above test case.

**Sample Input:**

    1 1
    1

    3
    0 1 2

    1 2
    -1 3

    8
    -2 -1 0 1 2 3 4 5

    0 0
    0

**Sample Output:**

    Test case #1
    Target 0 not found
    Target 1 found at (1,1)
    Target 2 not found

    Test case #2
    Target -2 not found
    Target -1 found at (1,1)
    Target 0 not found
    Target 1 not found
    Target 2 not found
    Target 3 found at (1,2)
    Target 4 not found
    Target 5 not found

**Attachments:**  
» [Download Easy
Input](http://sites.google.com/site/ihas1337code/matrix_search_easy_input.txt)  
» [Download Easy
Output](http://sites.google.com/site/ihas1337code/matrix_search_easy_output.txt)  
» [Download Hard
Input](http://sites.google.com/site/ihas1337code/matrix_search_hard_input.txt)  
» [Download Hard
Output](http://sites.google.com/site/ihas1337code/matrix_search_hard_output.txt)  
» [Download Performance
Input](http://sites.google.com/site/ihas1337code/matrix_search_performance1000_input.txt)

**Further Thoughts:**  
A variation of this problem had been asked in Amazon interviews:  

> 2D Matrix(*n* \* *n*) of positive and negative numbers is given.
> Matrix is sorted rowwise and columnwise. You have to return the count
> of -ve numbers in most optimal way.

VN:F [1.9.22\_1171]

Rating: 4.8/**5** (15 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Searching a 2D Sorted Matrix Part III</span></span>, <span
class="rating"><span class="average">4.8</span> out of <span
class="best">5</span> based on <span class="votes">15</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/10/searching-2d-sorted-matrix-part-iii.html>

### Leave a reply

### 3 trackbacks

-   *on July 25, 2011*
-   *on August 8, 2014*
-   *on October 8, 2014*

> Write an efficient algorithm that searches for a value in an *n* x *m*
> table (two-dimensional array). This table is sorted along the rows and
> columns — that is,
>
> Table[i][j] ≤ Table[i][j + 1],  
> Table[i][j] ≤ Table[i + 1][j]

<span id="more-46"></span>  

[Google this
problem](http://www.google.com/search?q=searching+an+element+in+a+sorted+matrix)
and you will see that a lot of sites have posted this problem before me.
So why another blog post?

I have read through forums, blog posts, and go through each comment
people made. Surprisingly, most people had answered this question
incorrectly. Especially the run time complexity part. They just put down
the recurrence formula and “guess” the complexity. It just don’t work
like that. To save you from frustration, I decided to post all possible
solutions and my in-depth analysis here.

The most efficient solution is surprisingly easy to code. Its run time
analysis is also easy to prove. It is also surprisingly easy to make
incorrect assumptions if you are not careful.

**Note:**  
For the sake of run time complexity analysis, we will assume that the
matrix is a square matrix of size *n* x *n*. Your algorithm should work
on matrix of size *m* x *n* though.

[![](http://3.bp.blogspot.com/_UElib2WLeDE/TKxHZ0TZjeI/AAAAAAAACWI/53zbyt6LwpE/s1600/matrix.png)](http://3.bp.blogspot.com/_UElib2WLeDE/TKxHZ0TZjeI/AAAAAAAACWI/53zbyt6LwpE/s1600/matrix.png)

Elements are sorted across each row and each column in this 2D matrix.
This is also known as a [Young
Tableau](http://en.wikipedia.org/wiki/Young_tableau).

**Hint:**  
If you are choosing a place to start from, try the top right corner. Or
the bottom left corner.

**Binary Search Solution:**  
Most people will observe the keyword “sorted”, which no surprise that
the idea of applying Binary Search to each row (or to each column) came
up immediately. As each row takes *O*(lg *n*) time to search, and there
are a total of *n* rows, we are able to do it in *O*(*n* lg *n*) time.
Of course, your interviewer will tell you that this is not a good enough
solution. In fact, this is the first trap that you should look out for!
Do not confine yourself into thinking that binary search is the only way
to solve this problem.

**Incorrect Solution:**  
Here is another trap that most people will fall into if they are not
careful enough. This is based on an incorrect assumption that if the
target element falls between two numbers in the first row, then the
target element must be within that two column. If not, then the target
element does not exist.

Assume that you are searching for **9**. You scan through the first row
and see that **9** appears between **7** and **11**. Therefore, apply
Binary Search on these two columns (highlighted in yellow below). This
is wrong, try to look for **10** in the matrix. **10** does not belong
to any of those two columns.

[![](http://3.bp.blogspot.com/_UElib2WLeDE/TKxUbgvK3qI/AAAAAAAACWM/iD0Zbx201yI/s1600/matrix_hi1.png)](http://3.bp.blogspot.com/_UElib2WLeDE/TKxUbgvK3qI/AAAAAAAACWM/iD0Zbx201yI/s1600/matrix_hi1.png)

Apply binary search across the highlighted columns. Searches **9** but
failed to search for **10**.

What if we do the same to the rows too? That is, since **10** is between
**3** and **10**, we apply binary search both to the two rows and two
columns (as highlighted in yellow below). Finally, **10** could be found
now. Although it seems to work in this example matrix, this is an
incorrect solution. Coming up with a counter example is left as an
exercise to the reader.

[![](http://1.bp.blogspot.com/_UElib2WLeDE/TKxW1avetEI/AAAAAAAACWQ/PAqTro0QqdM/s1600/matrix_hi2.png)](http://1.bp.blogspot.com/_UElib2WLeDE/TKxW1avetEI/AAAAAAAACWQ/PAqTro0QqdM/s1600/matrix_hi2.png)

Apply binary search across the highlighted rows and columns. Searches
both **9** and **10** now. Is this solution correct? Try to come up with
a counter example.

**Diagonal Binary Search (Still not there yet):**  
Still not giving up, you keep on brainstorming on how you can do a
Binary Search in a more efficient manner.

How about we traverse the matrix diagonally starting from the top right
corner? We will call this method the *Diagonal Binary Search* method.
You may also start from the bottom left corner, it doesn’t matter.

Assume that our target is ’10′. We start from the top right corner,
which contains the element **15**. Since **10** is less than **15**, we
could eliminate the entire column from consideration as illustrated
below (Areas that are eliminated are colored in gray). This follows from
the rule that the column is in sorted order.

[![](http://1.bp.blogspot.com/_UElib2WLeDE/TKxaSgQBzGI/AAAAAAAACWU/IDe3LNjWAl8/s1600/matrix_hi3.png)](http://1.bp.blogspot.com/_UElib2WLeDE/TKxaSgQBzGI/AAAAAAAACWU/IDe3LNjWAl8/s1600/matrix_hi3.png)

Eliminated areas are shown in gray. We start from the upper right
corner, and traverse in a diagonal pattern.

We apply binary search from element **1** to **11** on the first row.
Since **10** is not found, we proceed to the next diagonal step, which
is **12**. **10** is less than **12**, therefore we do a binary search
from **2** to **8** across the second row. Since **8** is less than
**12**, you could skip doing a binary search anyway. Now, the eliminated
areas are shown below. You could see that we continue next with element
**9** and do a binary search across the third column from **14** to
**23**. Eventually we will find **10** following that.

[![](http://4.bp.blogspot.com/_UElib2WLeDE/TKxb9NkEl1I/AAAAAAAACWY/UjB_9L1GXf4/s1600/matrix_hi4.png)](http://4.bp.blogspot.com/_UElib2WLeDE/TKxb9NkEl1I/AAAAAAAACWY/UjB_9L1GXf4/s1600/matrix_hi4.png)

Eliminated areas are shown in gray. We have just completed the second
step.

As we traverse diagonally, there’s one less item to search for either
across the row or column. Therefore, the run time complexity can be
written as:

    T(n) = lg n + lg (n-1) + lg (n-2) + ... + lg (1) 
         = lg n(n-1)(n-2)...(1) 
         = lg n!

Compared to the previous method, this is a tiny bit of improvement over
the last method. Proof of lg *n*! is less than *n* lg *n* is left as an
exercise to the reader.

**<span>» Continue reading</span> [Part II: Searching a 2D Sorted
Matrix](http://www.leetcode.com/2010/10/searching-2d-sorted-matrix-part-ii.html).**

VN:F [1.9.22\_1171]

Rating: 4.6/**5** (13 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Searching a 2D Sorted Matrix Part I</span></span>, <span
class="rating"><span class="average">4.6</span> out of <span
class="best">5</span> based on <span class="votes">13</span> ratings
<span class="summary"></span></span></span>

> Suppose a sorted array is rotated at some pivot unknown to you
> beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). How do
> you find an element in the rotated array efficiently? You may assume
> no duplicate exists in the array.

<span id="more-13"></span>  

**<span>Note:</span>**  
 I have updated the problem description to assume that there exists no
duplicate in the array. Some readers have noted that the below code does
not work for input with duplicates. For example, for input “1 2 1 1 1
1″, the binary search method below would not work, as there is no way to
know if an element exists in the array without going through each
element one by one.  
  
[![](http://3.bp.blogspot.com/_UElib2WLeDE/S8TAqqC2_4I/AAAAAAAACII/BJ11UEyVDp0/s320/rotatedarray.PNG)](http://3.bp.blogspot.com/_UElib2WLeDE/S8TAqqC2_4I/AAAAAAAACII/BJ11UEyVDp0/s1600/rotatedarray.PNG)

At first look, we know that we can do a linear search in O(*n*) time.
But linear search does not need the elements to be sorted in any way.

First, we know that it is a sorted array that’s been rotated. Although
we do not know where the rotation pivot is, there is a property we can
take advantage of. Here, we make an observation that a rotated array can
be classified as two sub-array that is sorted (i.e., 4 5 6 7 0 1 2
consists of two sub-arrays 4 5 6 7 and 0 1 2.

Do not jump to conclusion that we need to first find the location of the
pivot and then do binary search on both sub-arrays. Although this can be
done in O(lg *n*) time, this is not necessary and is more complicated.

In fact, we don’t need to know where the pivot is. Look at the middle
element (**7**). Compare it with the left most (**4**) and right most
element (**2**). The left most element (**4**) is less than (**7**).
This gives us valuable information — All elements in the bottom half
must be in *strictly increasing order*. Therefore, if the key we are
looking for is between **4** and **7**, we eliminate the upper half; if
not, we eliminate the bottom half.

When left index is greater than right index, we have to stop searching
as the key we are finding is not in the array.

Since we reduce the search space by half each time, the complexity must
be in the order of *O*(lg *n*). It is similar to binary search but is
somehow modified for this problem. In fact, this is more general than
binary search, as it works for both rotated and non-rotated arrays.

int rotated\_binary\_search(int A[], int N, int key) { int L = 0; int R
= N - 1; while (L \<= R) { // Avoid overflow, same as M=(L+R)/2 int M =
L + ((R - L) / 2); if (A[M] == key) return M; // the bottom half is
sorted if (A[L] \<= A[M]) { if (A[L] \<= key && key \< A[M]) R = M - 1;
else L = M + 1; } // the upper half is sorted else { if (A[M] \< key &&
key \<= A[R]) L = M + 1; else R = M - 1; } } return -1; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">rotated_binary_search</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">key</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">L</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">R</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">N</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">L</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">R</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="c">// Avoid overflow, same as M=(L+R)/2</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">M</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">L</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="sy">(</span><span class="i">R</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">L</span><span class="sy">)</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">2</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="i">M</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">key</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="i">M</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">    </span><span class="c">// the bottom half is sorted</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="i">L</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">M</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="i">L</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">key</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">key</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">M</span><span class="sy">]</span><span class="sy">)</span></p>
<p><span class="h">        </span><span class="v">R</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">M</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">else</span></p>
<p><span class="h">        </span><span class="v">L</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">M</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="c">// the upper half is sorted</span></p>
<p><span class="h">    </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="i">M</span><span class="sy">]</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">key</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="i">key</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">R</span><span class="sy">]</span><span class="sy">)</span></p>
<p><span class="h">        </span><span class="v">L</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">M</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">else</span><span class="h"> </span></p>
<p><span class="h">        </span><span class="v">R</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">M</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

The above solution is able to search for an element without knowing
where the pivot is. Challenge yourself with the problem below.  

> Implement the following function, FindSortedArrayRotation, which takes
> as its input an array of unique integers that has been sorted in
> ascending order, then rotated by an unknown amount X where 0

**Solution:**  
This time you have to search for the rotation pivot. There is a subtle
observation. This problem is in fact the same as finding the minimum
element’s index. If the middle element is greater than the right most
element, then the pivot must be to the right; if it is not, the pivot
must be to the left.

int FindSortedArrayRotation(int A[], int N) { int L = 0; int R = N - 1;
while (A[L] \> A[R]) { int M = L + (R - L) / 2; if (A[M] \> A[R]) L =
M + 1; else R = M; } return L; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">FindSortedArrayRotation</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">N</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">L</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">R</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">N</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="i">L</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">R</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">M</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">L</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="i">R</span><span class="h"> </span><span class="o">-</span><span class="h"> </span><span class="i">L</span><span class="sy">)</span><span class="h"> </span><span class="o">/</span><span class="h"> </span><span class="cn">2</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="i">M</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">R</span><span class="sy">]</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">L</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">M</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">else</span></p>
<p><span class="h">      </span><span class="v">R</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">M</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">L</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Some Test Cases:**

{ 1 }  
return 0
{ 1, 2 }  
return 0

{ 2, 1 }  
return 1

{ 1, 2, 3 }  
return 0

{ 3, 1, 2 }  
return 1

{ 2, 3, 1 }  
return 2

{ 1, 2, 3, 4, 5 }  
return 0

{ 2, 3, 4, 5, 1 }  
return 4

{ 3, 4, 5, 1, 2 }  
return 3

{ 4, 5, 1, 2, 3 }  
return 2

{ 5, 1, 2, 3, 4 }  
return 1

{ 1, 2, 3, 4, 5, 6 }  
return 0

{ 2, 3, 4, 5, 6, 1 }  
return 5

{ 3, 4, 5, 6, 1, 2 }  
return 4

{ 4, 5, 6, 1, 2, 3 }  
return 3

{ 5, 6, 1, 2, 3, 4 }  
return 2

{ 6, 1, 2, 3, 4, 5 }  
return 1

{ 6, 8, 1, 2, 4, 5 }  
return 2

VN:F [1.9.22\_1171]

Rating: 4.7/**5** (25 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Searching an Element in a Rotated Sorted Array</span></span>,
<span class="rating"><span class="average">4.7</span> out of <span
class="best">5</span> based on <span class="votes">25</span> ratings
<span class="summary"></span></span></span>

> Design an algorithm and write code to serialize and deserialize a
> binary tree. Writing the tree to a file is called ‘serialization’ and
> reading back from the file to reconstruct the exact same binary tree
> is ‘deserialization’.

<span id="more-43"></span>

Being able to store a binary tree to a file presents lots of benefits.
First, we are able to save the binary tree to a file and restore it at a
later time. We are also able to transmit the binary tree representation
via network and load it into another computer. Without doubt,
serialization/deserialization of a binary tree is important and an
algorithm to represent a binary tree in a compact way is very desirable.

[![](http://3.bp.blogspot.com/_UElib2WLeDE/TKOkWuJhDLI/AAAAAAAACV0/J7U4Z-ee4tc/s320/binary.jpg)](http://3.bp.blogspot.com/_UElib2WLeDE/TKOkWuJhDLI/AAAAAAAACV0/J7U4Z-ee4tc/s1600/binary.jpg)

Serialization is the process of converting a data structure or object
into a sequence of bits so that it can be stored in a file or memory
buffer, or transmitted across a network connection link to be
“resurrected” later in the same or another computer environment.

**Hint:**  
If you have not read my previous article about [Saving a Binary Search
Tree to a
File](http://www.leetcode.com/2010/09/saving-binary-search-tree-to-file.html),
you should read it now. Since we are dealing with a binary tree, not a
binary search tree (BST), our previous method will not work. However,
this will get you started.

**Solution:**  
Our previous method will not work in the case of Binary Tree, because
binary trees are not bound with the same rule as BST. In order for the
nodes to be inserted at the correct place, we would need to output the
NULL nodes using some kind of sentinel (Here, we use ‘**\#**‘ as the
sentinel) as we are doing pre-order traversal.

Assume we have a binary tree below:

        _30_ 
       /    \    
      10    20
     /     /  \ 
    50    45  35

Using pre-order traversal, the algorithm should write the following to a
file:

    30 10 50 # # # 20 45 # # 35 # #

The pre-order traversal code below does all the job to serialize a
binary tree, believe it or not!

void writeBinaryTree(BinaryTree \*p, ostream &out) { if (!p) { out \<\<
"\# "; } else { out \<\< p-\>data \<\< " "; writeBinaryTree(p-\>left,
out); writeBinaryTree(p-\>right, out); } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">writeBinaryTree</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="i">ostream</span><span class="h"> </span><span class="o">&amp;</span><span class="i">out</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">p</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">out</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot;# &quot;</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">out</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">p</span><span class="o">-&gt;</span><span class="i">data</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="s">&quot; &quot;</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="e">writeBinaryTree</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">out</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="e">writeBinaryTree</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">out</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Deserializing a Binary Tree:**

Reading the binary tree from the file is similar. We read tokens one at
a time using pre-order traversal. If the token is a sentinel, we ignore
it. If the token is a number, we insert it to the current node, and
traverse to its left child, then its right child.

void readBinaryTree(BinaryTree \*&p, ifstream &fin) { int token; bool
isNumber; if (!readNextToken(token, fin, isNumber)) return; if
(isNumber) { p = new BinaryTree(token); readBinaryTree(p-\>left, fin);
readBinaryTree(p-\>right, fin); } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">readBinaryTree</span><span class="sy">(</span><span class="e">BinaryTree *</span><span class="o">&amp;</span><span class="i">p</span><span class="sy">,</span><span class="h"> </span><span class="i">ifstream</span><span class="h"> </span><span class="o">&amp;</span><span class="i">fin</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="i">token</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">bool</span><span class="h"> </span><span class="i">isNumber</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="e">readNextToken</span><span class="sy">(</span><span class="i">token</span><span class="sy">,</span><span class="h"> </span><span class="i">fin</span><span class="sy">,</span><span class="h"> </span><span class="i">isNumber</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span></p>
<p><span class="h">    </span><span class="st">return</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">isNumber</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">p</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="r">new</span><span class="h"> </span><span class="e">BinaryTree</span><span class="sy">(</span><span class="i">token</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="e">readBinaryTree</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">left</span><span class="sy">,</span><span class="h"> </span><span class="i">fin</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="e">readBinaryTree</span><span class="sy">(</span><span class="i">p</span><span class="o">-&gt;</span><span class="i">right</span><span class="sy">,</span><span class="h"> </span><span class="i">fin</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Alternative Solution:**  
We may also use level-order traversal to write/read binary tree.
Level-order traversal works because like pre-order traversal, we see the
parent node before its child nodes. The implementation of it using
level-order traversal is left as an exercise to the reader. Read my
post: [Printing a Binary Tree in Level
Order](http://www.leetcode.com/2010/09/printing-binary-tree-in-level-order.html)
on how to traverse a binary tree in level-order.

**Further Thoughts:**  
There is an obvious shortcoming in this method, that is: a sentinel is
required to represent empty nodes. What if we need to store strings that
can contain any characters (including the sentinel) in the binary tree?
Could you come up with a solution to overcome this shortcoming?

Please note that this is not the only way to serialize a binary tree,
and also probably not the most compact way. But this is good enough for
a standard interview question. If you would like to explore deeper, and
even apply serialization/deserialization to general trees, you may read
the [Binary Tree article’s encoding
section](http://en.wikipedia.org/wiki/Binary_tree#Encodings) on
Wikipedia.

VN:F [1.9.22\_1171]

Rating: 4.7/**5** (39 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Serialization/Deserialization of a Binary Tree</span></span>,
<span class="rating"><span class="average">4.7</span> out of <span
class="best">5</span> based on <span class="votes">39</span> ratings
<span class="summary"></span></span></span>

> A long array A[] is given to you. There is a sliding window of size
> *w* which is moving from the very left of the array to the very right.
> You can only see the *w* numbers in the window. Each time the sliding
> window moves rightwards by one position. Following is an example:  
>  The array is [1 3 -1 -3 5 3 6 7], and *w* is 3.
>
>     Window position                Max
>     ---------------               -----
>     [1  3  -1] -3  5  3  6  7       3
>      1 [3  -1  -3] 5  3  6  7       3
>      1  3 [-1  -3  5] 3  6  7       5
>      1  3  -1 [-3  5  3] 6  7       5
>      1  3  -1  -3 [5  3  6] 7       6
>      1  3  -1  -3  5 [3  6  7]      7
>
> **Input**: A long array A[], and a window width w  
>  **Output**: An array B[], B[i] is the maximum value of from A[i] to
> A[i+w-1]  
>  **Requirement**: Find a good optimal way to get B[i]

<span id="more-75"></span>

The obvious brute force solution with run time complexity of *O*(*nw*)
is definitely not efficient enough. Every time the window is moved, you
have to search for a total of *w* elements in the window.

A [heap](http://en.wikipedia.org/wiki/Heap_%28data_structure%29) data
structure quickly comes to mind. We could boost the run time to
approximately *O*(*n* lg *w*) (Note that I said approximately because
the size of the heap changes constantly and averages about *w*). Insert
operation takes *O*(lg *w*) time, where *w* is the size of the heap.
However, getting the maximum value is cheap, it merely takes constant
time as the maximum value is always kept in the root (head) of the heap.

As the window slides to the right, some elements in the heap might not
be valid anymore (range is outside of the current window). How should
you remove them? You would need to be somewhat careful here. Since you
only remove elements that are out of the window’s range, you would need
to keep track of the elements’ indices too.

<s>Note that as *n* grows larger, the term lg *w* is pretty
insignificant compared to *n*, and thus the overall complexity
approximates to *O*(*n*).</s> (**<span>Edit:</span>** In fact, the
correct run time complexity should be O(*n* log *n*). If A is sorted,
then the inner while loop will never run. This is due to the next
element (which is larger) being pushed to the queue’s top as the new
maximum. (Thanks to my readers
[**<span>anonymous</span>**](http://www.leetcode.com/2011/01/sliding-window-maximum.html#comment-726)
and **<span>faircoin</span>** who pointed out this.)

typedef pair\<int, int\> Pair; void maxSlidingWindow(int A[], int n, int
w, int B[]) { priority\_queue\<Pair\> Q; for (int i = 0; i \< w; i++)
Q.push(Pair(A[i], i)); for (int i = w; i \< n; i++) { Pair p = Q.top();
B[i-w] = p.first; while (p.second \<= i-w) { Q.pop(); p = Q.top(); }
Q.push(Pair(A[i], i)); } B[n-w] = Q.top().first; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="r">typedef</span><span class="h"> </span><span class="i">pair</span><span class="o">&lt;</span><span class="t">int</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="o">&gt;</span><span class="h"> </span><span class="i">Pair</span><span class="sy">;</span></p>
<p><span class="t">void</span><span class="h"> </span><span class="e">maxSlidingWindow</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">w</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">B</span><span class="sy">[</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="i">priority_queue</span><span class="o">&lt;</span><span class="i">Pair</span><span class="o">&gt;</span><span class="h"> </span><span class="i">Q</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">w</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="v">Q</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="e">Pair</span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="i">i</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">w</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">Pair</span><span class="h"> </span><span class="v">p</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">Q</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">B</span><span class="sy">[</span><span class="i">i</span><span class="o">-</span><span class="i">w</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">p</span><span class="sy">.</span><span class="i">first</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="v">p</span><span class="sy">.</span><span class="i">second</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">i</span><span class="o">-</span><span class="i">w</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">Q</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="v">p</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">Q</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">    </span><span class="v">Q</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="e">Pair</span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="i">i</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="v">B</span><span class="sy">[</span><span class="i">n</span><span class="o">-</span><span class="i">w</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">Q</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="sy">.</span><span class="i">first</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

You might be wondering: Is there a better way of doing this without
using a heap? How about using a [double-ended
queue](http://en.wikipedia.org/wiki/Double-ended_queue)? (A linked list
should be fine too)

The double-ended queue is the perfect data structure for this problem.
It supports insertion/deletion from the front and back. The trick is to
find a way such that the largest element in the window would always
appear in the front of the queue. How would you maintain this
requirement as you push and pop elements in and out of the queue?

Besides, you might notice that there are some redundant elements in the
queue that we shouldn’t even consider about. For example, if the current
queue has the elements: [10 5 3], and a new element in the window has
the element 11. Now, we could have emptied the queue without considering
elements 10, 5, and 3, and insert only element 11 into the queue.

A natural way most people would think is to try to maintain the queue
size the same as the window’s size. Try to break away from this thought
and try to think outside of the box. Removing redundant elements and
storing only elements that need to be considered in the queue is the key
to achieve the efficient O(*n*) solution below.

void maxSlidingWindow(int A[], int n, int w, int B[]) { deque\<int\> Q;
for (int i = 0; i \< w; i++) { while (!Q.empty() && A[i] \>=
A[Q.back()]) Q.pop\_back(); Q.push\_back(i); } for (int i = w; i \< n;
i++) { B[i-w] = A[Q.front()]; while (!Q.empty() && A[i] \>= A[Q.back()])
Q.pop\_back(); while (!Q.empty() && Q.front() \<= i-w) Q.pop\_front();
Q.push\_back(i); } B[n-w] = A[Q.front()]; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">maxSlidingWindow</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">w</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">B</span><span class="sy">[</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="i">deque</span><span class="o">&lt;</span><span class="t">int</span><span class="o">&gt;</span><span class="h"> </span><span class="i">Q</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">w</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">Q</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="v">Q</span><span class="sy">.</span><span class="e">back</span><span class="sy">(</span><span class="sy">)</span><span class="sy">]</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">Q</span><span class="sy">.</span><span class="e">pop_back</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">Q</span><span class="sy">.</span><span class="e">push_back</span><span class="sy">(</span><span class="i">i</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">w</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">B</span><span class="sy">[</span><span class="i">i</span><span class="o">-</span><span class="i">w</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="v">Q</span><span class="sy">.</span><span class="e">front</span><span class="sy">(</span><span class="sy">)</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">Q</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="v">Q</span><span class="sy">.</span><span class="e">back</span><span class="sy">(</span><span class="sy">)</span><span class="sy">]</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">Q</span><span class="sy">.</span><span class="e">pop_back</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="v">Q</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">Q</span><span class="sy">.</span><span class="e">front</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">i</span><span class="o">-</span><span class="i">w</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">Q</span><span class="sy">.</span><span class="e">pop_front</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">Q</span><span class="sy">.</span><span class="e">push_back</span><span class="sy">(</span><span class="i">i</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="v">B</span><span class="sy">[</span><span class="i">n</span><span class="o">-</span><span class="i">w</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="v">Q</span><span class="sy">.</span><span class="e">front</span><span class="sy">(</span><span class="sy">)</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

The above algorithm could be proven to have run time complexity of
O(*n*). This is because each element in the list is being inserted and
then removed **at most once**. Therefore, the total number of insert +
delete operations is 2*n*.

VN:F [1.9.22\_1171]

Rating: 4.8/**5** (79 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Sliding Window Maximum</span></span>, <span
class="rating"><span class="average">4.8</span> out of <span
class="best">5</span> based on <span class="votes">79</span> ratings
<span class="summary"></span></span></span>

Splitting Linked List
=====================

September 11, 2010 <span>in [linked
list](http://leetcode.com/category/linked-list "View all posts in linked list")</span>
<span class="post-utility alignright"></span>

> Given a list, split it into two sublists — one for the front half, and
> one for the back half. If the number of elements is odd, the extra
> element should go in the front list. So FrontBackSplit() on the list
> {2, 3, 5, 7, 11} should yield the two lists {2, 3, 5} and {7, 11}.

<span id="more-32"></span>This is a very good linked list question, as
there are tricky cases you have to consider, and getting them all right
in one place is harder than it looks. It also has a very obvious simple
solution, which is to iterate the list twice. The first time to count
how many elements in the list, and the second time to find the splitting
point.

Can we do better? You bet.

Hint: Try to use two pointers to traverse the list.

Solution: We use two pointers (we call it a slow pointer and a fast
pointer). The slow pointer advances one node at a time, while the fast
pointer advances two nodes at a time. By the time the fast pointer
reaches the end, the slow pointer would have reached the splitting point
(or near). Care must be taken to account those special cases. Below is a
solution that works for all cases.

void FrontBackSplit(Node \*head, Node \*\*front, Node \*\*back) { if
(!head) return; // Handle empty list Node \*front\_last\_node;
Node \*slow = head; Node \*fast = head; while (fast) { front\_last\_node
= slow; slow = slow-\>next; fast = (fast-\>next) ? fast-\>next-\>next :
NULL; } front\_last\_node-\>next = NULL; // ends the front
sublist \*front = head; \*back = slow; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">void</span><span class="h"> </span><span class="e">FrontBackSplit</span><span class="sy">(</span><span class="e">Node *</span><span class="i">head</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="o">*</span><span class="i">front</span><span class="sy">,</span><span class="h"> </span><span class="e">Node *</span><span class="o">*</span><span class="i">back</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="o">!</span><span class="i">head</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="sy">;</span><span class="h">  </span><span class="c">// Handle empty list</span></p>
<p><span class="h">  </span><span class="e">Node *</span><span class="i">front_last_node</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Node *</span><span class="v">slow</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">head</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="e">Node *</span><span class="v">fast</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">head</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">fast</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">front_last_node</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">slow</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">slow</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">slow</span><span class="o">-&gt;</span><span class="i">next</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">fast</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">(</span><span class="i">fast</span><span class="o">-&gt;</span><span class="i">next</span><span class="sy">)</span><span class="h"> </span><span class="sy">?</span><span class="h"> </span><span class="i">fast</span><span class="o">-&gt;</span><span class="i">next</span><span class="o">-&gt;</span><span class="i">next</span><span class="h"> </span><span class="o">:</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="i">front_last_node</span><span class="o">-&gt;</span><span class="v">next</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="t">NULL</span><span class="sy">;</span><span class="h">  </span><span class="c">// ends the front sublist</span></p>
<p><span class="h">  </span><span class="o">*</span><span class="v">front</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">head</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="o">*</span><span class="v">back</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">slow</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.1/**5** (8 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Splitting Linked List</span></span>, <span
class="rating"><span class="average">4.1</span> out of <span
class="best">5</span> based on <span class="votes">8</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/09/splitting-linked-list.html>

Stack that Support Push, Pop, and GetMin in Constant Time
=========================================================

November 16, 2010 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> Design a stack that supports push, pop, and retrieving the minimum
> element in constant time. Can you do this?

<span id="more-57"></span>  
 Today, I read this interesting problem (**exercise 4-44**) from the
excellent book “[The Algorithm Design
Manual](http://www.amazon.com/Algorithm-Design-Manual-Steve-Skiena/dp/0387948600)”
by Steven Skiena.

Initially I thought of using an extra min-heap to store the elements.
Although this enables us to retrieve the minimum element in *O*(1), push
and pop operations both operates in *O*(lg *N*), where *N* is the total
number of elements in the stack. Definitely not a desirable method.

How about recording the current minimum in the stack? This works until
you pop current minimum off the stack, where you would have to update
your next minimum, which takes *O*(*N*) time to examine all elements.

**Hint:**  
Assume you have an extra stack. What would you do with the extra stack?

[![](http://4.bp.blogspot.com/_UElib2WLeDE/TONExbuGwPI/AAAAAAAACYs/4QBqKnu8WlU/s320/stack.jpg)](http://4.bp.blogspot.com/_UElib2WLeDE/TONExbuGwPI/AAAAAAAACYs/4QBqKnu8WlU/s1600/stack.jpg)

<span>Stack is a last in, first out (LIFO) data structure. It can be
easily implemented either through an array or a linked list.</span>

**Solution:**  
The solution is surprisingly simple and elegant — Use an extra stack to
maintain the minimums. What does this mean?

-   To retrieve the current minimum, just return the top element from
    minimum stack.
-   Each time you perform a push operation, check if the pushed element
    is a new minimum. If it is, push it to the minimum stack too.
-   When you perform a pop operation, check if the popped element is the
    same as the current minimum. If it is, pop it off the minimum stack
    too.

All of the above operates in *O*(1) constant time.

**A Gotcha:**

There is one small gotcha I purposely left in the above solution. Could
you figure it out without looking at the code below first?

struct StackGetMin { void push(int x) { elements.push(x); if
(minStack.empty() || x \<= minStack.top()) minStack.push(x); } bool
pop() { if (elements.empty()) return false; if (elements.top() ==
minStack.top()) minStack.pop(); elements.pop(); return true; } bool
getMin(int &min) { if (minStack.empty()) { return false; } else { min =
minStack.top(); return true; } } stack\<int\> elements; stack\<int\>
minStack; };
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">struct</span><span class="h"> </span><span class="e">StackGetMin</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">void</span><span class="h"> </span><span class="e">push</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">x</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="v">elements</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">x</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">minStack</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">x</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="v">minStack</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">minStack</span><span class="sy">.</span><span class="e">push</span><span class="sy">(</span><span class="i">x</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="t">bool</span><span class="h"> </span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">elements</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">elements</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="v">minStack</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">minStack</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="v">elements</span><span class="sy">.</span><span class="e">pop</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="t">bool</span><span class="h"> </span><span class="e">getMin</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="o">&amp;</span><span class="i">min</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">minStack</span><span class="sy">.</span><span class="e">empty</span><span class="sy">(</span><span class="sy">)</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="t">false</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span><span class="h"> </span><span class="st">else</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">min</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">minStack</span><span class="sy">.</span><span class="e">top</span><span class="sy">(</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">return</span><span class="h"> </span><span class="t">true</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="i">stack</span><span class="o">&lt;</span><span class="t">int</span><span class="o">&gt;</span><span class="h"> </span><span class="i">elements</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">stack</span><span class="o">&lt;</span><span class="t">int</span><span class="o">&gt;</span><span class="h"> </span><span class="i">minStack</span><span class="sy">;</span></p>
<p><span class="sy">}</span><span class="sy">;</span></p>
</div></td>
</tr>
</tbody>
</table>

**Further Thoughts:**

Before we conclude this section, try a variation of this problem
(appeared as a [Google interview
question](http://www.leetcode.com/search/label/google%20interview)):  

> Design a queue that supports push\_rear, pop\_front, and get\_min in
> *O*(1). Would that be elegantly possible too?

**Hint:**  
Use two queues.

If you need extra hints, see [this
post](http://www.leetcode.com/2011/01/sliding-window-maximum.html) (both
problems are related). If you could design a queue with push\_rear,
pop\_front, and get\_min in *O*(1), then finding the [Sliding Window
Maximum](http://www.leetcode.com/2011/01/sliding-window-maximum.html)
could be solved by direct application of such data structure.

VN:F [1.9.22\_1171]

Rating: 4.7/**5** (31 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Stack that Support Push, Pop, and GetMin in Constant
Time</span></span>, <span class="rating"><span
class="average">4.7</span> out of <span class="best">5</span> based on
<span class="votes">31</span> ratings <span
class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2010/11/stack-that-supports-push-pop-and-getmin.html>

### Leave a reply

### 4 trackbacks

-   *on October 20, 2012*
-   *on June 14, 2013*
-   *on October 8, 2014*
-   *on November 16, 2014*

Studious Student Problem Analysis
=================================

January 10, 2011 <span>in
[Uncategorized](http://leetcode.com/category/uncategorized "View all posts in Uncategorized")</span>
<span class="post-utility alignright"></span>

> You’ve been given a list of words to study and memorize. Being a
> diligent student of language and the arts, you’ve decided to not study
> them at all and instead make up pointless games based on them. One
> game you’ve come up with is to see how you can concatenate the words
> to generate the lexicographically lowest possible string.<span
> id="more-73"></span>
>
> **Input**  
> ****As input for playing this game you will receive a text file
> containing an integer **N**, the number of word sets you need to play
> your game against. This will be followed by **N** word sets, each
> starting with an integer **M**, the number of words in the set,
> followed by **M** words. All tokens in the input will be separated by
> some whitespace and, aside from **N** and **M**, will consist entirely
> of lowercase letters.  
> **  
> Output**  
> ****Your submission should contain the lexicographically shortest
> strings for each corresponding word set, one per line and in order.  
> **  
> Constraints**  
> 1 N 1 M 1

Here is my problem analysis for Facebook Hacker Cup Qualification Round:
Studious Student.

**Studious Student Problem Analysis:**  
As I mentioned, this problem is not as straight forward as you think it
might be. The first most natural way to approach this problem is
sorting. Most people will reason that you can sort and concatenate each
individual word together to form the lexicographically smallest string.
This is incorrect, as illustrated in one of the sample inputs:

**jibw ji jp bw jibw**

By sorting and concatenate, the answer is:

**bwjijibwjibwjp**,

while the correct answer should be:

**bwjibwjibwjijp**.

[![](http://2.bp.blogspot.com/_UElib2WLeDE/TSuum2i-8oI/AAAAAAAACcM/Vt55w-yj2Rk/s320/dictionary_page.jpg)](http://2.bp.blogspot.com/_UElib2WLeDE/TSuum2i-8oI/AAAAAAAACcM/Vt55w-yj2Rk/s1600/dictionary_page.jpg)

<span>Lexicographical order is also known as dictionary order, since it
is how the words are ordered in the dictionary.</span>

Notice in the above words, “**ji**” is the prefix of “**jibw**“. The
“*sort and concatenate*” method definitely does not work when there is a
case where a word is a prefix of one or more other words.

Well, one might try a naive way of doing a brute force. Although it is
highly inefficient, it works for this problem. This is because each
input would be at most **9** words, and it turns out there are only a
total of **9!** = **362880** possible permutations of words being
concatenated together. Therefore, one can generate all possible
permutations and find the answer.

We make an easy observation that if all words in the list are of equal
length, then *sort + concatenate* must yield the smallest dictionary
order. In fact, a better argument would be:

If no word appears to be a prefix of any other words, then the simple
*sort + concatenate* must yield the smallest dictionary order string.

To solve this problem correctly, we must also handle the special case
where a word appears as a prefix of other words. One efficient and easy
(non-trivial to prove but easy to reason) solution for this problem is
to re-define the order relation of two words, *s1* and *s2*, as:

*s1* is less than *s2* **iff (if and only if)**  
**  
** *s1* + *s2* s2 + *s1*.

Then, by sorting and concatenating the words using the above ordering,
it must yield the lexicographically smallest string. Why?

Here is a concrete example why this works. We use an example where the
list of words are:

**ji** **jibw** **jijibw**

By the definition of *s1* is less than *s2* iff *s1*+*s2* s2+*s1*, we
found that the lowest ordered word in the list is “**jibw**“. This is
because “**jibwji**” jijibw” and “**jibwjijibw**” jijibwjibw“.

Now, the key to understand why the order relation s1+s2

-   We have found the smallest-ordered word such that s1+x
-   For a case with more words, then this order relation holds: s1+x
-   This result can be generalized to all *M* words by induction, due to
    the transitive property mentioned above.

I do not claim that this is a rigid or even a correctly constructed
proof. However, it does help me in convincing myself this is a valid
solution.

bool compareSort(const string &s1, const string &s2) { return s1 + s2 \<
s2 + s1; } int main() { string words[10]; int N, M; cin \>\> N; for (int
i = 0; i \< N; i++) { cin \>\> M; for (int j = 0; j \< M; j++) cin \>\>
words[j]; sort(words, words+M, compareSort); for (int j = 0; j \< M;
j++) cout \<\< words[j]; cout \<\< endl; } }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">bool</span><span class="h"> </span><span class="e">compareSort</span><span class="sy">(</span><span class="m">const</span><span class="h"> </span><span class="t">string</span><span class="h"> </span><span class="o">&amp;</span><span class="i">s1</span><span class="sy">,</span><span class="h"> </span><span class="m">const</span><span class="h"> </span><span class="t">string</span><span class="h"> </span><span class="o">&amp;</span><span class="i">s2</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">s1</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="i">s2</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">s2</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="i">s1</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">int</span><span class="h"> </span><span class="e">main</span><span class="sy">(</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">string</span><span class="h"> </span><span class="v">words</span><span class="sy">[</span><span class="cn">10</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="i">N</span><span class="sy">,</span><span class="h"> </span><span class="i">M</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">N</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">N</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="i">M</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">M</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="i">cin</span><span class="h"> </span><span class="o">&gt;&gt;</span><span class="h"> </span><span class="v">words</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">    </span><span class="e">sort</span><span class="sy">(</span><span class="i">words</span><span class="sy">,</span><span class="h"> </span><span class="i">words</span><span class="o">+</span><span class="i">M</span><span class="sy">,</span><span class="h"> </span><span class="i">compareSort</span><span class="sy">)</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">M</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="v">words</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="i">cout</span><span class="h"> </span><span class="o">&lt;&lt;</span><span class="h"> </span><span class="i">endl</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

VN:F [1.9.22\_1171]

Rating: 4.4/**5** (14 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Studious Student Problem Analysis</span></span>, <span
class="rating"><span class="average">4.4</span> out of <span
class="best">5</span> based on <span class="votes">14</span> ratings
<span class="summary"></span></span></span>
### Source

<http://leetcode.com/2011/01/studious-student-problem-analysis.html>

 

The Painter’s Partition Problem Part II
=======================================

April 6, 2011 <span>in [binary
search](http://leetcode.com/category/binary-search "View all posts in binary search")</span>
<span class="post-utility alignright"></span>

<span>**Note:**</span>  
 This is Part II of the article: [The Painter’s Partition
Problem](http://www.leetcode.com/2011/04/the-painters-partition-problem.html).
Please read [Part
I](http://www.leetcode.com/2011/04/the-painters-partition-problem.html)
for more background information.  
 <span id="more-538"></span>

> You have to paint N boards of length {A<sub>0</sub>, A<sub>1</sub>,
> A<sub>2</sub> … A<sub>N-1</sub>}. There are *K* painters available and
> you are also given how much time a painter takes to paint 1 unit of
> board. You have to get this job done as soon as possible under the
> constraints that any painter will only paint continuous sections of
> board, say board {2, 3, 4} or only board {1} or nothing but not board
> {2, 4, 5}.

In my [previous
post](http://www.leetcode.com/2011/04/the-painters-partition-problem.html)
we talked about how to use the power of [Dynamic
Programming](http://www.leetcode.com/category/dynamic-programming) (DP)
to solve a fairly difficult problem. Although the DP approach is pretty
neat, it uses an extra O(*kN*) space. In this post, we introduce an
algorithm without extra space and runs in the order of O(*N* log *c*)
time, where *c* is the sum of all elements in A.

**Hint:**  
 Try to think how to apply Binary Search indirectly to solve this
problem. First, it does not require A to be sorted in any way. Second,
if you sort A, the constraint that the painter must paint continuous
sections of board does not necessarily hold anymore. Think carefully:
What if you have a maximum board length in mind such that no painter can
exceed this value?

**Solution:**  
 Assume that you are assigning continuous section of board to each
painter such that its total length must not exceed a predefined maximum,
cost<sub>max</sub>. Then, you are able to find the number of painters
that is required, *x*. Following are some key observations:

1.  The lowest possible value for cost<sub>max</sub> must be the maximum
    element in A (name this as **lo**).
2.  The highest possible value for cost<sub>max</sub> must be the entire
    sum of A, (name this as **hi**).
3.  As cost<sub>max</sub> increases, *x* decreases. The opposite also
    holds true.

Now, the question translates directly into:

How do we use binary search to find the minimum of cost<sub>max</sub>
while satisfying the condition *x* = *k*? The search space will be the
range of [**lo**, **hi**].

Let us study using the example below to understand how this works:

    Assume that A = { 100, 200, 300, 400, 500, 600, 700, 800, 900 }, 
    and k = 3.

Since *k* is positive, we know that the highest possible
cost<sub>max</sub> must be the sum of A, 4500. (ie, assigning all boards
to one painter).

The lowest possible cost<sub>max</sub> must be the largest element in A,
900. This requires a total of six painters — The first painter paints
{100, 200, 300}, second painter paints {400, 500} while the rest of them
paints one board each).

Below is a simple conceptual illustration of how the search space looks
like, with its corresponding *x* value (the required number of painters)
pointing to cost<sub>max</sub>.

    900        ...       4500
     ↑                     ↑
    x=6                   x=1

Note that *x* decreases while cost<sub>max</sub> increases.  
 We want to find the minimum of cost<sub>max</sub> under the constraint
of *x* = *k*.

    900  ...  2700  ...  4500
     ↑          ↑          ↑
    x=6        x=2        x=1

We choose the middle element, 2700, and find its corresponding *x*,
which is 2.  
 Since *x* = *k* (which equals to 3), we can find a better minimum (ie,
the real solution) in the lower half.  
 Therefore, we discard the upper half and continue searching in the
lower half.

    900  ...  1800  ...  2700
     ↑          ↑          ↑
    x=6        x=3        x=2

The middle element now is 1800 and its corresponding *x* is 3, which is
still = *k*.  
 We discard the upper half again and continue searching in the lower
half.

    900  ...  1350  ...  1800
     ↑          ↑          ↑
    x=6        x=5        x=3

This time, the middle element is 1350 and its corresponding *x* is 5,
which is \> *k*.  
 We have to discard the lower half **including the middle element
itself**, since *x* \> *k* in that region (ie, no valid solution).  
 Here, read the phrase in bold **“including the middle element itself“**
again, as this is extremely important to maintain the invariant. Why?  
 Yes, that means the lower half **including** the value 1350 would be
discarded.  
 We continue searching in the upper half (ie, in the range of [1351,
1800]).

…

After multiple successions of halving the search space, the final answer
is 1700, and its corresponding *x* is 3. This is also the minimum of
cost<sub>max</sub> while maintaining the requirement *x* = *k*.

The complexity of this algorithm is *O*(*N* log ( **∑** A<sub>i</sub>
)), which is quite efficient. Furthermore, it does not require any extra
space, unlike the DP solution which requires *O*(*kN*) space. This
solution is also easier to code. Just be very careful while writing code
for any variation of binary search, and think through all the corner
cases while you code.

int getMax(int A[], int n) { int max = INT\_MIN; for (int i = 0; i \< n;
i++) { if (A[i] \> max) max = A[i]; } return max; } int getSum(int A[],
int n) { int total = 0; for (int i = 0; i \< n; i++) total += A[i];
return total; } int getRequiredPainters(int A[], int n, int
maxLengthPerPainter) { int total = 0, numPainters = 1; for (int i = 0; i
\< n; i++) { total += A[i]; if (total \> maxLengthPerPainter) { total =
A[i]; numPainters++; } } return numPainters; } int partition(int A[],
int n, int k) { int lo = getMax(A, n); int hi = getSum(A, n); while (lo
\< hi) { int mid = lo + (hi-lo)/2; int requiredPainters =
getRequiredPainters(A, n, mid); if (requiredPainters \<= k) hi = mid;
else lo = mid+1; } return lo; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>33</p>
<p>34</p>
<p>35</p>
<p>36</p>
<p>37</p>
<p>38</p>
<p>39</p>
<p>40</p>
<p>41</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">getMax</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">max</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">INT_MIN</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">     </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">max</span><span class="sy">)</span><span class="h"> </span><span class="v">max</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">max</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">int</span><span class="h"> </span><span class="e">getSum</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">total</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="i">total</span><span class="h"> </span><span class="o">+</span><span class="o">=</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">total</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">int</span><span class="h"> </span><span class="e">getRequiredPainters</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">maxLengthPerPainter</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">total</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="v">numPainters</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="i">total</span><span class="h"> </span><span class="o">+</span><span class="o">=</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">total</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">maxLengthPerPainter</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">total</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="i">numPainters</span><span class="o">++</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">numPainters</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">int</span><span class="h"> </span><span class="e">partition</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">k</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">lo</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">getMax</span><span class="sy">(</span><span class="i">A</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">hi</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">getSum</span><span class="sy">(</span><span class="i">A</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">while</span><span class="h"> </span><span class="sy">(</span><span class="i">lo</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">hi</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">mid</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">lo</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="sy">(</span><span class="i">hi</span><span class="o">-</span><span class="i">lo</span><span class="sy">)</span><span class="o">/</span><span class="cn">2</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="t">int</span><span class="h"> </span><span class="v">requiredPainters</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">getRequiredPainters</span><span class="sy">(</span><span class="i">A</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="i">mid</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">requiredPainters</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">k</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">hi</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">mid</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="st">else</span></p>
<p><span class="h">      </span><span class="v">lo</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">mid</span><span class="o">+</span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">lo</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Additional Reference:**  
 [TopCoder’s Tutorial on Binary
Search](http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=binarySearch)

<span>**Further Thoughts:**</span>  
 The above binary search solution has a run time complexity of O(N log (
∑ Ai )). What impact would the term ? Ai (ie, the search space) have
over the run time itself? What if the search space is extremely large?

As you may have known, binary search is extremely fast. For example,
binary search in a range of one million elements requires no more than
20 iterations. Here, we explore an alternative solution which reduces
the search space even further. (Thanks to an id grass for the idea)

The idea is to first build a cumulative sum array B, where B[j] =
∑{i=0..j} Ai. We know that we must allocate one of the amount found in
B[j] to the first painter. Since the elements in B is in increasing
order, we can apply binary search in B to answer the following question:

Find the index j such that B[j] fails to satisfy the condition while
B[j+1] satisfy.

Finally, we can set lo = B[j] and hi = B[j+1], and apply the same binary
search from method 1 from above.

Using the above example:

    A = { 100, 200, 300, 400, 500, 600, 700, 800, 900 }, and k = 3.

We build the cumulative array B:

    B = { 100, 300, 600, 1000, 1500, 2100, 2800, 3600, 4500 }

After we apply binary search, we are able to find that B[4] = 1500, B[5]
= 2100, because for costmax = 1500, x = 4; while costmax = 2100, x =3.

Time required: O(N log N)

Then, we set lo = 1500 and hi = 2100, then apply binary search to find
in that range.

Time required: O(N log (B[j+1]-B[j]) ) = O(N log A[j+1]).

Therefore, the worst case run time complexity = O(N log N + N log max(A)
)

VN:F [1.9.22\_1171]

Rating: 4.7/**5** (25 votes cast)

<span class="hreview-aggregate"><span class="item"><span class="fn">The
Painter's Partition Problem Part II</span></span>, <span
class="rating"><span class="average">4.7</span> out of <span
class="best">5</span> based on <span class="votes">25</span> ratings
<span class="summary"></span></span></span>

 

### Source

<http://leetcode.com/2011/04/the-painters-partition-problem-part-ii.html>

> You have to paint N boards of length {A<sub>0</sub>, A<sub>1</sub>,
> A<sub>2</sub> … A<sub>N-1</sub>}. There are *K* painters available and
> you are also given how much time a painter takes to paint 1 unit of
> board. You have to get this job done as soon as possible under the
> constraints that any painter will only paint continuous sections of
> board, say board {2, 3, 4} or only board {1} or nothing but not board
> {2, 4, 5}.

<span id="more-516"></span>  
 This is a problem which is fairly difficult. Try your very best to
really think through it. You will improve your problem solving technique
by struggling through it!

It turns out that this problem is the same as
“[FairWorkload](http://www.topcoder.com/stat?c=problem_statement&pm=1901&rd=4650)”
from TopCoder’s division 1 level 2 problem in SRM 169. If you find the
problem statement above is difficult to understand, head over to
[TopCoder’s FairWorkload problem
statement](http://www.topcoder.com/stat?c=problem_statement&pm=1901&rd=4650)
for a clearer description with examples. This problem is an interesting
problem because it has several approaches, which I will outline them one
by one here.

For most people, the first natural approach is to brute force. Let’s
look at an example where you have nine boards, each of length 100, and
you have three painters. How would you divide the boards?

Very easy, just divide it into three equal-sized partitions!

    100 100 100 | 100 100 100 | 100 100 100

But what if the boards are of different lengths? If we just divide the
boards into three equal-sized partitions, the below configuration would
be divided as:

    100 200 300 | 400 500 600 | 700 800 900

The above allocation is clearly not appropriate, as it is extremely
unfair to the third painter. The third painter has to paint 2400 units
while the first painter paints only 600 units! The fairest possible way
to divide the boards among the three painters should be:

    100 200 300 400 500 | 600 700 | 800 900

In this way, the largest board to paint is 1700 units whilst the
smallest board to paint is 1300 units. Compared to the previous
allocation, this allocation allows painting to finish faster because the
maximum over the partitions has decreased from 2400 to 1700 units.

Now that we understand the problem better, we can re-state the above
problem as follow:

Given an array of non-negative integers A and a positive integer *k*, we
want to:  
 Divide A into *k* or fewer partitions,  
 such that the maximum sum over all the partitions is minimized.

By now, I am sure a handful of people would start thinking a heuristic
approach to solve this problem. How about just computing the average
size of a partition (ie, ∑{*i*=0..*n*-1} A<sub>i</sub> / *k*) and try to
match each partition as closely to the average as possible? Although
this *seemed* to work for the above examples, there is no way you could
evaluate all possibilities systematically and thus do not always produce
the correct solution.

A more systematic way is to use the brute force approach to evaluate all
possibilities. However, brute force in this case is not as straight
forward as it used to be. Stop for awhile and think how you would do an
exhaustive search for all possibilities. (Hint: Try to think
recursively)

Recursion can be utilized to solve this problem easily. Imagine that we
already have (*k*-1) partitions in place (the left partition) and we are
trying to put the last separator (the (*k*-1)th separator). What are the
possible locations to put the last separator? It must lie somewhere
between the (*j*-1)th and *j*th element, where 1 = *j* = *n*. Once we
have the last separator in place, we have completed all *k* partitions.
The cost of this partition arrangement can be readily calculated as the
larger of the two quantities below:

        i) The cost of the last partition, ∑{i=j..n-1} Ai
       ii) The cost of the largest partition formed to the left of j
           (ie, the left partition = { A0, A1, ..., Aj-1 } ).

Now, how do we find ii)? It turns out that we want to place the
remaining (*k*-2) separators such that the left partition is divided as
fairly as possible, which leads to another valid sub-problem itself.
Therefore, we can solve it recursively!

By defining M[*n*, *k*] as the optimum cost of a partition arrangement
with *n* total blocks from the first block and *k* partitions, the
recurrence relation can be stated as follow:

                     n                n-1
    M[n, k] = min { max { M[j, k-1], ∑ Ai } }
                    j=1               i=j

The base cases are:

    M[1, k] = A0
              n-1
    M[n, 1] = ∑ Ai
              i=0

Therefore, the brute force solution can then be coded directly from the
recurrence relation above:

int sum(int A[], int from, int to) { int total = 0; for (int i = from; i
\<= to; i++) total += A[i]; return total; } int partition(int A[], int
n, int k) { if (k == 1) return sum(A, 0, n-1); if (n == 1) return A[0];
int best = INT\_MAX; for (int j = 1; j \<= n; j++) best = min(best,
max(partition(A, j, k-1), sum(A, j, n-1))); return best; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">sum</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">from</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="st">to</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">total</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">from</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="st">to</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="i">total</span><span class="h"> </span><span class="o">+</span><span class="o">=</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">total</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">int</span><span class="h"> </span><span class="e">partition</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">k</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">k</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="e">sum</span><span class="sy">(</span><span class="i">A</span><span class="sy">,</span><span class="h"> </span><span class="cn">0</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">n</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="cn">1</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">best</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">INT_MAX</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="v">best</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">min</span><span class="sy">(</span><span class="i">best</span><span class="sy">,</span><span class="h"> </span><span class="e">max</span><span class="sy">(</span><span class="e">partition</span><span class="sy">(</span><span class="i">A</span><span class="sy">,</span><span class="h"> </span><span class="i">j</span><span class="sy">,</span><span class="h"> </span><span class="i">k</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">,</span><span class="h"> </span><span class="e">sum</span><span class="sy">(</span><span class="i">A</span><span class="sy">,</span><span class="h"> </span><span class="i">j</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="i">best</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

As you already knew, the brute force solution is definitely not very
efficient. It is exponential in run time complexity due to
re-computation of the same values over and over again. We can do much
better by caching our results in a *k*x*N* table utilizing Dynamic
programming (DP). The table has to be constructed in a way such that the
sub-problems are calculated first in a bottom-up fashion.

Each entry in the table needs *O*(*N*<sup>2</sup>) time to calculate.
This is due to the summation term (**∑**{i=j..n-1} A<sub>i</sub>) needs
*O*(*N*) time, and on top of that you need to find the minimum across
all partitions which increases the complexity by an order to
O(*N*<sup>2</sup>). Since there are a total of *kN* entries in the
table, the overall run time complexity has to be *O*(*kN*<sup>3</sup>).

It is easy to further reduce the complexity down to
*O*(*kN*<sup>2</sup>). The extra calculation of the summation term
(**∑**{i=j..n-1} A<sub>i</sub>) can be easily avoided by caching the
results using an array that stores cumulative sums.

Below is the DP solution with *O*(*kN*<sup>2</sup>) run time and using
*O*(*kN*) space complexity.

const int MAX\_N = 100; int findMax(int A[], int n, int k) { int
M[MAX\_N+1][MAX\_N+1] = {0}; int cum[MAX\_N+1] = {0}; for (int i = 1; i
\<= n; i++) cum[i] = cum[i-1] + A[i-1]; for (int i = 1; i \<= n; i++)
M[i][1] = cum[i]; for (int i = 1; i \<= k; i++) M[1][i] = A[0]; for (int
i = 2; i \<= k; i++) { for (int j = 2; j \<= n; j++) { int best =
INT\_MAX; for (int p = 1; p \<= j; p++) { best = min(best,
max(M[p][i-1], cum[j]-cum[p])); } M[j][i] = best; } } return M[n][k]; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="m">const</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">MAX_N</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">100</span><span class="sy">;</span></p>
<p><span class="t">int</span><span class="h"> </span><span class="e">findMax</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">k</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">M</span><span class="sy">[</span><span class="i">MAX_N</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">MAX_N</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">{</span><span class="cn">0</span><span class="sy">}</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">cum</span><span class="sy">[</span><span class="i">MAX_N</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">{</span><span class="cn">0</span><span class="sy">}</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="v">cum</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">cum</span><span class="sy">[</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="v">M</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">cum</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">k</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="v">M</span><span class="sy">[</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">A</span><span class="sy">[</span><span class="cn">0</span><span class="sy">]</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">2</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">k</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">2</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="t">int</span><span class="h"> </span><span class="v">best</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">INT_MAX</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">p</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">p</span><span class="h"> </span><span class="o">&lt;=</span><span class="h"> </span><span class="i">j</span><span class="sy">;</span><span class="h"> </span><span class="i">p</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">        </span><span class="v">best</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">min</span><span class="sy">(</span><span class="i">best</span><span class="sy">,</span><span class="h"> </span><span class="e">max</span><span class="sy">(</span><span class="v">M</span><span class="sy">[</span><span class="i">p</span><span class="sy">]</span><span class="sy">[</span><span class="i">i</span><span class="o">-</span><span class="cn">1</span><span class="sy">]</span><span class="sy">,</span><span class="h"> </span><span class="v">cum</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="o">-</span><span class="v">cum</span><span class="sy">[</span><span class="i">p</span><span class="sy">]</span><span class="sy">)</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">      </span><span class="sy">}</span></p>
<p><span class="h">      </span><span class="v">M</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">best</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="v">M</span><span class="sy">[</span><span class="i">n</span><span class="sy">]</span><span class="sy">[</span><span class="i">k</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**<span>Follow up:</span>**  
 Could you think of another non DP algorithm which doesn’t requires any
extra space?

**<span>» Continue reading</span> [Part II: The Painter’s Partition
Problem.](http://www.leetcode.com/2011/04/the-painters-partition-problem-part-ii.html)**

VN:F [1.9.22\_1171]

Rating: 4.4/**5** (10 votes cast)

<span class="hreview-aggregate"><span class="item"><span class="fn">The
Painter's Partition Problem Part I</span></span>, <span
class="rating"><span class="average">4.4</span> out of <span
class="best">5</span> based on <span class="votes">10</span> ratings
<span class="summary"></span></span></span>

> A robot is located at the top-left corner of a *m* x *n* grid (marked
> ‘Start’ in the diagram below). The robot can only move either down or
> right at any point in time. The robot is trying to reach the
> bottom-right corner of the grid (marked ‘Finish’ in the diagram
> below). How many possible unique paths are there?

<span id="more-52"></span>

[![](http://leetcode.com/wp-content/uploads/2014/12/robot_maze.png)](http://leetcode.com/wp-content/uploads/2014/12/robot_maze.png)

<span>Note: The grid above is 7×3, and is used to illustrate the
problem.</span>

This question appears originally from [Google Treasure
Hunt](http://treasurehunt.appspot.com/historic/robot/). This problem is
interesting because it can be solved using multiple approaches.

**Hint:** Try to use the most direct way to solve it, and see if you can
improve the efficiency.

**Backtracking Solution:**  
 The most direct way is to **** write code that traverses each possible
path, which can be done using backtracking. When you reach row=*m* and
col=*n*, you know you’ve reached the bottom-right corner, and there is
one additional unique path to it. However, when you reach row\>*m* or
col\>*n*, then it’s an invalid path and you should stop traversing. For
any grid at row=*r* and col=*c*, you have two choices: Traverse to the
right or traverse to the bottom. Therefore, the total unique paths at
grid (*r*,*c*) is equal to the sum of total unique paths from the grid
to the right and the grid below. Below is the backtracking code in 5
lines of code:

int backtrack(int r, int c, int m, int n) { if (r == m && c == n) return
1; if (r \> m || c \> n) return 0; return backtrack(r+1, c, m, n) +
backtrack(r, c+1, m, n); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="t">int</span><span class="h"> </span><span class="e">backtrack</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">r</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">c</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">m</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">r</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">m</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">c</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">r</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">m</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">c</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="e">backtrack</span><span class="sy">(</span><span class="i">r</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">c</span><span class="sy">,</span><span class="h"> </span><span class="i">m</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="e">backtrack</span><span class="sy">(</span><span class="i">r</span><span class="sy">,</span><span class="h"> </span><span class="i">c</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">m</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Improved Backtracking Solution using Memoization:**  
 Although the above backtracking solution is easy to code, it is very
inefficient in the sense that it recalculates the same solution for a
grid over and over again. By caching the results, we prevent
recalculation and only calculates when necessary. Here, we are using a
[dynamic programming](http://en.wikipedia.org/wiki/Dynamic_programming)
(DP) technique called
[memoization](http://en.wikipedia.org/wiki/Memoization).

const int M\_MAX = 100; const int N\_MAX = 100; int backtrack(int r, int
c, int m, int n, int mat[][N\_MAX+2]) { if (r == m && c == n) return 1;
if (r \> m || c \> n) return 0; if (mat[r+1][c] == -1) mat[r+1][c] =
backtrack(r+1, c, m, n, mat); if (mat[r][c+1] == -1) mat[r][c+1] =
backtrack(r, c+1, m, n, mat); return mat[r+1][c] + mat[r][c+1]; } int
bt(int m, int n) { int mat[M\_MAX+2][N\_MAX+2]; for (int i = 0; i \<
M\_MAX+2; i++) { for (int j = 0; j \< N\_MAX+2; j++) { mat[i][j] = -1; }
} return backtrack(1, 1, m, n, mat); }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="crayon-nums-content">
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
</div></td>
<td align="left"><div class="crayon-pre">
<p><span class="m">const</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">M_MAX</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">100</span><span class="sy">;</span></p>
<p><span class="m">const</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">N_MAX</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">100</span><span class="sy">;</span></p>
<p> </p>
<p><span class="t">int</span><span class="h"> </span><span class="e">backtrack</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">r</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">c</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">m</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="sy">]</span><span class="sy">[</span><span class="i">N_MAX</span><span class="o">+</span><span class="cn">2</span><span class="sy">]</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">r</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">m</span><span class="h"> </span><span class="o">&amp;&amp;</span><span class="h"> </span><span class="v">c</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="i">r</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">m</span><span class="h"> </span><span class="o">||</span><span class="h"> </span><span class="i">c</span><span class="h"> </span><span class="o">&gt;</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">return</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">mat</span><span class="sy">[</span><span class="i">r</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">c</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="v">mat</span><span class="sy">[</span><span class="i">r</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">c</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">backtrack</span><span class="sy">(</span><span class="i">r</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">c</span><span class="sy">,</span><span class="h"> </span><span class="i">m</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="i">mat</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">if</span><span class="h"> </span><span class="sy">(</span><span class="v">mat</span><span class="sy">[</span><span class="i">r</span><span class="sy">]</span><span class="sy">[</span><span class="i">c</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">==</span><span class="h"> </span><span class="o">-</span><span class="cn">1</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="v">mat</span><span class="sy">[</span><span class="i">r</span><span class="sy">]</span><span class="sy">[</span><span class="i">c</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="e">backtrack</span><span class="sy">(</span><span class="i">r</span><span class="sy">,</span><span class="h"> </span><span class="i">c</span><span class="o">+</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">m</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="i">mat</span><span class="sy">)</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">r</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">c</span><span class="sy">]</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">r</span><span class="sy">]</span><span class="sy">[</span><span class="i">c</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
<p> </p>
<p><span class="t">int</span><span class="h"> </span><span class="e">bt</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">m</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">M_MAX</span><span class="o">+</span><span class="cn">2</span><span class="sy">]</span><span class="sy">[</span><span class="i">N_MAX</span><span class="o">+</span><span class="cn">2</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">i</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">M_MAX</span><span class="o">+</span><span class="cn">2</span><span class="sy">;</span><span class="h"> </span><span class="i">i</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">j</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">0</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="h"> </span><span class="o">&lt;</span><span class="h"> </span><span class="i">N_MAX</span><span class="o">+</span><span class="cn">2</span><span class="sy">;</span><span class="h"> </span><span class="i">j</span><span class="o">++</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">      </span><span class="v">mat</span><span class="sy">[</span><span class="i">i</span><span class="sy">]</span><span class="sy">[</span><span class="i">j</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="o">-</span><span class="cn">1</span><span class="sy">;</span></p>
<p><span class="h">    </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="sy">}</span></p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="e">backtrack</span><span class="sy">(</span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="cn">1</span><span class="sy">,</span><span class="h"> </span><span class="i">m</span><span class="sy">,</span><span class="h"> </span><span class="i">n</span><span class="sy">,</span><span class="h"> </span><span class="i">mat</span><span class="sy">)</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Dynamic Programming Solution using Bottom-up Approach:**  
 If you notice closely, the above DP solution is using a top-down
approach. Now let’s try a bottom-up approach. Remember this important
relationship that is necessary for this DP solution to work:

The total unique paths at grid (*r*,*c*) is equal to the sum of total
unique paths from grid to the right (*r*,*c*+1) and the grid below
(*r*+1,*c*).

How can this relationship help us solve the problem? We observe that all
grids of the bottom edge and right edge must all have only one unique
path to the bottom-right corner. Using this as the base case, we can
build our way up to our solution at grid (1,1) using the relationship
above.

[![](http://leetcode.com/wp-content/uploads/2014/12/robot_maze_dp.png)](http://leetcode.com/wp-content/uploads/2014/12/robot_maze_dp.png)

<span>The total unique paths at grid (*r*,*c*) is equal to the sum of
total unique paths from grid to the right (*r*,*c*+1) and the grid below
(*r*+1,*c*).</span>

const int M\_MAX = 100; const int N\_MAX = 100; int dp(int m, int n) {
int mat[M\_MAX+2][N\_MAX+2] = {0}; mat[m][n+1] = 1; for (int r = m;
r \>= 1; r--) for (int c = n; c \>= 1; c--) mat[r][c] = mat[r+1][c] +
mat[r][c+1]; return mat[1][1]; }
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><div class="crayon-pre">
<p><span class="m">const</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">M_MAX</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">100</span><span class="sy">;</span></p>
<p><span class="m">const</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="v">N_MAX</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">100</span><span class="sy">;</span></p>
<p> </p>
<p><span class="t">int</span><span class="h"> </span><span class="e">dp</span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="i">m</span><span class="sy">,</span><span class="h"> </span><span class="t">int</span><span class="h"> </span><span class="i">n</span><span class="sy">)</span><span class="h"> </span><span class="sy">{</span></p>
<p><span class="h">  </span><span class="t">int</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">M_MAX</span><span class="o">+</span><span class="cn">2</span><span class="sy">]</span><span class="sy">[</span><span class="i">N_MAX</span><span class="o">+</span><span class="cn">2</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="sy">{</span><span class="cn">0</span><span class="sy">}</span><span class="sy">;</span></p>
<p><span class="h">  </span><span class="v">mat</span><span class="sy">[</span><span class="i">m</span><span class="sy">]</span><span class="sy">[</span><span class="i">n</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">r</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">m</span><span class="sy">;</span><span class="h"> </span><span class="i">r</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">r</span><span class="o">--</span><span class="sy">)</span></p>
<p><span class="h">    </span><span class="st">for</span><span class="h"> </span><span class="sy">(</span><span class="t">int</span><span class="h"> </span><span class="v">c</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="i">n</span><span class="sy">;</span><span class="h"> </span><span class="i">c</span><span class="h"> </span><span class="o">&gt;=</span><span class="h"> </span><span class="cn">1</span><span class="sy">;</span><span class="h"> </span><span class="i">c</span><span class="o">--</span><span class="sy">)</span></p>
<p><span class="h">      </span><span class="v">mat</span><span class="sy">[</span><span class="i">r</span><span class="sy">]</span><span class="sy">[</span><span class="i">c</span><span class="sy">]</span><span class="h"> </span><span class="o">=</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">r</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="i">c</span><span class="sy">]</span><span class="h"> </span><span class="o">+</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="i">r</span><span class="sy">]</span><span class="sy">[</span><span class="i">c</span><span class="o">+</span><span class="cn">1</span><span class="sy">]</span><span class="sy">;</span></p>
<p> </p>
<p><span class="h">  </span><span class="st">return</span><span class="h"> </span><span class="v">mat</span><span class="sy">[</span><span class="cn">1</span><span class="sy">]</span><span class="sy">[</span><span class="cn">1</span><span class="sy">]</span><span class="sy">;</span></p>
<p><span class="sy">}</span></p>
</div></td>
</tr>
</tbody>
</table>

**Combinatorial Solution:**  
 It turns out this problem could be solved using combinatorics, which no
doubt would be the most efficient solution. In order to see it as a
combinatorial problem, there are some necessary observations. Look at
the 7×3 sample grid in the picture above. Notice that no matter how you
traverse the grids, you always traverse a total of 8 steps. To be more
exact, you always have to choose 6 steps to the right (**R**) and 2
steps to the bottom (**B**). Therefore, the problem can be transformed
to a question of how many ways can you choose 6**R**‘s and 2**B**‘s in
these 8 steps. The answer is **C**(8,2) (or **C**(8,6)). Therefore, the
general solution for a *m* x *n* grid is **C**(*m*+*n*-2, *m*-1).

**Further Thoughts:**

Now consider if some obstacles are added to the grids marked as ‘X’. How
many unique paths would there be? A combinatorial solution is difficult
to obtain (I don’t know myself, quite frankly), but the DP solution can
be modified easily to accommodate this constraint.

VN:F [1.9.22\_1171]

Rating: 4.9/**5** (30 votes cast)

<span class="hreview-aggregate"><span class="item"><span
class="fn">Unique Paths</span></span>, <span class="rating"><span
class="average">4.9</span> out of <span class="best">5</span> based on
<span class="votes">30</span> ratings <span
class="summary"></span></span></span>

